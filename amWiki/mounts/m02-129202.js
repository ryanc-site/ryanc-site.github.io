if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m02']=[{"name":"01-设计模式总述.md","path":"02-java篇/02-技术栈/01-设计模式/01-设计模式总述.md","content":"# 设计模式总述\n\n> 设计模式总体来说分为三大类：<span style=\"color:#42B983;font-weight:bold;\">创建型、结构型 和 行为型</span></br>\n>\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2020年12月16日19:45:40</span>\n\n## 一、设计模式分类\n\n<span style=\"color:#42B983;font-weight:bold;\">创建型模式</span>\n共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。\n\n<span style=\"color:#42B983;font-weight:bold;\">结构型模式</span>\n共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。\n\n<span style=\"color:#42B983;font-weight:bold;\">行为型模式</span>\n共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。\n\n其实还有两类：<span style=\"color:#FF531A;font-weight:bold;\">并发型模式</span> 和 <span style=\"color:#FF531A;font-weight:bold;\">线程池模式</span>。\n\n## 二、设计模式遵循原则\n\n> 设计模式的    <span style=\"color:#42B983;font-weight:bold;\">六大原则</span>\n\n### 总原则：开闭原则\n\n> **开闭原则**：即 <span style=\"color:#42B983;font-weight:bold;\">开放-封闭</span> 原则，软件实体可以扩展但不可修改。\n\n<span style=\"color:#FF531A;font-weight:bold;\">个人理解：</span>\n\n**这个原则其实是有两个特征的：**\n\n* 一、对于扩展是开放的：</br>\n  设计程序实体不可能达到绝对的封闭，也不可能做到一次设计就能应对日后的变化</br>\n  所以需要在设计程序实体时就:<span style=\"color:#FF531A;font-weight:bold;\">考虑   到日后可能的变化，尽可能的抽象变化使程序实体能够被扩展。</span>\n\n* 二、对于更改是封闭的：</br>\n  就像在“一”中提到的，程序实体的设计是没有办法做的一次设计就应对日后所有的变换，</br>\n  在程序实体设计完成,开发工作也完成后，需求是会有变更或新增。</br>\n  而我们设计的程序实体在面对需求时：<span style=\"color:#FF531A;font-weight:bold;\">对程序实体的改动是通过新增代码\n  而不是更改现有的代码</span>\n\n\n\n### 1、单一职责原则\n\n> **单一职责原则：**就一个程序实体而言，<span style=\"color:#42B983;font-weight:bold;\">有且仅有</span> 一个引起它变化的原因\n\n<span style=\"color:#FF531A;font-weight:bold;\">个人理解：</span>\n\n就设计过程中的一个类而言，应该仅有一个能引起它变化的原因；不要存在多余一个导致其发生变化的原因。</br>\n<span style=\"color:#FF531A;font-weight:bold;\">也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。</span>\n\n\n\n### 2、里氏替换原则\n\n> **里氏替换原则：**又称“**里氏代换原则**” <span style=\"color:#42B983;font-weight:bold;\">子类型</span> 必须能够替换掉  <span style=\"color:#42B983;font-weight:bold;\">它们的父类型</span>\n\n<span style=\"color:#FF531A;font-weight:bold;\">百科阅读：</span>\n\n<span style=\"border-bottom: 2px solid #0081EF;\">**里氏代换原则(**Liskov Substitution Principle LSP)面向对象设计的基本原则之一。</span> </br>\n<span style=\"border-bottom: 2px solid #0081EF;\">里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。</span> </br>\n<span style=\"border-bottom: 2px solid #0081EF;\">LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，</span></br>\n<span style=\"border-bottom: 2px solid #0081EF;\">基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</span></br>\n<span style=\"border-bottom: 2px solid #0081EF;\">里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。</span></br>\n<span style=\"border-bottom: 2px solid #0081EF;\">而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</span>\n\n\n\n<span style=\"color:#FF531A;font-weight:bold;\">个人理解：</span>\n\n一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它<span style=\"color:#FF531A;font-weight:bold;\">察觉不出父亲对象和子类对象的区别</span></br>\n<span style=\"color:#FF531A;font-weight:bold;\">也就是说：在软件实体中，把父类替换成它的子类，程序实体没有影响</span>\n\n\n\n### 3、依赖倒转原则\n\n> **依赖倒转原则：**\n> ​\t\tA、高层模块不应该依赖底层模块，两个都应该抽象依赖\n> ​\t\tB、抽象不应该依赖细节，细节已改依赖抽象\n\n<span style=\"color:#FF531A;font-weight:bold;\">个人理解：</span>\n\n**这个是开闭原则的基础，具体内容：**</br>\n\n   <span style=\"color:#FF531A;font-weight:bold;\">面向接口编程，依赖于抽象而不依赖于具体。</span></br>\n\n   <span style=\"color:#FF531A;font-weight:bold;\">写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</span></br>\n\n\n\n### 4、接口隔离原则\n\n> **依赖倒转原则：**\n> 程序实体不应该依赖它不需要的接口。一个程序实体对另一个程序实体的依赖应该建立在最小的接口上。\n\n<span style=\"color:#FF531A;font-weight:bold;\">个人理解：</span>\n\n<span style=\"color:#FF531A;font-weight:bold;\">每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。</span></br>\n使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。\n\n\n\n### 5、迪米特法则\n\n> **迪米特法则：**又称 **最少知识原则** 一个程序实体对另一个程序实体知道的<span style=\"color:#42B983;font-weight:bold;\"> 越少越好</span>\n\n<span style=\"color:#FF531A;font-weight:bold;\">个人理解：</span>\n\n一个类对自己依赖的类知道的越少越好。<br>\n也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。</br>\n这样当被依赖的类变化时，才能最小的影响该类。</br>\n\n<span style=\"color:#FF531A;font-weight:bold;\">如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用</span></br>\n<span style=\"color:#FF531A;font-weight:bold;\">如果其中一个程序实体需要调用另外一个程序实体，可以通过第三者转发这个调用</span></br>\n\n<span style=\"border-bottom: 2px solid #42B983;\">**最少知道原则** 的另一个表达方式是：只与直接的朋友通信。</span></br>\n<span style=\"border-bottom: 2px solid #42B983;\">类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。</span></br>\n<span style=\"border-bottom: 2px solid #42B983;\">我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。</span></br>\n<span style=\"border-bottom: 2px solid #42B983;\">我们要求陌生的类不要作为局部变量出现在类中。</span></br>\n\n\n\n### 6、合成复用原则\n\n> **合成复用原则：**尽量使用<span style=\"color:#42B983;font-weight:bold;\">   合成/聚合</span>，尽量不要使用<span style=\"color:#42B983;font-weight:bold;\">   类继承</span>\n\n<span style=\"color:#FF531A;font-weight:bold;\">个人理解：</span>\n\n* **聚合**</br>\n\n  聚合表示一种弱的“拥有”关系，体现的是<span style=\"color:#FF531A;font-weight:bold;\">A对象可以包含B对象</span>，但是<span style=\"color:#FF531A;font-weight:bold;\">B对象不是A对象的一部分</span>\n\n* **合成**  </br>\n\n  合成则是一种强的“拥有”关系，体现了<span style=\"color:#FF531A;font-weight:bold;\">严格的部分和整体的关系，部分和整体的生命周期一样</span>\n","timestamp":1618132041402},{"name":"01-工厂方法模式.md","path":"02-java篇/02-技术栈/01-设计模式/02-创建型/01-工厂方法模式.md","content":"# 工厂方法模式\n\n> 前置：<span style=\"color:#42B983;font-weight:bold;\">工厂方法模式</span> 之前我们先来解读以下 <span style=\"color:#FF531A;font-weight:bold;\">简单工厂模式</span></br>\n>\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2020年12月20日10:46:06</span>\n\n## 一、简单工厂模式\n\n### 1、模式类图\n\n![image-20201220101334913](amWiki/images/lib_img/image-20201220101334913.png \"简单工厂模式类图\")\n\n### 2、简单工厂解读\n\n#### a、_Algorithm(inf : 产品规则)\n\n><span style=\"color:#42B983;font-weight:bold;\">规则制定</span>：规定产品的规格(例：算法要实现什么功能)\n\n~~~java\npublic interface _Algorithm {\n\n    // 产品规格：计算\n\tpublic void calc(int num1,int num2);\n\n}\n~~~\n\n\n\n#### b、_XXXAlgorithm(class：具体产品)\n\n> <span style=\"color:#42B983;font-weight:bold;\">具体的产品</span>：产品在满足产品规格情况下的具体细节(加法算法、减法算法 or 乘法算法...)我们以加法为例\n\n~~~java\npublic class _AddAlgorithm implements _Algorithm {\n\n    // 具体产品：时间 num1 和 num2 的求和\n\tpublic void calc(int num1,int num2) {\n\t\tSoutUtil.soutObject(num1 + \"+\" + num2 + \"=\" + (num1 + num2));\n\t}\n\n}\n~~~\n\n\n\n#### c、_AlgorithmFactory(class：产品工厂)\n\n> <span style=\"color:#42B983;font-weight:bold;\">产品工厂</span>：按照客户的需求生产具体的产品（生成 加法算法、减法算法。。。产品）\n\n~~~java\npublic class _AlgorithmFactory {\n\n    // 算法标识\n\tpublic static final String ALG_MARK_ADD = \"+\";\n\tpublic static final String ALG_MARK_SUB = \"-\";\n\tpublic static final String ALG_MARK_MUL = \"*\";\n\tpublic static final String ALG_MARK_DIV = \"/\";\n\n\t// 依据客户端的算法请求，生产对应的算法产品\n\tpublic _Algorithm produceAlgorithm(String algMark) {\n\t\t_Algorithm target = null;\n\t\tswitch (algMark) {\n\t\t\tcase ALG_MARK_ADD :\n\t\t\t\ttarget = new _AddAlgorithm(); break;\n\t\t\tcase ALG_MARK_SUB :\n\t\t\t\ttarget = new _SubAlgorithm(); break;\n\t\t\tcase ALG_MARK_MUL :\n\t\t\t\ttarget = new _MulAlgorithm(); break;\n\t\t\tcase ALG_MARK_DIV :\n\t\t\t\ttarget = new _DivAlgorithm(); break;\n\t\t}\n\t\treturn target;\n\t}\n}\n~~~\n\n#### d、test\n\n~~~java\n/**\n *  简单工厂模式\n */\n@Test\npublic void simpleFactoryPattern() {\n    SoutUtil.soutFrame(\"*\", Constant.SOUT_FRAME_START);\n    int a = 10,b = 5;\n    // 简单算法工厂\n    _AlgorithmFactory factory = new _AlgorithmFactory();\n\n    _Algorithm add = factory.produceAlgorithm(factory.ALG_MARK_ADD);\n    add.calc(a, b);\n\n    _Algorithm sub = factory.produceAlgorithm(factory.ALG_MARK_SUB);\n    sub.calc(a, b);\n\n    _Algorithm mul = factory.produceAlgorithm(factory.ALG_MARK_MUL);\n    mul.calc(a, b);\n\n    _Algorithm div = factory.produceAlgorithm(factory.ALG_MARK_DIV);\n    div.calc(a, b);\n\n    SoutUtil.soutFrame(\"*\", Constant.SOUT_FRAME_END);\n}\n~~~\n\n\n\n## 二、工厂方法模式\n\n### 1、模式类图\n\n![image-20201220111836726](amWiki/images/lib_img/image-20201220111836726.png \"工厂方法模式类图\")\n\n### 2、工厂方法解读\n\n#### a、Algorithm(inf：产品规则)\n\n> <span style=\"color:#42B983;font-weight:bold;\">规则制定</span>：规定产品的规格(例：算法要实现什么功能)\n\n~~~java\npublic interface Algorithm {\n\t// 产品的规格\n\tpublic void calc(int num1,int num2);\n\n}\n~~~\n\n\n\n#### b、xxxAlgorithm(class：具体产品)\n\n> <span style=\"color:#42B983;font-weight:bold;\">具体的产品</span>：产品在满足产品规格情况下的具体细节(加法算法、减法算法 or 乘法算法...)我们以加法为例\n\n~~~java\npublic class AddAlgorithm implements Algorithm {\n\n    // 产品的具体细节\n\t@Override\n\tpublic void calc(int num1, int num2) {\n\t\tSoutUtil.soutObject(num1 + \"+\" + num2 + \"=\" + (num1 + num2));\t\t\n\t}\n\n\n}\n~~~\n\n\n\n#### c、IFactory(inf：工厂标准)\n\n> <span style=\"color:#42B983;font-weight:bold;\">工厂标准</span>：制定产品供应商的生产标准\n\n~~~java\npublic interface IFactory {\n    // 工厂的生产标准\n\tpublic Algorithm produceAlgorithm();\n}\n~~~\n\n\n\n#### d、xxxFactory(class：产品供应商-工厂)\n\n> <span style=\"color:#42B983;font-weight:bold;\">产品供应商</span>：在满足产品供应商标准的情况下生产产品\n\n~~~java\npublic class AddFactory implements IFactory {\n\t// 供应商生产产品的具体细节\n\t@Override\n\tpublic Algorithm produceAlgorithm() {\n\t\treturn new AddAlgorithm();\n\t}\n\n}\n~~~\n\n#### f、test\n\n~~~java\n/**\n * 工厂方法模式\n */\n@Test\npublic void factoryFunctionPattern() {\n    SoutUtil.soutFrame(\"*\", Constant.SOUT_FRAME_START);\n\n    int a = 10,b = 5;\n\n    // 加法供货商\n    IFactory addFactory = new AddFactory();\n    Algorithm add  = addFactory.produceAlgorithm();\n    add.calc(a, b);\n\n    IFactory subFactory = new SubFactory();\n    Algorithm sub  = subFactory.produceAlgorithm();\n    sub.calc(a, b);\n\n    IFactory mulFactory = new MulFactory();\n    Algorithm mul  = mulFactory.produceAlgorithm();\n    mul.calc(a, b);\n\n    IFactory divFactory = new DivFactory();\n    Algorithm div  = divFactory.produceAlgorithm();\n    div.calc(a, b);\n\n\n    SoutUtil.soutFrame(\"*\", Constant.SOUT_FRAME_END);\n}\n~~~\n\n\n\n## 三、综述\n\n### 1、简单工厂模式\n\n<span style=\"color:#FF531A;font-weight:bold;\">简单工厂模式</span>   <span style=\"border-bottom: 2px solid #0081EF;\">的最大有点在于工厂类中包含了必要的逻辑判断</span></br>\n\n根据客户端的选择条件动态的实例化相关类，对于客户端来说，是去除了于具体产品的依赖\n\n### 2、工厂方法模式\n\n<span style=\"color:#FF531A;font-weight:bold;\">工厂方法模式</span>    定义一个用于创建对象的接口，让子类决定实例化哪个类</br>\n\n<span style=\"border-bottom: 2px solid #0081EF;\">**工厂方法使一个类的实例化延迟到其子类**</span>\n\n\n\n## 四、附录\n\n### 1、工具类SoutUtil\n\n~~~java\npublic class SoutUtil {\n    /**\n     * 打印边框 行为\n     * @param flagBit  打印边框的样式 ：*、》、> 、+ 、= 、-\n     */\n    public static void soutFrame(String flagBit, String action){\n        int loopSize = Constant.SOUT_FRAME_START.equals(action) ? 120 : 122;\n        System.out.print(Constant.SOUT_FRAME_START.equals(action) \n             ? action : \">>\\n\" + action);\n        \n        for (int i = 0; i < loopSize; i++) {\n            System.out.print(flagBit);\n        }\n        System.out.println(Constant.SOUT_FRAME_START.equals(action) ? \"\\n>>\":\"\");\n    }\n\n\n    /**\n     * 格式化输出obj 依赖 soutFrame\n     * @param obj\n     */\n    public static void soutObject(Object obj){\n        System.out.println(\">>   \" + obj);\n    }\n}\n~~~\n","timestamp":1618132041402},{"name":"02-抽象工厂模式.md","path":"02-java篇/02-技术栈/01-设计模式/02-创建型/02-抽象工厂模式.md","content":"# 抽象工厂模式\n\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2020年12月20日14:42:14</span>\n\n## 一、模式类图\n\n![image-20201220144416892](amWiki/images/lib_img/image-20201220144416892.png \"抽象工厂模式类图\")\n\n\n\n## 二、抽象工厂解读\n\n### 1、AbstractFactory(abst：工厂抽象)\n\n> <span style=\"color:#42B983;font-weight:bold;\">工厂抽象</span>：包含所有产品的生产规格\n\n~~~java\npublic abstract class AbstractFactory {\n\n\t// 普通算法生产规格\n\tpublic abstract NormalAlgorithm produceNormalAlg();\n\t\n\t// 科学算法生产规格\n\tpublic abstract ScienceAlgorithm produceScienceAlg();\n\t\n}\n~~~\n\n\n\n\n\n### 2、NormalAlgorithmIFactory(class：normal工厂)\n\n><span style=\"color:#42B983;font-weight:bold;\">normal工厂</span>：normal产品的生产细节\n\n~~~java\npublic class NormalAlgorithmIFactory extends AbstractFactory {\n\n\t@Override\n\tpublic NormalAlgorithm produceNormalAlg() {\n\t\treturn new AddAlgorithm();\n\t}\n\n\t@Override\n\tpublic ScienceAlgorithm produceScienceAlg() {\n\t\treturn null;\n\t}\n\n\t\n}\n~~~\n\n\n\n### 2.1、NorMalAlgorithm(inf：normal产品规则)\n\n> <span style=\"color:#42B983;font-weight:bold;\">normal产品规则</span>：normal的使用规格（api）\n\n~~~java\npublic interface NormalAlgorithm {\n\n\t// 普通算法：求两数之和\n\tpublic void calc(int num1,int num2);\n\t\n}\n~~~\n\n\n\n### 2.1.1、AddAlgorithm(class：add产品)\n\n> <span style=\"color:#42B983;font-weight:bold;\">add产品</span>：normal类产品的一种具体产品\n\n~~~java\npublic class AddAlgorithm implements NormalAlgorithm {\n\n\t// 普通算法具体实现：求和\n\t@Override\n\tpublic void calc(int num1, int num2) {\n\t\tSoutUtil.soutObject(num1 + \"+\" + num2 + \"=\" + (num1 + num2));\t\t\n\t}\n\n}\n~~~\n\n### -------\n\n### 3、ScienceAlgorithmIFactory(class：science工厂)\n\n> <span style=\"color:#42B983;font-weight:bold;\">science工厂</span>：science产品的生产细节\n\n~~~java\npublic class ScienceAlgorithmIFactory extends AbstractFactory {\n\n\t@Override\n\tpublic NormalAlgorithm produceNormalAlg() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic ScienceAlgorithm produceScienceAlg() {\n\t\treturn new AbsAlgorithm();\n\t}\n\n}\n~~~\n\n\n\n### 3.1、ScienceAlgorithm(inf：science产品规则)\n\n> <span style=\"color:#42B983;font-weight:bold;\">science产品规则</span>：science的使用规格（api）\n\n~~~java\npublic interface ScienceAlgorithm {\n\n\t// 科学算法接口标准：求平方\n\tpublic void abs(int num);\n}\n\n~~~\n\n\n\n### 3.1.1、AbsAlgorithm(class：asb产品)\n\n> <span style=\"color:#42B983;font-weight:bold;\">asb产品</span>：science类产品的一种具体产品\n\n~~~java\npublic class AbsAlgorithm implements ScienceAlgorithm {\n\n\t// 科学算法具体实现：求方\n\t@Override\n\tpublic void abs(int num) {\n\t\tSoutUtil.soutObject(num + \"² =\" + (num * num));\t\t\n\t}\n\n}\n~~~\n\n### 4、test\n\n~~~java\n@Test\npublic void abstractFactoryPattern(){\n    SoutUtil.soutFrame(\"*\", Constant.SOUT_FRAME_START);\n\n    int a = 10,b = 5;\n\n    // 普通算法\n    AbstractFactory normalFactory = new NormalAlgorithmIFactory();\n    normalFactory.produceNormalAlg().calc(a, b);\n\n    // 科学算法\n    AbstractFactory scienceFactory = new ScienceAlgorithmIFactory();\n    scienceFactory.produceScienceAlg().abs(a);\n\n    SoutUtil.soutFrame(\"*\", Constant.SOUT_FRAME_END);\n}\n~~~\n\n\n\n## 三、综述\n\n### 1、简单说明\n\n​\ta、本例只对工厂进行了抽象，感兴趣的小伙伴可以自行对产品规格也进行抽象的定制化</br>\n\n​\tb、对于产品的实例化一律采用了new的方式，小伙伴们也可以用反射等高大上方式\n\n\n\n## 四、附录\n\n### 1、工具类SoutUtil\n\n~~~ java\npublic class SoutUtil {\n    /**\n     * 打印边框 行为\n     * @param flagBit  打印边框的样式 ：*、》、> 、+ 、= 、-\n     */\n    public static void soutFrame(String flagBit, String action){\n        int loopSize = Constant.SOUT_FRAME_START.equals(action) ? 120 : 122;\n        System.out.print(Constant.SOUT_FRAME_START.equals(action) \n              ? action : \">>\\n\" + action);\n        \n        for (int i = 0; i < loopSize; i++) {\n            System.out.print(flagBit);\n        }\n        System.out.println(Constant.SOUT_FRAME_START.equals(action) ? \"\\n>>\":\"\");\n    }\n\n\n    /**\n     * 格式化输出obj 依赖 soutFrame\n     * @param obj\n     */\n    public static void soutObject(Object obj){\n        System.out.println(\">>   \" + obj);\n    }\n}\n~~~\n\n\n\n","timestamp":1618132041402},{"name":"03-单例模式.md","path":"02-java篇/02-技术栈/01-设计模式/02-创建型/03-单例模式.md","content":"# 单例模式\n\n> <span style=\"color:#42B983;font-weight:bold;\">单例模式：</span>保证一个类有且仅有一个实例，并提供一个访问它（单例实例）的全局访问点\n>\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2021年01月10日22:37:07</span>\n\n## 一、单例类图结构\n\n![image-20210110225313174](amWiki/images/lib_img/image-20210110225313174.png)\n\n<span style=\"color:#FF531A;font-weight:bold;\">即：</span>\n\n​     <span style=\"border-bottom: 2px solid #0081EF;\">通常我们可以让一个全局变量使得一个对象被访问，但是它不能防止你实例化多个对象。</span></br>\n<span style=\"border-bottom: 2px solid #0081EF;\">而解决其最好的方法就是：让其自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建</span></br>\n<span style=\"border-bottom: 2px solid #0081EF;\">并且它可以提供一个访问其自身唯一实例的方法。</span>\n\n</br></br></br>\n\n## 二、懒汉式单例\n\n> <span style=\"color:#42B983;font-weight:bold;\">懒汉式：</span>指全局单例实例在第一次被使用时构建\n\n### 1、简单版本\n\n~~~java\npublic class Single1 {\n    private static Single1 instance;\n    public static Single1 getInstance() {\n        if (instance == null) {\n            instance = new Single1();\n        }\n        return instance;\n    }\n}\n~~~\n\n<span style=\"color:#FF531A;font-weight:bold;\">注：</span>基本按照单例原则实现单例模式，对外提供了唯一的实例访问节点。</br>\n\n<span style=\"color:#42B983;font-weight:bold;\">缺：</span>没有将实例构造器私有化，外界依旧可以获取新的实例，破坏了单一实例的原则。</br>\n\n</br></br>\n\n### 1.1、简单版本升级\n\n~~~java\npublic class Single1 {\n    private static Single1 instance;\n    private Single1() {}\n    public static Single1 getInstance() {\n        if (instance == null) {\n            instance = new Single1();\n        }\n        return instance;\n    }\n}\n~~~\n\n<span style=\"color:#FF531A;font-weight:bold;\">注：</span>针对简单版本所暴露的不足，进行改善将其构造器私有化，实例的初始化交由实例类自己管理。</br>\n\n<span style=\"color:#42B983;font-weight:bold;\">缺：</span>看似完美，世界近乎和平！但是人一多起来一切就都变了。开个玩笑<span style=\"color:#FF531A;font-weight:bold;\">^.- !! </span></br>\n​         <span style=\"border-bottom: 2px solid #0081EF;\">这种写法在大多数的时候也是没问题的。问题在于，当多线程工作的时候，如果有多个线程</span><br>\n<span style=\"border-bottom: 2px solid #0081EF;\">同时运行到if (instance == null),都判断为null,那么两个线程就各自会创建一个实例——这样一来，就不是单例了。</span></br>\n\n</br></br>\n\n### 2、Synchronized版本\n\n> 既然简单版本对多线程的场景考虑不足，那我们就为其加入同步机制——同步锁\n\n~~~java\npublic class Single2 {\n    private static Single2 instance;\n    private Single2() {}\n    public static synchronized Single2 getInstance() {\n        if (instance == null) {\n            instance = new Single2();\n        }\n        return instance;\n    }\n}\n~~~\n\n<span style=\"color:#FF531A;font-weight:bold;\">注：</span>在单例模式实例单一原则的基础上，加入同步机制（对实例判空和初始化操作同步）确保实例唯一。</br>\n\n<span style=\"color:#42B983;font-weight:bold;\">缺：</span>对唯一实例访问节点加入同步机制，解决了多个实例出现的问题，但是给 <span style=\"border-bottom: 2px solid #0081EF;color:#FF531A;font-weight:bold;\">除了进入同步之外的线程强制增加了等待时间</span></br>\n\n</br></br>\n\n### 3、双重检查（Double-Check）\n\n> Synchronized版本其实是用了100%会出现的防护盾(延迟问题),去避免了1%几率出现的问题(多线程多实例)问题\n>\n> <span style=\"color:#42B983;font-weight:bold;\">双重检查：</span>优化了这个问题，我们继续来看\n\n~~~java\npublic class Single3 {\n    private static Single3 instance;\n    private Single3() {}\n    public static Single3 getInstance() {\n        // 无同步 - 初始化检查\n        if (instance == null) {\n            synchronized (Single3.class) {\n                // 同步 - 初始化检查\n                if (instance == null) {\n                    instance = new Single3();\n                }\n            }\n        }\n        return instance;\n    }\n}\n~~~\n\n这个版本的代码看起来有点复杂\n注意其中有两次if (instance == null)的判断，这个叫做<span style=\"color:#FF531A;font-weight:bold;\">『双重检查 Double-Check』</span>。\n\n<span style=\"color:#FF531A;font-weight:bold;\">注：</span>\n\n* **第一个if (instance == null)：**</br>\n\n  其实是为了解决Version2中的效率问题，只有instance为null的时候，才进入synchronized的代码段——大大减少了几率。</br>\n\n* **第二个if (instance == null)：**</br>\n\n   则是跟Synchronized版本一样，是为了防止可能出现多个实例的情况。</br>\n\n<span style=\"color:#42B983;font-weight:bold;\">缺：</span>这里需要前置知识：<span style=\"color:#FF531A;font-weight:bold;\">原子操作</span>  &  <span style=\"color:#FF531A;font-weight:bold;\">指令重排</span></br>\n\n而问题就出在：instance = new Single3(); </br>\n\n**1 、该操作非原子操作，分为如下三步：**\n\n​\t\ta、给instance分配内存</br>\n​       b、调用Single3构造函数初始化成员变量，完成实例化</br>\n​       c、将instance的引用指向，实例的堆内存空间</br>\n\n**2、jvm有指令重排优化，就有可能是 a - c - b**</br>\n\n​      这时问题就出现了：</br>\n​               线程t1完成了a、c，但是还未完成b，CPU时间片到了。</br>\n​               线程t2上来就判断了instance不为空，但是这时候b还未完成，此时使用实例就顺利成章的报错了</br>\n\n</br></br>\n\n### 4、volatile版本\n\n>  <span style=\"color:#42B983;font-weight:bold;\">终极版本：volatile</span>  解决了  <span style=\"color:#FF531A;font-weight:bold;\">双重检查(Double-Check)</span> 中遗留的问题，我们继续看  0.o\n\n~~~java\npublic class Single4 {\n    // 内存可见 &  禁止指令重排\n    private static volatile Single4 instance;\n    private Single4() {}\n    public static Single4 getInstance() {\n        if (instance == null) {\n            synchronized (Single4.class) {\n                if (instance == null) {\n                    instance = new Single4();\n                }\n            }\n        }\n        return instance;\n    }\n}\n~~~\n\n<span style=\"color:#FF531A;font-weight:bold;\">注：</span>\n\nvolatile关键字的一个作用是禁止指令重排，把instance声明为volatile之后，\n对它的写操作就会有一个内存屏障（什么是内存屏障？），这样，在它的赋值完成之前，就不用会调用读操作。</br>\n\n<span style=\"color:#42B983;font-weight:bold;\">缺：</span>经过4个版本的迭代应该完美了吧，世界该和平了吧！</br>\n然而并没有，这只是暴风雨（强大的反射）来临前的宁静  <span style=\"color:#FF531A;font-weight:bold;\">^.- !! </span></br>\n\n</br></br></br>\n\n## 三、饿汉式单例\n\n> <span style=\"color:#42B983;font-weight:bold;\">饿汉式：</span>指全局单例实例在类被装载时构建。下面我们接着看\n\n~~~java\npublic class SingleB {\n    // 实例在类被加载时就实例化\n    private static final SingleB INSTANCE = new SingleB();\n    private SingleB() {}\n    public static SingleB getInstance() {\n        return INSTANCE;\n    }\n}\n~~~\n\n<span style=\"color:#FF531A;font-weight:bold;\">注：</span>对于一个恶汉式单例的写法，就<span style=\"border-bottom: 2px solid #0081EF;\">目前来看式完美</span>的。\n\n<span style=\"color:#42B983;font-weight:bold;\">缺：</span>实例初始化是在类加载时进行，开发者无法精准把我实例的初始化时机，引申出以下问题：\n\n1、可能初始化的太早，造成资源浪费\n\n2、如果初始化本身依赖于一些其他资源，就很难保证其他数据在它初始化前准备就绪\n\n故：<span style=\"border-bottom: 2px solid #0081EF;\">如果所需的单例占用的资源很少，并且也不依赖于其他数据，那么这种实现方式也是很好的。</span>\n\n</br></br></br>\n\n## 四、其他单例实现\n\n### 1、静态内部类版本\n\n> <span style=\"color:#42B983;font-weight:bold;\">静态内部类写法 </span>是《Effective》一书中提倡的一种<span style=\"color:#FF531A;font-weight:bold;\">“神乎其技”</span>写法\n\n~~~java\npublic class Singleton {\n    // 静态内部类管理实例\n    private static class SingletonHolder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n    private Singleton (){}\n    public static final Singleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n~~~\n\n<span style=\"color:#FF531A;font-weight:bold;\">注：</span>这种写法非常巧妙\n\n​\t\t1、对于内部类SingletonHolder，它是一个饿汉式的单例实现，在SingletonHolder初始化的时候会由ClassLoader来保证同步，使INSTANCE是一个真·单例</br>\n\n​\t\t2、同时，由于SingletonHolder是一个内部类，只在外部类的Singleton的getInstance()中被使用，所以它被加载的时机也就是在getInstance()方法第一次被调用的时候。\n\n<span style=\"border-bottom: 2px solid #0081EF;color:#FF531A;font-weight:bold;\">——它利用了ClassLoader来保证了同步，同时又能让开发者控制类加载的时机。从内部看是一个饿汉式的单例，但是从外部看来，又的确是懒汉式的实现。简直神乎其技！！！佩服</span>\n\n</br></br>\n\n### 2、 枚举终极版本\n\n> <span style=\"color:#42B983;font-weight:bold;\">枚举写法 </span>是《Effective》一书中提倡的另一种<span style=\"color:#FF531A;font-weight:bold;\">“神乎其技”</span>的写法\n\n~~~java\npublic enum SingleInstance {\n\n    INSTANCE;\n    \n    public void fun1() { \n        // do something\n    }\n}\n// 使用\nSingleInstance.INSTANCE.fun1();\n~~~\n\n<span style=\"color:#FF531A;font-weight:bold;\">注：</span>看到了么？这是一个枚举类型……连class都不用了，极简。由于创建枚举实例的过程是线程安全的，所以这种写法也没有同步的问题。</br>\n\n<span style=\"border-bottom: 2px solid #0081EF;color:#FF531A;font-weight:bold;\">这种写法在功能上与共有域方法相近，但是它更简洁，无偿地提供了序列化机制，绝对防止对此实例化，即使是在面对复杂的序列化或者反射攻击的时候。单元素的枚举类型已经成为实现Singleton的最佳方法。</span></br>\n\n\n\n<span style=\"color:#42B983;font-weight:bold;\">缺：金无赤足，人无完人！</span>\n\n个人观点：枚举极简、安全、杜绝多实例非常优秀，但是也有不适用的场景：在需要继承场景时，它就不适用了。\n\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……\n\n</br></br>\n\n<span style=\"border-bottom: 2px solid #0081EF;color:#FF531A;font-weight:bold;\">所以，尽力做到能做到的最好就行了。</span>\n\n","timestamp":1618132041402},{"name":"04-建造者模式.md","path":"02-java篇/02-技术栈/01-设计模式/02-创建型/04-建造者模式.md","content":"","timestamp":1618132041402},{"name":"05-原型模式.md","path":"02-java篇/02-技术栈/01-设计模式/02-创建型/05-原型模式.md","content":"","timestamp":1618132041402},{"name":"01-适配器模式.md","path":"02-java篇/02-技术栈/01-设计模式/03-结构型/01-适配器模式.md","content":"","timestamp":1618132041402},{"name":"02-装饰器模式.md","path":"02-java篇/02-技术栈/01-设计模式/03-结构型/02-装饰器模式.md","content":"","timestamp":1618132041402},{"name":"03-代理模式.md","path":"02-java篇/02-技术栈/01-设计模式/03-结构型/03-代理模式.md","content":"","timestamp":1618132041402},{"name":"04-外观模式.md","path":"02-java篇/02-技术栈/01-设计模式/03-结构型/04-外观模式.md","content":"","timestamp":1618132041402},{"name":"05-桥接模式.md","path":"02-java篇/02-技术栈/01-设计模式/03-结构型/05-桥接模式.md","content":"","timestamp":1618132041402},{"name":"06-组合模式.md","path":"02-java篇/02-技术栈/01-设计模式/03-结构型/06-组合模式.md","content":"","timestamp":1618132041402},{"name":"07-享元模式.md","path":"02-java篇/02-技术栈/01-设计模式/03-结构型/07-享元模式.md","content":"","timestamp":1618132041402},{"name":"01-策略模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/01-策略模式.md","content":"","timestamp":1618132041402},{"name":"02-模板方法模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/02-模板方法模式.md","content":"","timestamp":1618132041402},{"name":"03-观察者模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/03-观察者模式.md","content":"","timestamp":1618132041402},{"name":"04-迭代子模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/04-迭代子模式.md","content":"","timestamp":1618132041402},{"name":"05-责任链模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/05-责任链模式.md","content":"","timestamp":1618132041402},{"name":"06-命令模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/06-命令模式.md","content":"","timestamp":1618132041402},{"name":"07-备忘录模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/07-备忘录模式.md","content":"","timestamp":1618132041402},{"name":"08-状态模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/08-状态模式.md","content":"","timestamp":1618132041402},{"name":"09-访问者模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/09-访问者模式.md","content":"","timestamp":1618132041402},{"name":"10-中介者模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/10-中介者模式.md","content":"","timestamp":1618132041402},{"name":"11-解释器模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/11-解释器模式.md","content":"","timestamp":1618132041402},{"name":"01-class类文件结构.md","path":"02-java篇/02-技术栈/02-jvm/01-class类文件结构.md","content":"# java类（.class）文件结构\n\n>Class文件结构是了解虚拟机的重要基础之一，如果想深入的了解虚拟机，Class文件结构是不能不了解的。\n>\n>时间：<span style=\"color:#42B983;font-weight:bold;\">2021年3月29日14:48:33</span>\n\n## 一 、概述\n\nClass文件格式只有两种数据类型：<span style=\"color:#FC5531; font-weight:bold;\">无符号数</span>  和  <span style=\"color:#FC5531; font-weight:bold;\">表</span>。\n\n* <span style=\"color:#42B983; font-weight:bold;\">无符号数 : </span>\n\n   属于基本的数据类型，以\n\n   u1 ：代表1个字节\n   u2 ：代表2个字节\n   u4 ：代表4个字节\n   u8 ：代表8个字节  的无符号数；\n\n  可用来描述数字，索引引用，数量值或者按照UTF-8编码构成的字符串值\n\n* <span style=\"color:#42B983; font-weight:bold;\">表 : </span>\n\n  由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以 <span style=\"color:#FC5531; font-weight:bold;\">“_info”</span> 结尾。\n\n  表用于描述由层次关系的复合结构的数据，整个Class文件本质上就是一张表\n\n## 二、class文件内容\n\nclass文件内容：\n\n<span style=\"color:#42B983; font-weight:bold;\">\t\t\t魔数、次版本号、主版本号、常量池计数器、常量池、访问标志、类索引、父类索引、接口计数器 </span></br>\n\n<span style=\"color:#42B983; font-weight:bold;\">接口索引集合，字段计数器、字段表集合、方法计数器、方法表集合、属性计数器、属性表集合</span></br>\n\n具体表现形式：\n\n![](assets\\20170923072656258.png)\n\n## 三、魔数与class文件版本\n\n* <span style=\"color:#42B983; font-weight:bold;\">魔数 : </span>\n\n  Class 文件的头 4 个字节称为魔数，用来表示这个 Class 文件的类型</br>\n\n  Class 文件的魔数是用 16 进制表示的“CAFE BABE”，是不是很具有浪漫色彩？</br>\n\n  ![1617009147770](assets\\1617009147770.png)\n\n> 魔数相当于文件后缀名，只不过后缀名容易被修改，不安全，因此在 Class 文件中标识文件类型比较合适。\n\n\n\n* <span style=\"color:#42B983; font-weight:bold;\">class文件版本 : </span></br>\n\n  **紧接着魔数的4个字节是Class文件的版本号**：</br>\n\n  第5,6字节是次版本号（Minor Version）</br>\n\n  第7,8字节是主版本号（Major Version）</br>\n\n  ![1617009187240](assets\\1617009187240.png)\n\n> 如上例：0x00000034  十进制版本代号：52.0 即jdk1.8.0\n\n\n## 四、常量池\n\n### 1、简述\n\n版本信息之后就是常量池，常量池中存放两种类型的常量：</br>\n\n<span style=\"color:#42B983; font-weight:bold;\">字面值常量 : </span></br>\n\n<span style=\"color:#FC5531; font-weight:bold;\">字面值常量就是我们在程序中定义的字符串、被 final 修饰的值。</span></br>\n\n<span style=\"color:#42B983; font-weight:bold;\">符号引用 : </span></br>\n\n<span style=\"color:#FC5531; font-weight:bold;\">符号引用就是我们定义的各种名字：类和接口的全限定名、字段的名字和描述符、方法的名字和描述符。</span></br>\n\n### 2、常量池特点\n\n- 常量池中常量数量不固定，因此常量池开头放置一个 u2 类型的无符号数，用来存储当前常量池的容量。\n\n- ![1617009213111](assets\\1617009213111.png)\n\n  > 一个U2无符号数：0X00 12  代表十进制常量个数:1*16 +2 -1 =17个\n  >\n  > <span style=\"color:#FC5531; font-weight:bold;\">注：</span>这里说有17个常量，不是指往后数17个字节都是常量，<span style=\"color:#FC5531; font-weight:bold;\">切记常量的个数是从1计数的</span>\n\n- 常量池的每一项常量都是一个表，表开始的第一位是一个 u1 类型的标志位（tag），代表当前这个常量属于哪种常量类型。\n\n![1617009295970](assets\\1617009295970.png)\n\n> 一个U1无符号数：0X0A  表示第一个常量的tag \n>\n> 即：tag=10 表示：CONSTANT_Methodref_info类中方法的符号引用\n\n![1617006769949](assets\\1617006769949.png)\n\n> 上表详见：常量类型结构\n>\n> 故：该常量由：U1_tag，U2_index，U2_index组成 ：0x 0A 00 03 00 0F\n>\n> ![1617009332453](assets\\1617009332453.png)\n\n### 3、常量池类型\n\n| 类型                             | tag  | 描述                   |\n| -------------------------------- | ---- | ---------------------- |\n| CONSTANT_utf8_info               | 1    | UTF-8 编码的字符串     |\n| CONSTANT_Integer_info            | 3    | 整型字面量             |\n| CONSTANT_Float_info              | 4    | 浮点型字面量           |\n| CONSTANT_Long_info               | 5    | 长整型字面量           |\n| CONSTANT_Double_info             | 6    | 双精度浮点型字面量     |\n| CONSTANT_Class_info              | 7    | 类或接口的符号引用     |\n| CONSTANT_String_info             | 8    | 字符串类型字面量       |\n| CONSTANT_Fieldref_info           | 9    | 字段的符号引用         |\n| CONSTANT_Methodref_info          | 10   | 类中方法的符号引用     |\n| CONSTANT_InterfaceMethodref_info | 11   | 接口中方法的符号引用   |\n| CONSTANT_NameAndType_info        | 12   | 字段或方法的符号引用   |\n| CONSTANT_MethodHandle_info       | 15   | 表示方法句柄           |\n| CONSTANT_MethodType_info         | 16   | 标识方法类型           |\n| CONSTANT_InvokeDynamic_info      | 18   | 表示一个动态方法调用点 |\n\n### 4、常量类型结构表\n\n![](assets\\20180306173808622.png)\n\n![](assets\\20180306173826647.png)\n\n## 五、访问标志\n\n> <span style=\"color:#42B983;font-weight:bold;\">访问标志 ：</span>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否被 abstract/final 修饰\n\n![](assets\\20180306174116287.png)\n\n在本例中：0x00 21 == 0x0001|0x0020表示是一个用户定义的public类\n\n![1617009937871](assets\\1617009937871.png)\n\n## 六、索引\n\n> <span style=\"color:#42B983;font-weight:bold;\">索引：</span> <span style=\"color:#FC5531; font-weight:bold;\">类索引、父类索引</span> 和 <span style=\"color:#FC5531; font-weight:bold;\">接口索引集合</span>\n\n访问标志符紧接着的二进制表示本例中类的继承关系，共三项\n\n###  <span style=\"color:#FC5531; font-weight:bold;\">1、类索引</span>\n\nU2 两个字节，常量池中的对本类的描述\n\n![1617073926069](assets\\1617073926069.png)\n\n> 0x0002 表示常量池中第2个常量为类索引\n\n### <span style=\"color:#FC5531; font-weight:bold;\">2、父类索引</span>\n\nU2 两个字节，常量池中对父类的描述\n\n![1617073968982](assets\\1617073968982.png)\n\n> 0x0003 表示常量池中第3个常量为类索引\n\n### <span style=\"color:#FC5531; font-weight:bold;\">3、接口索引 、</span> <span style=\"color:#FC5531; font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px\">接口索引集合</span>\n\n头两个字节表示接口数，然后，紧跟进接口列表\n\n![1617073986457](assets\\1617073986457.png)\n\n> 0x0000表示实现的接口个数为0个,也就没有接口索引集合了\n\n## 七、字段表集合\n\n接着的二进制表示字段表，头两位为个数，个数后边是字段内容\n\n### <span style=\"color:#42B983;font-weight:bold;\">1、字段描述规则：</span>\n\n![1617074278474](assets\\1617074278474.png)\n\n###  <span style=\"color:#42B983;font-weight:bold;\">2、access_flags的取值表：</span>\n\n![1617074310253](assets\\1617074310253.png)\n\n###  <span style=\"color:#42B983;font-weight:bold;\">3、name_index</span>\n\n\tname_index的含义，同上，映射至常量池中的常量索引\n\n### <span style=\"color:#42B983;font-weight:bold;\">4、descriptor_index</span>\n\n\tdescriptor_index，描述符，表示该变量的类型，此处插一下描述符的表示规则：\n\t\n\t 4.1 描述符中的字符含义如下：\n\n![1617074550746](assets\\1617074550746.png)\n\n\t4.2 表示数组时，每一个维度前用“[”表示\n\t\n\t4.3 描述方法，先参后返回值\n\n### <span style=\"color:#42B983;font-weight:bold;\">5、本例字段</span>\n\n* 字段计数\n\n  ![1617074730851](assets\\1617074730851.png)\n\n  > 0x0001 表示只有一个字段\n\n* 字段内容\n\n  ![1617074804975](assets\\1617074804975.png)\n\n  > 0x0002000400050000表示：0002(private)00040005(查看第四、第五常量)0000(attributes_count)\n\n## 八、方法表集合\n\n接着的二进制表示方法表，头两位为个数\n\n### <span style=\"color:#42B983;font-weight:bold;\">1、方法描述规则：</span>\n\n![1617089287926](assets\\1617089287926.png)\n\n### <span style=\"color:#42B983;font-weight:bold;\">2、access_flags的取值表：</span>\n\n![1617089281407](assets\\1617089281407.png)\n\n### <span style=\"color:#42B983;font-weight:bold;\">3、本例方法</span>\n\n* 方法计数器\n\n![1617089527090](assets\\1617089527090.png)\n\n> 0x0001 表示本例中方法个数为1\n\n![1617090818887](assets\\1617090818887.png)\n\n> 0x0001 表示方法为public   \n\n> 0x0006 表示常量池中第六个常量   : 表示初始化方法（构造器）\n\n![1617090950717](assets\\1617090950717.png)\n\n> 0x0007 表示常量池中第七个常量 ：依据“描述字符含义表” v 为void返回值\n\n![1617090991978](assets\\1617090991978.png)\n\n## 九、属性表集合\n\n\n\n## 十、附录\n\n### 1、java类\n\n~~~java\npackage site.ryanc;\n\npublic class User {\n    private String name;\n}\n~~~\n\n### 2、class文件\n\n~~~java\n//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by FernFlower decompiler)\n//\n\npackage site.ryanc;\n\npublic class User {\n    private String name;\n\n    public User() {\n    }\n}\n~~~\n\n\n\n### 3、class二进制文件\n\n~~~txt\n\t\t\t0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n00000000h: CA FE BA BE 00 00 00 34 00 12 0A 00 03 00 0F 07 ; 漱壕...4........\n00000010h: 00 10 07 00 11 01 00 04 6E 61 6D 65 01 00 12 4C ; ........name...L\n00000020h: 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 ; java/lang/String\n00000030h: 3B 01 00 06 3C 69 6E 69 74 3E 01 00 03 28 29 56 ; ;...<init>...()V\n00000040h: 01 00 04 43 6F 64 65 01 00 0F 4C 69 6E 65 4E 75 ; ...Code...LineNu\n00000050h: 6D 62 65 72 54 61 62 6C 65 01 00 12 4C 6F 63 61 ; mberTable...Loca\n00000060h: 6C 56 61 72 69 61 62 6C 65 54 61 62 6C 65 01 00 ; lVariableTable..\n00000070h: 04 74 68 69 73 01 00 11 4C 73 69 74 65 2F 72 79 ; .this...Lsite/ry\n00000080h: 61 6E 63 2F 55 73 65 72 3B 01 00 0A 53 6F 75 72 ; anc/User;...Sour\n00000090h: 63 65 46 69 6C 65 01 00 09 55 73 65 72 2E 6A 61 ; ceFile...User.ja\n000000a0h: 76 61 0C 00 06 00 07 01 00 0F 73 69 74 65 2F 72 ; va........site/r\n000000b0h: 79 61 6E 63 2F 55 73 65 72 01 00 10 6A 61 76 61 ; yanc/User...java\n000000c0h: 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74 00 21 00 02 ; /lang/Object.!..\n000000d0h: 00 03 00 00 00 01 00 02 00 04 00 05 00 00 00 01 ; ................\n000000e0h: 00 01 00 06 00 07 00 01 00 08 00 00 00 2F 00 01 ; ............./..\n000000f0h: 00 01 00 00 00 05 2A 3F 00 01 3F 00 00 00 02 00 ; ......*?..?.....\n00000100h: 09 00 00 00 06 00 01 00 00 00 02 00 0A 00 00 00 ; ................\n00000110h: 0C 00 01 00 00 00 05 00 0B 00 0C 00 00 00 01 00 ; ................\n00000120h: 0D 00 00 00 02 00 0E                            ; .......\n~~~\n\n### 4、class二进制解读\n\n___\n\n<span style=\"color:#FC5531; font-weight:bold;\">（魔数）</span>      <span style=\"color:#ed7d31; font-weight:bold;\">CA FE BA BE</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（版本）</span>      <span style=\"color:#ffc000; font-weight:bold;\">00 00 00 34</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（常量容量</span>\t<span style=\"color:#70ad47; font-weight:bold;\">00 12</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（常量01）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">0A 00 03 00 0F</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（常量02）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">07 00 10</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（常量03）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">07 00 11</span></br>\n<span style=\"color:#FC5531; font-weight:bold;\">（常量04）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 04 6E 61 6D 65</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（常量05）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 12 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 3B</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（常量06）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 06 3C 69 6E 69 74 3E</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（常量07）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 03 28 29 56</span></br>\n<span style=\"color:#FC5531; font-weight:bold;\">（常量08）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 04 43 6F 64 65</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（常量09）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 0F 4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（常量10）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 12 4C 6F 63 61 6C 56 61 72 69 61 62 6C 65 54 61 62 6C 65</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（常量11）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 04 74 68 69 73</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（常量12）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 11 4C 73 69 74 65 2F 72 79 61 6E 63 2F 55 73 65 72 3B</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（常量13）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 0A 53 6F 75 72 63 65 46 69 6C 65</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（常量14）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 09 55 73 65 72 2E 6A 61 76 61</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（常量15）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">0C 00 06 00 07</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（常量16）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 0F 73 69 74 65 2F 72 79 61 6E 63 2F 55 73 65 72</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（常量17）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（访问标志） </span><span style=\"color:#7030a0; font-weight:bold;\">00 21</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（类索引）</span>     <span style=\"color:#c00000; font-weight:bold;\">00 02</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（父类索引） </span><span style=\"color:#c00000; font-weight:bold;\">00 03</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（接口个数） </span><span style=\"color:#c00000; font-weight:bold;\">00 00</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（接口索引）</span><span style=\"color:#c00000; font-weight:bold;\"> NULL</span></br>\n<span style=\"color:#FC5531; font-weight:bold;\">（字段计数）</span> <span style=\"color:#000000; font-weight:bold;\">00 01</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（字段一）</span>     <span style=\"color:#000000; font-weight:bold;\">00 02 00 04 00 05 00 00</span> </br>\n<span style=\"color:#FC5531; font-weight:bold;\">（方法计数） </span><span style=\"color:#000000; font-weight:bold;\">00 01</span> </br>\n\n00 01 00 06 00 07 00 01 00 08 00 00 00 2F 00 01 </br>\n\n00 01 00 00 00 05 2A 3F 00 01 3F 00 00 00 02 00 </br>\n\n09 00 00 00 06 00 01 00 00 00 02 00 0A 00 00 00 </br>\n\n0C 00 01 00 00 00 05 00 0B 00 0C 00 00 00 01 00 </br>\n\n0D 00 00 00 02 00 0E</br>\n\n___\n\n### 面试经\n\n暂无\n\n\n\n### 参考\n\n[Java中的类文件结构之一：如何分析一个.class文件的二进制码内容_kcstrong的博客-CSDN博客](https://blog.csdn.net/kcstrong/article/details/79460262)\n\n[Java类文件结构详解_A_zhenzhen的专栏-CSDN博客_java类文件结构](https://blog.csdn.net/A_zhenzhen/article/details/77977345)\n\nhttps://github.com/doocs/jvm/blob/main/docs/07-class-structure.md\n\n","timestamp":1618132041402},{"name":"02-jvm内存结构.md","path":"02-java篇/02-技术栈/02-jvm/02-jvm内存结构.md","content":"# jvm 内存结构\n\n>本文所有内容基于: \t<span style=\"color:#42B983;font-weight:bold;\">HotSpot    jdk1.8</span>\t\n>\n>时间：<span style=\"color:#42B983;font-weight:bold;\">2021年4月7日14:15:21</span>\n\n## 一、简述\n\njava 虚拟机的内存空间可以分为（基于jvm设计规范的概念）：</br>\n\n<span style=\"color:#42B983;font-weight:bold;\">五部分：</span><span style=\"color:#FC5531; font-weight:bold;\">程序计数器、java虚拟机栈、本地方法栈，堆 和 方法区</span> **直接内存**</br>\n\n\n\n![jvm-memory-structure.jpg](https://github.com/doocs/jvm/blob/main/docs/images/jvm-memory-structure.jpg?raw=true)\n\n---\n\n\n\n![image-20210411165306022](amWiki_datas/amWiki/images/lib_img/image-20210411165306022.png)\n\n---\n\n![image-20210411165421771](amWiki_datas/amWiki/images/lib_img/image-20210411165421771.png)\n\n<span style=\"color:#FC5531; font-weight:bold;\">扩展：</span>\n\n<span style=\"border-bottom: 2px solid #0081EF;\">JDK 1.8 同 JDK 1.7 比，最大的差别就是：</span><span style=\"border-bottom: 2px solid #0081EF;color:#FC5531;\">元数据区取代了永久代。</span></br>\n\n<span style=\"border-bottom: 2px solid #0081EF;\">元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。</span></br>\n\n<span style=\"border-bottom: 2px solid #0081EF;\">不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。</span></br>\n\n\n\n## 二、程序计数器\n\n### 1、定义\n\n<span style=\"color:#42B983;font-weight:bold;\">\t程序计数器</span>  是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。</br>\n\n若当前线程正在执行的是一个本地方法，那么此时程序计数器为`Undefined`。</br>\n\n每个线程都具有各自独立的程序计数器，所以该区域是  <span style=\"color:#FC5531; font-weight:bold;\">★非线程共享的内存区域★</span></br>\n\n### 2、作用\n\n- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。\n- 在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。\n\n### 3、特点\n\n- 是一块较小的内存空间。\n- 线程私有，每条线程都有自己的程序计数器。\n- 生命周期：随着线程的创建而创建，随着线程的结束而销毁。\n- 是唯一一个  <span style=\"color:#FC5531; font-weight:bold;\">不会出现`OutOfMemoryError`的内存区域。</span>\n\n## 三 、java虚拟机栈\n\n### 1、定义\n\n<span style=\"color:#42B983;font-weight:bold;\">Java 虚拟机栈</span>  是描述 Java 方法运行过程的内存模型。\n\nJava 虚拟机栈会为每一个即将运行的 Java 方法创建一块叫做“栈帧”的区域，用于存放该方法运行过程中的一些信息，如：\n\n- 局部变量表\n- 操作数栈\n- 动态链接\n- 方法出口信息\n- ......\n\n![image-20210411165529231](amWiki_datas/amWiki/images/lib_img/image-20210411165529231.png)\n\n<span style=\"color:#FC5531; font-weight:bold;\">扩展：</span> \n\n* 栈帧：局部变量表、操作栈、动态链接、方法返回地址\n\n  * <span style=\"color:#42B983;font-weight:bold;\">局部变量表</span>\n\n    存放方法参数和局部变量\n    相对于类属性变量的准备阶段和初始化阶段来说，局部变量没有准备阶段，必须显式初始化\n    如果是非静态方法，则在index[0]位置上存储的是方法所属对象的实例引用，随后存储的是参数和局部变量\n    字节码指令中的STORE指令就是将操作栈中计算完成的局部变量写回局部变量表的存储空间内\n\n  * <span style=\"color:#42B983;font-weight:bold;\">操作栈</span>\n\n    操作栈是一个初始状态为空的桶式结构栈 在方法执行过程中，会有各种指令往栈中写入和提取信息 JVM的执行引擎是基于栈的执行引擎，其中的栈指的就是操作栈 字节码指令集的定义都是基于栈类型的,栈的深度在方法元信息的stack属性中\n\n  * <span style=\"color:#42B983;font-weight:bold;\">动态链接</span>\n\n    每个栈帧中包含一个在常量池中对当前方法的引用，目的是支持方法调用过程的动态连接\n\n  * <span style=\"color:#42B983;font-weight:bold;\">方法返回地址</span>\n\n    方法执行时有两种退出情况 正常退出 正常执行到任何方法的返回字节码指令，如RETURN、IRETURN、ARETURN等 异常退出 无论何种退出情况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧\n\n\n\n### 2、压栈出栈过程\n\n当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。\n\nJava 虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。\n\n方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。\n\n> 由于 Java 虚拟机栈是与线程对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题。\n\n\n\n### 3、特点\n\n- 局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。</br>\n- Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</br>\n  - <span style=\"border-bottom: 2px solid #0081EF;color:#FC5531;\">StackOverFlowError</span> <span style=\"border-bottom: 2px solid #0081EF;\">若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。</br></span>\n  - <span style=\"border-bottom: 2px solid #0081EF;color:#FC5531;\">OutOfMemoryError</span> <span style=\"border-bottom: 2px solid #0081EF;\">若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OutOfMemoryError 异常。</span></br>\n- Java 虚拟机栈也是线程私有，随着线程创建而创建，随着线程的结束而销毁。</br>\n\n> 出现 StackOverFlowError 时，内存空间可能还有很多。\n\n\n\n\n## 四、本地方法栈\n\n### 1、定义\n\n<span style=\"color:#42B983;font-weight:bold;\">本地方法栈</span>  是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。\n\n\n\n### 2、栈帧变化过程\n\n本地方法被执行时，在本地方法栈也会创建一块栈帧，\n用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。\n\n方法执行结束后，相应的栈帧也会出栈，并释放内存空间。\n也会抛出 StackOverFlowError 和OutOfMemoryError 异常。\n\n> 如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。\n\n## 五、堆\n\n### 1、定义\n\n<span style=\"color:#42B983;font-weight:bold;\">堆 </span> 是用来存放对象的内存空间，<span style=\"color:#FC5531; font-weight:bold;\"> 几乎 </span>所有的对象都存储在堆中。\n\n### 2、特点\n\n对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。\n\n堆内存是所有线程共有的，可以分为两个部分：<span style=\"color:#FC5531; font-weight:bold;\"> 年轻代</span> 和 <span style=\"color:#FC5531; font-weight:bold;\"> 老年代</span>。\n\n<span style=\"border-bottom: 2px solid #0081EF;\">Perm代表的是永久代，但是注意永久代并不属于堆内存中的一部分</span>，<span style=\"border-bottom: 2px solid #0081EF;color:#FC5531;\">同时jdk1.8之后永久代已经被移除。</span>\n\n![image-20210411165604127](amWiki_datas/amWiki/images/lib_img/image-20210411165604127.png)\n\n- 线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。\n- 在虚拟机启动时创建。\n- 是垃圾回收的主要场所。\n- 进一步可分为：新生代（Eden 区：`From Survior`，`To Survivor`）、老年代。\n\n不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。\n\n堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出 OutOfMemoryError 异常。\n\n> Java 堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。\n\n## 六、方法区\n\n### 1、定义\n\n<span style=\"color:#42B983;font-weight:bold;\">方法区 ：</span>Java 虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息：\n\n- 已经被虚拟机加载的类信息\n- 常量\n- 静态变量\n- 即时编译器编译后的代码\n\n### 2、特点\n\n- 线程共享。 方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。\n- 永久代。 方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区称为“永久代”。\n- 内存回收效率低。 方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：对常量池的回收；对类型的卸载。\n- Java 虚拟机规范对方法区的要求比较宽松。 和堆一样，允许固定大小，也允许动态扩展，还允许不实现垃圾回收。\n\n### 3、运行时常量池\n\n方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码。常量就存放在运行时常量池中。\n\n当类被 Java 虚拟机加载后， .class 文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如 String 类的 `intern()` 方法就能在运行期间向常量池中添加字符串常量。\n\n\n\n## 七、直接内存\n\n### 1、定义\n\n<span style=\"color:#42B983;font-weight:bold;\">直接内存 </span> 并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。\n\njdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。\n\n### 2、操作直接内存\n\n在 NIO 中引入了一种基于通道和缓冲的 IO 方式。它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的`DirectByteBuffer`对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。\n\n<span style=\"border-bottom: 2px solid #0081EF;color:#FC5531;\">直接内存的大小不受 Java 虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError 异常。</span>\n\n### 3、直接内存与堆内存比较\n\n- 直接内存申请空间耗费更高的性能\n- 直接内存读取 IO 的性能要优于普通的堆内存。\n- 直接内存作用链： 本地 IO -> 直接内存 -> 本地 IO\n- 堆内存作用链：本地 IO -> 直接内存 -> 非直接内存 -> 直接内存 -> 本地 IO\n\n> 服务器管理员在配置虚拟机参数时，会根据实际内存设置`-Xmx`等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现`OutOfMemoryError`异常。\n\n\n\n## 附录\n\n### 面试经\n\n1、JVM管理的内存结构是怎样的？\n2、不同的虚拟机在实现运行时内存的时候有什么区别？\n3、运行时数据区中哪些区域是线程共享的？哪些是独享的？\n4、除了JVM运行时内存以外，还有什么区域可以用吗？\n5、堆和栈的区别是什么？\n6、Java中的数组是存储在堆上还是栈上的？\n7、Java中的对象创建有多少种方式？\n8、Java中对象创建的过程是怎么样的？\n9、Java中的对象一定在堆上分配内存吗？\n10、如何获取堆和栈的dump文件？\n\n解惑：[JVM内存结构的面试题_Virgil_K2017的博客-CSDN博客](https://blog.csdn.net/virgil_k2017/article/details/98851768)\n\n### 参考\n\n[jvm/01-jvm-memory-structure.md at main · doocs/jvm (github.com)](https://github.com/doocs/jvm/blob/main/docs/01-jvm-memory-structure.md)\n\n[JAVA高级面试题——2019_longzhutengyue的博客-CSDN博客_java 高级面试题](https://blog.csdn.net/longzhutengyue/article/details/95534447)\n\n\n\n\n\n","timestamp":1618132041402},{"name":"03-类加载的时机、过程和加载器.md","path":"02-java篇/02-技术栈/02-jvm/03-类加载的时机、过程和加载器.md","content":"# 类加载的时机、过程和加载器\n\n> 本文所有内容基于: \t<span style=\"color:#42B983;font-weight:bold;\">HotSpot    jdk1.8</span>\t\n>\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2021年4月6日14:42:44</span>\n\n## 一、类加载过程\n\n> 类加载主要分为：<span style=\"color:#FC5531; font-weight:bold;\">加载、链接(验证、准备，解析)，初始化 </span>三步\n\n![image-20210411165630344](amWiki/images/lib_img/image-20210411165630344.png)\n\n### 1、加载\n\n“加载”是“类加载”过程的一个阶段，不能混淆这两个名词。在加载阶段，虚拟机需要完成 3 件事：</br>\n\n- <span style=\"border-bottom: 2px solid #0081EF;\">通过类的全限定名获取该类的二进制字节流。</span>\n- <span style=\"border-bottom: 2px solid #0081EF;\">将二进制字节流所代表的静态结构转化为方法区的运行时数据结构。</span>\n- <span style=\"border-bottom: 2px solid #0081EF;\">在内存中创建一个代表该类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</span>\n\n<span style=\"color:#FC5531; font-weight:bold;\">扩展:</span>\n\n * 获取二进制字节流\n   <span style=\"border-bottom: 2px solid #0081EF;\">对于 Class 文件，虚拟机没有指明要从哪里获取、怎样获取。</span></br>\n   <span style=\"border-bottom: 2px solid #0081EF;\">除了直接从编译好的 .class 文件中读取，还有以下几种方式</span>：</br>\n   * 从 zip 包中读取，如 jar、war 等\n   * 从网络中获取，如 Applet\n   * 通过动态代理技术生成代理类的二进制字节流\n   * 由 JSP 文件生成对应的 Class 类\n   * 从数据库中读取，如 有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分发。\n* “数组类” & “非数组类“ 比较\n  * <span style=\"border-bottom: 2px solid #0081EF;\">非数组类加载阶段可以使用系统提供的引导类加载器，也可以由用户自定义的类加载器完成，开发人员可以通过定义自己的类加载器控制字节流的获取方式（如重写一个类加载器的 `loadClass()` 方法）</span>\n  * <span style=\"border-bottom: 2px solid #0081EF;color:#FC5531;\">数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的，再由类加载器创建数组中的元素类。</span>\n\n\n\n### 2、链接\n\n#### a、验证\n\n<span style=\"color:#42B983;font-weight:bold;\">简述:</span>验证阶段确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求,并且不会危害虚拟机自身的安全。</br>\n\n- <span style=\"color:#FC5531; font-weight:bold;\">文件格式验证</span> 验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理，验证点如下：\n  - 是否以魔数 0XCAFEBABE 开头\n  - 主次版本号是否在当前虚拟机处理范围内\n  - 常量池是否有不被支持的常量类型\n  - 指向常量的索引值是否指向了不存在的常量\n  - CONSTANT_Utf8_info 型的常量是否有不符合 UTF8 编码的数据\n  - ......（详：类文件结构）\n- <span style=\"color:#FC5531; font-weight:bold;\">元数据验证</span> 对字节码描述信息进行语义分析，确保其符合 Java 语法规范。\n  - 是否有父类；\n  - 是否继承了不被允许继承的类；\n  - 如果该类不是抽象类，是否实现了其父类或接口要求实现的所有方法；\n  - ......\n- <span style=\"color:#FC5531; font-weight:bold;\">字节码验证</span> 本阶段是验证过程中最复杂的一个阶段，是对方法体进行语义分析，保证方法在运行时不会出现危害虚拟机的事件。\n  - 保证任何时候操作数栈的数据类型与指令代码序列的一致性；\n  - 跳转指令不会跳转到方法体以外的字节码指令上；\n  - ......\n- <span style=\"color:#FC5531; font-weight:bold;\">符号引用验证</span> 本阶段发生在解析阶段，确保解析正常执行。\n  - 符号引用的类、字段、方法的访问性（public、private等）是否可被当前类访问；\n  - 指定类是否存在符合方法的字段描述符；\n  - ......\n\n\n\n#### b、准备\n\n<span style=\"color:#42B983;font-weight:bold;\">简述: </span> 负责为类变量（或称“静态成员变量”）分配内存，并设置默认初始值。</br>\n\t   <span style=\"color:#FC5531; font-weight:bold;\">这些变量（★不包括实例变量★）所使用的内存都在方法区中进行分配</span></br>\n\n初始值“通常情况下”是数据类型的零值（0, null...），假设一个类变量的定义为：</br>\n\n```java\npublic static int value = 123;\n```\n\n那么变量 value 在准备阶段过后的初始值为 0 而不是 123，因为这时候尚未开始执行任何 Java 方法。</br>\n\n存在“特殊情况”：如果类字段的字段属性表中存在 ConstantValue 属性，</br>\n\n那么在准备阶段 value 就会被初始化为 ConstantValue 属性所指定的值，假设上面类变量 value 的定义变为：</br>\n\n```java\npublic static final int value = 123;\n```\n\n那么在准备阶段虚拟机会根据 ConstantValue 的设置将 value 赋值为 123。\n\n\n\n#### c、解析\n\n<span style=\"color:#42B983;font-weight:bold;\">简述:</span> 解析阶段是虚拟机将常量池内的符号引用替换成直接引用的过程。</br>\n\t  直接引用是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。</br>\n\t  直接引用和虚拟机实现的内存有关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用不尽相同。</br>\n\n\n\n### 3、初始化\n\n<span style=\"color:#42B983;font-weight:bold;\">简述:</span> 初始化阶段是类加载过程的最后一步，到了该阶段才真正开始执行类定义的Java程序代码，根据程序员通过代码定制的主观计划去初始化类变量和其他资源，是执行类构造器初始化方法的过程。</br>\n\n类初始化阶段是类加载过程的最后一步，是执行类构造器 `<clinit>()` 方法的过程。\n\n`<clinit>()` 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static {} 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。\n\n静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但不能访问。如下方代码所示：\n\n```java\npublic class Test {\n    static {\n        i = 0;  // 给变量赋值可以正常编译通过\n        System.out.println(i);  // 这句编译器会提示“非法向前引用”\n    }\n    static int i = 1;\n}\n```\n\n`<clinit>()` 方法不需要显式调用父类构造器，虚拟机会保证在子类的 `<clinit>()` 方法执行之前，父类的 `<clinit>()` 方法已经执行完毕。\n\n由于父类的 `<clinit>()` 方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作。如下方代码所示：\n\n```java\nstatic class Parent {\n    public static int A = 1;\n    static {\n        A = 2;\n    }\n}\n\nstatic class Sub extends Parent {\n    public static int B = A;\n}\n\npublic static void main(String[] args) {\n    System.out.println(Sub.B); // 输出 2\n}\n```\n\n`<clinit>()` 方法不是必需的，如果一个类没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成 `<clinit>()` 方法。\n\n接口中不能使用静态代码块，但接口也需要通过 `<clinit>()` 方法为接口中定义的静态成员变量显式初始化。但接口与类不同，接口的 `<clinit>()` 方法不需要先执行父类的 `<clinit>()` 方法，只有当父接口中定义的变量使用时，父接口才会初始化。\n\n虚拟机会保证一个类的 `<clinit>()` 方法在多线程环境中被正确加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 `<clinit>()` 方法。\n\n\n\n\n\n## 二、类加载时机\n\n### 1、类加载的生命周期\n\n<span style=\"color:#42B983;font-weight:bold;\">类加载的生命周期</span> 是从类被加载到内存开始，直到卸载出内存为止的。\n整个生命周期分为7个阶段：<span style=\"color:#FC5531; font-weight:bold;\">加载、验证、准备、解析、初始化、使用、卸载。</span>\n其中，<span style=\"border-bottom: 2px solid #0081EF;\">验证、准备、解析</span> 三部分统称为连接。\n\n![image-20210411165653573](/amWiki_datas/amWiki/images/lib_img/image-20210411165653573.png)\n\n<span style=\"color:#FC5531; font-weight:bold;\">注：</span>\n\n<span style=\"border-bottom: 2px solid #0081EF;\">加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的</span></br>\n\n<span style=\"border-bottom: 2px solid #0081EF;\">类的加载过程必须按照这种顺序按部就班地开始（注意是“开始”，而不是“进行”或“完成”）</span></br>\n\n<span style=\"border-bottom: 2px solid #0081EF;\">而解析阶段则不一定:它在某些情况下可以在初始化后再开始,这是为了支持 Java 语言的运行时绑定。</span></br>\n\n\n\n### 2、“初始化”的时机\n\n<span style=\"color:#42B983;font-weight:bold;\">简述:</span>   Java 虚拟机规范没有强制约束类加载过程的第一阶段（即：加载）什么时候开始，但对于“初始化”阶段，有着严格的规定。有且仅有 5 种情况必须立即对类进行“初始化”：\n\n- 在遇到 new、putstatic、getstatic、invokestatic 字节码指令时，如果类尚未初始化，则需要先触发其初始化。\n- 对类进行反射调用时，如果类还没有初始化，则需要先触发其初始化。\n- 初始化一个类时，如果其父类还没有初始化，则需要先初始化父类。\n- 虚拟机启动时，用于需要指定一个包含 `main()` 方法的主类，虚拟机会先初始化这个主类。\n- 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类还没初始化，则需要先触发其初始化。\n\n这 5 种场景中的行为称为对一个类进行**主动引用**，除此之外，其它所有引用类的方式都不会触发初始化，称为**被动引用**。\n\n\n\n#### a、被动引用Demo1\n\n```java\n/**\n * 被动引用 Demo1:\n * 通过子类引用父类的静态字段，不会导致子类初始化。\n *\n * @author Ryan丶璟芮\n *\n */\nclass SuperClass {\n    static {\n        System.out.println(\"SuperClass init!\");\n    }\n\n    public static int value = 123;\n}\n\nclass SubClass extends SuperClass {\n    static {\n        System.out.println(\"SubClass init!\");\n    }\n}\n\npublic class NotInitialization {\n\n    public static void main(String[] args) {\n        System.out.println(SubClass.value);\n        // SuperClass init!\n    }\n\n}\n```\n\n<span style=\"color:#FC5531; font-weight:bold;\">注：</span>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。\n\n#### b、被动引用Demo2\n\n```java\n/**\n * 被动引用 Demo2:\n * 通过数组定义来引用类，不会触发此类的初始化。\n *\n * @author Ryan丶璟芮\n *\n */\n\npublic class NotInitialization {\n\n    public static void main(String[] args) {\n        SuperClass[] superClasses = new SuperClass[10];\n    }\n\n}\n```\n\n<span style=\"color:#FC5531; font-weight:bold;\">注：</span>这段代码不会触发父类的初始化，但会触发“[L 全类名”这个类的初始化，它由虚拟机自动生成，直接继承自 java.lang.Object，创建动作由字节码指令 newarray 触发。\n\n#### c、被动引用Demo3\n\n```java\n/**\n * 被动引用 Demo3:\n * 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。\n *\n * @author Ryan丶璟芮\n *\n */\nclass ConstClass {\n    static {\n        System.out.println(\"ConstClass init!\");\n    }\n\n    public static final String HELLO_RYAN = \"Hello Ryan\";\n\n}\n\npublic class NotInitialization {\n\n    public static void main(String[] args) {\n        System.out.println(ConstClass.HELLO_RYAN);\n    }\n\n}\n```\n\n<span style=\"color:#FC5531; font-weight:bold;\">注：</span>编译通过之后，常量存储到 NotInitialization 类的常量池中，NotInitialization 的 Class 文件中并没有 ConstClass 类的符号引用入口，这两个类在编译成 Class 之后就没有任何联系了。\n\n\n\n### 3、接口加载过程\n\n接口加载过程与类加载过程稍有不同。\n\n<span style=\"border-bottom: 2px solid #0081EF;color:#FC5531;\">当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，当真正用到父接口的时候才会初始化。</span>\n\n## 三、类加载器\n\n<span style=\"color:#42B983;font-weight:bold;\">类加载器</span> 主要分为三类：<span style=\"color:#FC5531; font-weight:bold;\">启动类加载器、扩展类加载器</span> 和 <span style=\"color:#FC5531; font-weight:bold;\">应用程序加载器</span>\n\n![classloader.png](https://github.com/doocs/jvm/blob/main/docs/images/classloader.png?raw=true)\n\n---\n\n![image-20210411165727903](amWiki/images/lib_img/image-20210411165727903.png)\n\n\n\n### 1、启动类加载器\n\n<span style=\"color:#42B983;font-weight:bold;\">启动类加载器（Bootstrap ClassLoader）：</span>\n\n<span style=\"border-bottom: 2px solid #0081EF;\">负责将存放在 <JAVA_HOME>\\lib 目录中的，并且能被虚拟机识别的（仅按照文件名识别，如 rt.jar</span></br>\n\n<span style=\"border-bottom: 2px solid #0081EF;\">名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。</span></br>\n\n### 2、扩展类加载器\n\n<span style=\"color:#42B983;font-weight:bold;\">扩展类加载器（Extension ClassLoader）：</span>\n\n <span style=\"border-bottom: 2px solid #0081EF;\">负责加载 `<JAVA_HOME>\\lib\\ext` 目录中的所有类库，开发者可以直接使用扩展类加载器。</span></br>\n\n### 3、应用程序类加载器\n\n<span style=\"color:#42B983;font-weight:bold;\">应用程序类加载器（Application ClassLoader）： </span>\n\n<span style=\"border-bottom: 2px solid #0081EF;\">由于这个类加载器是 ClassLoader 中的 `getSystemClassLoader()` 方法的返回值</span></br>\n\n<span style=\"border-bottom: 2px solid #0081EF;\">所以一般也称它为“系统类加载器”。它负责加载用户类路径（classpath）上所指定的类库</span></br>\n\n<span style=\"border-bottom: 2px solid #0081EF;\">开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器</span></br>\n\n<span style=\"border-bottom: 2px solid #0081EF;\">一般情况下这个就是程序中默认的类加载器。</span></br>\n\n\n\n### 4、双亲委派\n\n#### a 、简述\n\n<span style=\"color:#42B983;font-weight:bold;\">双亲委派模型</span> 是描述类加载器之间的层次关系。它要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。（父子关系一般不会以继承的关系实现，而是以组合关系来复用父加载器的代码）\n\n\n\n#### b、工作过程\n\n~~~java\n//类加载过程\n\n public Class<?> loadClass(String name) throws ClassNotFoundException {\n        return loadClass(name, false);\n    }\n\n protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException\n\n    {\n\t\t    // 首先判断该类型是否已经被加载\n\t\t    Class c = findLoadedClass(name);\n\t\t    if (c == null) {\n\t\t    //没有被加载，就委托给父类加载器或者委派给启动类加载器加载\n\n    try {\n\t\t    if (parent != null) {\n\t\t    // 如果存在父类加载器，就委派给父类加载器加载\n\t\t    c = parent.loadClass(name, false);\n\t\t    } else {\n\t\t        // 如果不存在父类加载器，就检查是否是由启动类加载器加载的类\n\t\t        c = findBootstrapClassOrNull(name);\n\t\t    }\n        } catch (ClassNotFoundException e) {\n        }\n\n      if (c == null) {\n        // 如果父类加载器和启动类加载器都不能完成加载任务，调用自身的加载工程\n        c = findClass(name);\n    }\n\n}\n\n    if (resolve) {\n        resolveClass(c);\n    }\n\nreturn c;\n\n }\n\n~~~\n\n如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（找不到所需的类）时，子加载器才会尝试自己去加载。\n\n在 java.lang.ClassLoader 中的 `loadClass` 方法中实现该过程。\n\n\n\n#### c、存在背景\n\n<span style=\"color:#FC5531; font-weight:bold;\">为什么使用双亲委派模型？</span>\n\n像 java.lang.Object 这些存放在 rt.jar 中的类，无论使用哪个类加载器加载，最终都会委派给最顶端的启动类加载器加载，从而使得不同加载器加载的 Object 类都是同一个。\n\n相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在 classpath 下，那么系统将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证。\n\n\n\n## 附录\n\n### 面试经\n\n1、所有new出来的对象都在堆上嘛？\n\n2、什么是逃逸分析\n\n3、双亲委派机制原理、可以打破该机制嘛？how？\n\n### 参考\n\n[常见JVM面试题及答案整理_Java笔记-CSDN博客_jvm面试题](https://blog.csdn.net/qq_41701956/article/details/100074023)\n","timestamp":1618132041402},{"name":"05-HotSpot_JOL.md","path":"02-java篇/02-技术栈/02-jvm/05-HotSpot_JOL.md","content":"\n\n\n\n# Java Object LayOut\n\n> 本文所有内容基于: \t<span style=\"color:#42B983;font-weight:bold;\">HotSpot    jdk1.8</span>\t\n>\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2021年3月26日12:31:52</span>\n\n## 一、简述\n\n在 <span style=\"color:#42B983;font-weight:bold;\">HotSpot</span>虚拟机中\n对象在内存中的存储分为三块区域：<span style=\"color:#FC5531; font-weight:bold;\">对象头（Header）</span>、<span style=\"color:#FC5531; font-weight:bold;\">实例数据（Instance Data）</span>、<span style=\"color:#FC5531; font-weight:bold;\">对齐填充（Padding）</span>\n\n![1617109250439](assets/\\1617109250439.png)\n\n---\n\n* 对象头\n\n  对象头(12个字节)主要分为两部分：\n\n  <span style=\"color:#FC5531; font-weight:bold;\">markWord ：</span> 占4个字节，主要描述：哈希码、gc分代年龄、锁状态标志、线程持有的锁、偏向线程id等</br>\n\n  ~~~c++\n  class markOopDesc: public oopDesc {\n   private:\n    // Conversion\n    uintptr_t value() const { return (uintptr_t) this; }\n   public:\n    // Constants\n    enum { age_bits                 = 4,  //分代年龄\n           lock_bits                = 2, //锁标识\n           biased_lock_bits         = 1, //是否为偏向锁\n           max_hash_bits            = BitsPerWord - age_bits - lock_bits - biased_lock_bits,\n           hash_bits                = max_hash_bits > 31 ? 31 : max_hash_bits, //对象的hashcode\n           cms_bits                 = LP64_ONLY(1) NOT_LP64(0),\n           epoch_bits               = 2 //偏向锁的时间戳\n    };\n  ~~~\n\n\n\n  <span style=\"color:#FC5531; font-weight:bold;\">Class对象指针：</span> 占8个字节，主要描述：</br>\n\n  * 普通对象：对象类型指针  <span style=\"color:#FC5531; font-weight:bold;\">注</span>：<span style=\"color:#42B983;font-weight:bold;\">对象定位方式</span>  和  <span style=\"color:#42B983;font-weight:bold;\">指针压缩</span>  问题 </br>\n  * 数组：数组元素类型指针 & 数组长度</br>\n\n---\n\n* 实例数据\n\n  实例数据部分就是成员变量的值：<span style=\"color:#42B983;font-weight:bold;\">基本变量</span> & <span style=\"color:#42B983;font-weight:bold;\">引用变量</span>。\n\n  * 基本变量：八种基本类型成员变量\n  * 引用变量：存放类的引用变量句柄，如String,Object每个句柄大小在32位虚拟机上是4byte，64位虚拟机上是8byte，但java8开始默认开启UseCompressedOops压缩参数，故也是4byte,classpoint也是如此；\n\n  <span style=\"color:#FC5531; font-weight:bold;\">注：</span>其中包括父类成员变量和本类成员变量\n\n---\n\n* 对齐填充\n\n  用于确保对象的总长度为 8 字节的整数倍。\n\n  HotSpot VM 的自动内存管理系统要求对象的大小必须是 8 字节的整数倍。\n\n  而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，\n\n  就需要通过对齐填充来补全。\n\n  > 对齐填充并不是必然存在，也没有特别的含义，它仅仅起着占位符的作用。\n\n---\n\n\n\n## 二 、详释\n\n> 实例数据 和 对齐填充 没有什么好说的，这里我们一起来看一下对象头（markWord & 实例数据）\n>\n> mark word的位长度为JVM的一个Word大小，也就是说32位JVM的Mark word为32位，64位JVM为64位。\n\n### 1、MarkWord\n\n* 32位对象头markword\n\n<table>\n\t<tr>\n\t    <th rowspan=\"2\">锁状态</th>\n\t    <th colspan=\"2\">25bit</th>  \n        <th rowspan=\"2\">4bit</th>\n\t    <th rowspan=\"2\">1bit(是否偏向锁)</th>\n\t    <th rowspan=\"2\">2bit(锁标志位)</th>  \n\t</tr >\n\t<tr >\n\t    <td>23bit</td>\n\t    <td>2bit</td>\n\t</tr>\n    <tr >\n\t    <td>无锁</td>\n\t    <td colspan=\"2\">对象hashCode</td>\n        <td>分代年龄</td>\n\t    <td>0</td>\n\t    <td>01</td>\n\t</tr>\n    <tr >\n\t    <td>偏向锁</td>\n\t    <td>(锁偏向的线程id)</td>\n\t    <td>Epoch</td>\n        <td>对象分代年龄</td>\n\t    <td>1</td>\n\t    <td>01</td>\n\t</tr>\n    <tr >\n\t    <td>轻量级</td>\n\t    <td colspan=\"4\">指向栈中锁记录的指针</td>\n\t    <td>00</td>\n\t</tr>\n    <tr >\n\t    <td>重量级</td>\n\t    <td colspan=\"4\">指向重量级锁的指针</td>\n\t    <td>10</td>\n\t</tr>\n    <tr >\n\t    <td>GC标记</td>\n\t    <td colspan=\"4\">空</td>\n\t    <td>11</td>\n\t</tr>\n</table>\n\n* 64位对象头markword\n\n<table>\n\t<tr>\n\t    <th align=\"center\" rowspan=\"2\" >锁状态</th>\n\t    <th align=\"center\" colspan=\"2\">56bit</th>  \n        <th align=\"center\" rowspan=\"2\">1bit</th>\n\t    <th align=\"center\" rowspan=\"2\">4bit</th>\n\t    <th align=\"center\" rowspan=\"2\">1bit(是否偏向锁)</th>\n        <th align=\"center\" rowspan=\"2\">2bit(锁标志位)</th>\n\t</tr >\n\t<tr >\n\t    <td align=\"center\">25bit</td>\n\t    <td align=\"center\">31bit</td>\n\t</tr>\n    <tr >\n\t    <td align=\"center\">无锁</td>\n        <td align=\"center\">unused</td>\n\t    <td align=\"center\">对象hashCode</td>\n        <td align=\"center\">cms_free</td>\n        <td align=\"center\">分代年龄</td>\n\t    <td align=\"center\">0</td>\n\t    <td align=\"center\">01</td>\n\t</tr>\n    <tr >\n\t    <td align=\"center\">偏向锁</td>\n\t    <td align=\"center\">(锁偏向的线程id)</td>\n\t    <td align=\"center\">Epoch</td>\n        <td align=\"center\">cms_free</td>\n        <td align=\"center\">对象分代年龄</td>\n\t    <td align=\"center\">1</td>\n\t    <td align=\"center\">01</td>\n\t</tr>\n    <tr >\n\t    <td align=\"center\">轻量级</td>\n\t    <td align=\"center\" colspan=\"5\">指向栈中锁记录的指针</td>\n\t    <td align=\"center\">00</td>\n\t</tr>\n    <tr >\n\t    <td align=\"center\">重量级</td>\n\t    <td align=\"center\" colspan=\"5\">指向重量级锁的指针</td>\n\t    <td align=\"center\">10</td>\n\t</tr>\n    <tr >\n\t    <td align=\"center\">GC标记</td>\n\t    <td align=\"center\" colspan=\"5\">空</td>\n\t    <td align=\"center\">11</td>\n\t</tr>\n</table>\n\n>  <span style=\"color:#FC5531; font-weight:bold;\">注</span>：这里锁升级（锁膨胀）、锁消除、锁粗化不做讨论，放在synchronize原理中讲解\n\n* 问题讨论\n\n  jvm对内存，对象年龄到15就会被移入老年代，那调优jvm是不是可以调大这个年龄？</br>\n\n  调优参数-XX:MaxTenuringThreshold</br>\n\n### 2、class类指针\n\n> class类指针 即：类型指针，通过该指针能确定对象属于哪个类。如果对象是一个数组，那么对象头还会包括数组长度。\n\n* 指针压缩\n\n  指针：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</br>\n\n   这部分就涉及到一个指针压缩的概念，在开启指针压缩的情况下，占4字节（32bit）</br>\n\n  未开启情况下，占8字节（64bit），现在JVM在1.6之后，在64位操作系统下都是默认开启的。</br>\n\n  * 未开启指针压缩\n\n  ![1617246983290](assets/\\1617246983290.png)\n\n\n\n  ![1617247062129](assets\\1617247062129.png)\n\n  采用8字节（64位）存储真实内存地址，比之前采用4字节（32位）压缩存储地址带来的问题：</br>\n\n  1. <span style=\"color:#FC5531; font-weight:bold;\">增加了GC开销</span>：64位对象引用需要占用更多的堆空间，留给其他数据的空间将会减少，</br>\n\n     从而加快了GC的发生，更频繁的进行GC。</br>\n\n  2. <span style=\"color:#FC5531; font-weight:bold;\">降低CPU缓存命中率</span>：64位对象引用增大了,CPU能缓存的oop将会更少,从而降低了CPU缓存的效率。</br>\n\n\n\n  * 开启指针压缩\n\n  ![1617246963007](assets\\1617246963007.png)\n\n![1617247316252](assets\\1617247316252.png)\n\n4个字节，32位，可以表示232 个地址，如果这个地址是真实内存地址的话，</br>\n那么由于CPU寻址的最小单位是byte，也就是 232 byte = 4GB。</br>\n如果内存地址是指向 bit的话，32位的最大寻址范围其实是 512MB，但是由于内存里，将8bit为一组划分，</br>\n所以内存地址就其实是指向的8bit为一组的byte地址，所以32位可以表示的容量就扩充了8倍，</br>\n就变成了4GB。</br>\n\n将java堆内存进行8字节划分</br>\n\njava对象的指针地址就可以不用存对象的真实的64位地址了，而是可以存一个映射地址编号。</br>\n这样4字节就可以表示出2^32个地址，而每一个地址对应的又是8byte的内存块。</br>\n所以，再乘以8以后，一换算，就可以表示出32GB的内存空间。</br>\n\n### 3、实例数据\n\n> 基本变量这里不再讨论，这里涉及到对象的访问方式：<span style=\"color:#42B983;font-weight:bold;\">句柄访问</span> & <span style=\"color:#42B983;font-weight:bold;\">指针访问</span>\n\n* 句柄访问\n\n  堆中需要有一块叫做“句柄池”的内存空间，句柄中包含了对象实例数据与类型数据各自的具体地址信息。\n\n  引用类型的变量存放的是该对象的句柄地址（reference）。访问对象时，首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址找到对象。\n\n![1617246273983](assets\\1617246273983.png)\n\n* 指针访问\n\n  引用类型的变量直接存放对象的地址，从而不需要句柄池，通过引用能够直接访问对象。但对象所在的内存空间需要额外的策略存储对象所属的类信息的地址。\n\n  ![1617246318399](assets\\1617246318399.png)\n\n<span style=\"color:#FC5531; font-weight:bold;\">注</span>：HotSpot 采用第二种方式，即直接指针方式来访问对象，只需要一次寻址操作，所以在性能上比句柄访问方式快一倍。但像上面所说，它需要**额外的策略**来存储对象在方法区中类信息的地址。\n\n## 三、实例说明\n\n### 1、引入JOL辅助依赖\n\n~~~xml\n<dependency>\n    <groupId>org.openjdk.jol</groupId>\n    <artifactId>jol-core</artifactId>\n    <version>0.9</version>\n</dependency>\n~~~\n\n\n\n### 2、obj说明类\n\n* learner类\n\n~~~java\npublic class JolLearn {\n    public static void main(String[] args) {\n        /**\n         *  User对象的布局\n         *\n         *\n         *\n         *         --   +-------------+--------------------------------+\n         *        |     |   markword  |   8字节 (synchronized 信息在这里 |\n         * 对象头 {      +-------------+--------------------------------+\n         *        \\     |class pointer|   开启ccp4字节，不开启8字节       |\n         *         --   +-------------+--------------------------------+\n         *              |instant data |   具体分析：int 4字节。。。       |\n         *              +-------------+--------------------------------+\n         *              |   padding   |   总字节数被8整除，否则补齐       |\n         *              +-------------+--------------------------------+\n         *\n         *  Q:\n         *      1、\n         */\n        User_NoVal user_NoVal = new User_NoVal();\n        User_HaveVal user_HaveVal = new User_HaveVal();\n\n        // 普通对象:无成员变量时的对象布局\n        System.out.println(ClassLayout.parseInstance(user_NoVal).toPrintable());\n\n        // 普通对象:有成员变量时的对象布局\n        System.out.println(ClassLayout.parseInstance(user_HaveVal).toPrintable());\n\n        // 普通对象：无成员变量 有synchronized 信息时的对象布局\n        /*synchronized(user_NoVal){\n            System.out.println(ClassLayout.parseInstance(user_NoVal).toPrintable());\n        }*/\n    }\n}\n~~~\n\n* 有成员变量（hava_val）类\n\n~~~java\nclass User_HaveVal{\n    // 4个字节\n    private int id;\n    // 开启普通指针压缩的情况下 4个字节\n    private String name;\n}\n~~~\n\n* 无成员变量（  no_val  ）类\n\n~~~java\nclass User_NoVal{\n\n}\n~~~\n\n\n\n## 附录\n\n### 面试经\n\n1、对象在内存中的存储布局？Object o = new Object()在内存中占用多少字符？\n\n2、什么是java指针压缩\n\n3、Hotspot开启内存压缩的规则（64位机）\n\n4、当物理内存超过32g时指针压缩为啥会失效\n\n5、对象怎么定位？\n\n### 参考\n\n[jvm压缩指针原理以及32g内存压缩指针失效详解_超负荷运转-CSDN博客_压缩指针](https://blog.csdn.net/lioncatch/article/details/105919666)\n\n[聊一聊JAVA指针压缩的实现原理（图文并茂，让你秒懂）_liujianyangbj的博客-CSDN博客_指针压缩](https://blog.csdn.net/liujianyangbj/article/details/108049482)\n\nhttps://github.com/doocs/jvm/blob/main/docs/02-hotspot-jvm-object.md\n\n[java byte object的子类_Java对象布局(JOL)实现过程解析_王若然的博客-CSDN博客](https://blog.csdn.net/weixin_31458015/article/details/114184239)\n","timestamp":1618132041402},{"name":"01-synchronize底层原理.md","path":"02-java篇/02-技术栈/03-多线程/01-synchronize底层原理.md","content":"\n\n# synchronize底层原理\n\n>synchronize是如何使用的？这里不再赘述，从底层出发了解原理。\n>\n>时间：<span style=\"color:#42B983;font-weight:bold;\">2021年4月1日14:44:08</span>    本文所有内容基于: \t<span style=\"color:#42B983;font-weight:bold;\">HotSpot    jdk1.8</span>\t\n\n## 一、前置知识\n\n### 1、cas和unsafe类\n\n#### a、<span style=\"color:#FC5531; font-weight:bold;\">cas </span> \n**Compare and Swap(set)** 基于乐观锁的一种概念</br>\n描述了，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止的机制</br>\n\n\n\n#### b、<span style=\"color:#FC5531; font-weight:bold;\">unsafe类</span> \n\nunsafe(不安全)类，是对cas机制的一种  <span style=\"color:#42B983;font-weight:bold;\">\"安全实现\"</span>  下边我们详细描述。\n\n##### 不安全\n\n因为unsafe类是<span style=\"color:#FC5531; font-weight:bold;\"> 直接操作内存 </span>的类，所以不安全\n\n##### 安全\n\n因为unsafe类是直接操作内存的类，所以为了不让程序员们直接使用，对unsafe类加了限制</br>\n\n该类只能有Bootstrap类加载器加载（<span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px\">但让使用反射这种非常规的方式还是可以突破限制 ^_-！</span>）\n\n##### 正常尝试使用\n\n~~~java\n/**\n * 正常渠道使用unsafe类\n * ：因为 unsafe类 是在rt包下的，并且unsafe是直接操作内存的类，所以官方为了不让程序员们直接操作内存导致不安全的问题发生，所以对unsafe类使用加了以下限制\n * 首先unsafe类必须有Bootstrap类加载器加载才能使用\n *\n * @author cWX993443\n * @since 2021-02-02\n */\npublic class NormalChannelUnsafe {\n    // 获取unsafe的实例\n    static final Unsafe unsafe = sun.misc.Unsafe.getUnsafe();\n\n    // state 字段内存偏移量\n    static long stateOffSet;\n\n    // cas 要修改的字段state\n    private volatile long state = 0;\n\n    static {\n        try {\n            // 获取字段“state\" 在对象NormalChannelUnsafe中的内存偏移量\n            stateOffSet = unsafe.objectFieldOffset(NormalChannelUnsafe.class.getDeclaredField(\"state\"));\n        } catch (NoSuchFieldException e) {\n            System.out.println(e.getLocalizedMessage());\n        }\n    }\n\n    public static void main(String[] args) {\n        NormalChannelUnsafe normalChannelUnsafe = new NormalChannelUnsafe();\n        // 使用unsafe类的cas方式修改对象normalChannelUnsafe对象在内存偏移量为stateOffSet位置上的值为1\n        Boolean sucess = unsafe.compareAndSwapLong(normalChannelUnsafe, stateOffSet, 0, 1);\n    }\n}\n~~~\n\n##### 反射尝试\n\n~~~java\n/**\n * 非正规渠道使用unsafe类\n *  正常的渠道无法使用unsafe类 但是我们可以利用强大的 反射来打破平衡，突破限制\n *\n * @author cWX993443\n * @since 2021-02-02\n */\npublic class AbnormalChannelUnsafe {\n\n    static  Unsafe unsafe;\n\n    static long stateOffSet;\n\n    private volatile long state = 0;\n\n    static{\n        try {\n            Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\n\n            field.setAccessible(true);\n\n            unsafe = (Unsafe) field.get(null);\n\n            stateOffSet = unsafe.objectFieldOffset(AbnormalChannelUnsafe.class.getDeclaredField(\"state\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n\n    public static void main(String[] args) {\n\n        AbnormalChannelUnsafe abnormalChannelUnsafe = new AbnormalChannelUnsafe();\n\n        Boolean success = unsafe.compareAndSwapLong(abnormalChannelUnsafe,stateOffSet,256,1);\n\n        System.out.println(\"abnormalChannelUnsafe to update state`s value result :\" + success + \" | current value :\" + abnormalChannelUnsafe.state);\n\n    }\n\n}\n~~~\n\n##### unsafe对cas实现解读\n\n> 这里以上例中的 unsafe.compareAndSwapLong();为例探索\n\n* java代码\n\n~~~java\n/**\n     * Atomically update Java variable to <tt>x</tt> if it is currently\n     * holding <tt>expected</tt>.\n     * @return <tt>true</tt> if successful\n     */\n    public final native boolean compareAndSwapLong(Object o, long offset,\n                                                   long expected,long x);\n~~~\n\n* openjdk1.8源码说明\n\n~~~c++\nUNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x))\n  UnsafeWrapper(\"Unsafe_CompareAndSwapLong\");\n  Handle p (THREAD, JNIHandles::resolve(obj));\n  jlong* addr = (jlong*)(index_oop_from_field_offset_long(p(), offset));\n  if (VM_Version::supports_cx8())\n    return (jlong)(Atomic::cmpxchg(x, addr, e)) == e;\n  else {\n    jboolean success = false;\n    ObjectLocker ol(p, THREAD);\n    if (*addr == e) { *addr = x; success = true; }\n    return success;\n  }\nUNSAFE_END\n~~~\n\n接着我们再看上面这段代码中的核心代码点：<span style=\"color:#FC5531; font-weight:bold;\">Atomic::cmpxchg(x, addr, e)</span>\n在atomic_linux_x86.inline.hpp中的实现\n\n~~~c++\ninline jlong    Atomic::cmpxchg    (jlong    exchange_value, volatile jlong*    dest, jlong    compare_value) {\n  bool mp = os::is_MP();\n  __asm__ __volatile__ (LOCK_IF_MP(%4) \"cmpxchgq %1,(%3)\"\n                        : \"=a\" (exchange_value)\n                        : \"r\" (exchange_value), \"a\" (compare_value), \"r\" (dest), \"r\" (mp)\n                        : \"cc\", \"memory\");\n  return exchange_value;\n}\n~~~\n\n<span style=\"color:#FC5531; font-weight:bold;\">简单说明：</span>\n\n<span style=\"color:#42B983;font-weight:bold;\">\\__asm__  \\__volatile__ </span>:声明接下来的4部分表达式（：分割的）不被gcc指令优化</br>\n\n<span style=\"color:#42B983;font-weight:bold;\">os::is_MP()</span>：判断当前环境是否为多处理器环境 </br>\n\n<span style=\"color:#42B983;font-weight:bold;\">重点★★★</span> LOCK_IF_MP(%4) \"cmpxchgq %1,(%3)\" </br>\n\n LOCK_IF_MP：如果为多核处理器，则在“核心指令”前追加“lock”指令</br>\n\n lock:语义：只允许一个cpu修改地址偏移量上的值</br>\n\n硬件层面细究：锁总线：锁定总线一个北桥电信号 这里就不在往深了探讨了 0.o</br>\n\ncmpxchgq：核心指令，语义：比较并交换</br>\n\n<span style=\"color:#FC5531; font-weight:bold;\">总</span>：总结cas机制用unsafe核心实现底层指令：<span style=\"color:#FC5531; font-weight:bold;\">lock  cmpxchgp</span>\n\n### 2、JOL\n\n>  JOL:java object layout,有专门的文章讲解，这里不在赘述\n\n## 二、synchronize使用场景\n\n### 1、修饰代码块\n\n~~~java\n// 指定一个加锁的对象，给对象加锁\npublic Demo1{\n   Object lock=new Object();\n   public void test1(){\n       synchronized(lock){\n       }\n   }\n}\n~~~\n\n\n\n### 2、修饰静态方法\n\n~~~java\n// 对当前类的Class对象加锁\npublic class Demo2 {\n   //形式一\n    public void test1(){\n        synchronized(Demo2.class){\n        }\n    }\n  //形式二\n    public void test2(){\n        public synchronized static void test1(){\n        }\n    }\n}\n~~~\n\n### 3、修饰普通方法\n\n~~~java\n// 对当前实例对象this加锁\npublic class Demo3 {\n    public synchronized void test1(){\n    }\n}\n~~~\n\n\n\n## 三、字节码层面解读synchronize\n\n### 1、java代码\n\n~~~java\npublic static void main( String[] args ){\n    System.out.println( \"hello Java\" );\n}\n//synchronized修饰普通方法\npublic synchronized void test1() { }\n\n//修饰代码块\npublic void test2() {\n    synchronized (this) {}\n}\n~~~\n\n### 2、java字节码\n\n(字节码查看命令：javap -verbose  类名) 下文只是截取了test1 和 test2方法部分\n\ntest1()    <span style=\"color:#42B983;font-weight:bold;\">核心标志：</span><span style=\"color:#FC5531; font-weight:bold;\">ACC_SYNCHRONIZED</span>\n\n~~~java\n\'\'\'\npublic synchronized void test1();\n    descriptor: ()V\n    flags: ACC_PUBLIC, ACC_SYNCHRONIZED\n    Code:\n      stack=0, locals=1, args_size=1\n         0: return\n      LineNumberTable:\n        line 59: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       1     0  this   Lsite/ryanc/lock/SyncLearn;\n\'\'\'\n~~~\n\n> 如果修饰同步方法是通过的flag ACC_SYNCHRONIZED来完成的，也就是说一旦执行到这个方法，就会先判断是否有标志位，然后ACC_SYNCHRONIZED会去隐式调用刚才的两个指令：monitorenter和monitorexit。\n\n---\n\ntest2()    <span style=\"color:#42B983;font-weight:bold;\">核心指令：</span><span style=\"color:#FC5531; font-weight:bold;\">monitorenter 、monitorexit</span>\n\n~~~java\n\'\'\'\n public void test2();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=3, args_size=1\n         0: aload_0\n         1: dup\n         2: astore_1\n         3: monitorenter\n         4: aload_1\n         5: monitorexit\n         6: goto          14\n         9: astore_2\n        10: aload_1\n        11: monitorexit\n        12: aload_2\n        13: athrow\n        14: return\n~~~\n\n> 首先如果被synchronized修饰在方法块的话，是通过 monitorenter 和 monitorexit 这两个字节码指令获取线程的执行权的。当方法执行完毕退出以后或者出现异常的情况下会自动释放锁。\n\n### 3、综述\n\n<span style=\"color:#FC5531; font-weight:bold;\">简单说明：</span>\n在Java虚拟机执行到monitorenter指令时：</br>\n1首先它会尝试获取对象的锁，如果该对象没有锁，或者当前线程已经拥有了这个对象的锁时</br>\n它会把计数器+1；然后当执行到monitorexit 指令时就会将计数器-1</br>\n然后当计数器为0时，锁就释放了。2⃣️如果获取锁 失败，那么当前线程就要阻塞等待</br>\n直到对象锁被另一个线程释放为止。</br>\n\n<span style=\"color:#FC5531; font-weight:bold;\">问题讨论(面试经)：</span>为啥方法test2中有两个monitorexit？\n\n\n\n## 四、源码层面解读synchronize\n\n> 这里我们配合synchronize1.6优化后的，锁升级的过程来探究\n\n### 1、锁状态在markword的布局\n\n![1617267712331](../jvm/assets/1617267712331.png)\n\n### 2、无锁状态\n\n#### a、java代码\n\n~~~java\npublic class NoLock {\n    private static Object o = new Object();\n    public static void main(String[] args) {\n        System.out.println(ClassLayout.parseInstance(o).toPrintable());\n    }\n}\n~~~\n\n#### b、jol\n\n~~~\njava.lang.Object object internals:\n OFFSET  SIZE   TYPE DESCRIPTION VALUE\n      0     4   (object header)  01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      4     4   (object header)  00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4   (object header)  dd 01 00 f8 (11011101 00000001 00000000 11111000) (-134217251)\n     12     4   (loss due to the next object alignment)\nInstance size: 16 bytes\nSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total\n~~~\n\n<span style=\"color:#FC5531; font-weight:bold;\">问题讨论(面试经)：</span>上面布局中，锁标记状态最后两位，为啥打印出来是前两位？\n<span style=\"color:#42B983;font-weight:bold;\">解惑 : </span> 大端模式 和 小端模式\n\n总：无锁状态不涉及锁，我们从jol层面理解一下就好，这里不在深究 o.0\n\n### 3、偏向锁状态\n\n#### a、java代码\n\n~~~java\npublic class DeflectionLock {\n    private static Object o = new Object();\n//    private static Object o;\n\n    public static void main(String[] args) throws InterruptedException {\n//        Thread.sleep(5000);\n//        o = new Object();\n        System.out.println(ClassLayout.parseInstance(o).toPrintable());\n        lock();\n        System.out.println(ClassLayout.parseInstance(o).toPrintable());\n    }\n\n    private static void lock() {\n        synchronized (o) {\n\n        }\n    }\n}\n~~~\n\n#### b、jol\n\n~~~\njava.lang.Object object internals:\n OFFSET  SIZE   TYPE DESCRIPTION VALUE\n      0     4  (object header)   05 00 00 00 (00000101 00000000 00000000 00000000) (5)\n      4     4  (object header)   00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4  (object header)   dd 01 00 f8 (11011101 00000001 00000000 11111000) (-134217251)\n     12     4  (loss due to the next object alignment)\nInstance size: 16 bytes\nSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total\n\njava.lang.Object object internals:\n OFFSET  SIZE   TYPE DESCRIPTION VALUE\n      0     4  (object header)   05 50 05 01 (00000101 01010000 00000101 00000001) (17125381)\n      4     4  (object header)   00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4  (object header)   dd 01 00 f8 (11011101 00000001 00000000 11111000) (-134217251)\n     12     4  (loss due to the next object alignment)\nInstance size: 16 bytes\nSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total\n~~~\n\n<span style=\"color:#FC5531; font-weight:bold;\">问题讨论(面试经)：</span>上述代码打印的jol于我们预期的jol不同？</br>\n<span style=\"color:#42B983;font-weight:bold;\">解惑 : </span> jdk1.6后默认开启偏向锁（-XX:-UseBiasedLocking = true）输入延迟开启</br>\n\n\t   取消延时（XX:BiasedLockingStartUpDelay=0；）</br>\n\n#### c、加锁流程\n\n![image-20210411165923326](amWiki_datas/amWiki/images/lib_img/image-20210411165923326.png)\n\n\n\n#### d、monitorenter指令源码\n\n~~~c++\n\'\'\'\n//UseHeavyMonitors表示是否只使用重量级锁，默认为false，如果为true则调用InterpreterRuntime::monitorenter方法获取重量级锁\n  if (UseHeavyMonitors) {\n    call_VM(noreg,CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n            lock_reg);\n  } else {\n    Label done;\n    \'\'\'\n     //UseBiasedLocking默认为true\n    if (UseBiasedLocking) {\n      //首先尝试获取偏向锁，获取成功会跳转到done，否则走到slow_case\n      biased_locking_enter(lock_reg, obj_reg, swap_reg, rscratch1, false, done, \t\t\t  &slow_case);\n    }\n\n~~~\n\n<span style=\"color:#FC5531; font-weight:bold;\">简单说明：</span> \n\n1、UseHeavyMonitors：首先判断是否使用重级锁，默认是false；</br>\n\n2、UseBiasedLocking:是否启用偏向锁,1.6以后默认开启,也可关闭(-XX:-UseBiasedLocking = false）</br>\n\n3、biased_locking_enter();该方法用cas将当前线程id刷新到 对象头markword中\n\n### 4、轻量级锁\n\n#### a、java代码\n\n~~~java\npublic class LightweightLocking {\n    private static Object o;\n    public static void main(String[] args) throws InterruptedException {\n        Thread.sleep(5000L);\n        o = new Object();\n        System.out.println(ClassLayout.parseInstance(o).toPrintable());\n        new Thread(LightweightLocking::lock).start();\n        // 加个睡眠是怕上面的线程没有执行完成而形成线程争用而升级为重量级锁\n        Thread.sleep(3000L);\n        lock();\n        System.out.println(ClassLayout.parseInstance(o).toPrintable());\n    }\n\n    private static void lock() {\n        synchronized (o) {\n            System.out.println(ClassLayout.parseInstance(o).toPrintable());\n        }\n    }\n}\n~~~\n\n\n\n#### b、jol\n\n> 运行java代码查看，探讨\n\n#### c、monitorenter指令源码\n\n~~~c++\nvoid ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) {\n  markOop mark = obj->mark();\n  assert(!mark->has_bias_pattern(), \"should not see bias pattern here\");\n\n  if (mark->is_neutral()) {//如果当前是无锁状态, markword的\n    //直接把mark保存到BasicLock对象的_displaced_header字段\n    lock->set_displaced_header(mark);\n    //通过CAS将mark word更新为指向BasicLock对象的指针，更新成功表示获得了轻量级锁\n    if (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()->mark_addr(), mark)) {\n      TEVENT (slow_enter: release stacklock) ;\n      return ;\n    }\n    // Fall through to inflate() ...\n  } \n  //如果markword处于加锁状态、且markword中的ptr指针指向当前线程的栈帧，表示为重入操作，不需要争抢锁\n  else\n  if (mark->has_locker() && THREAD->is_lock_owned((address)mark->locker())) {\n    assert(lock != mark->locker(), \"must not re-lock the same lock\");\n    assert(lock != (BasicLock*)obj->mark(), \"don\'t relock with same BasicLock\");\n    lock->set_displaced_header(NULL);\n    return;\n  }\n\n#if 0\n  // The following optimization isn\'t particularly useful.\n  if (mark->has_monitor() && mark->monitor()->is_entered(THREAD)) {\n    lock->set_displaced_header (NULL) ;\n    return ;\n  }\n#endif\n\t//代码执行到这里，说明有多个线程竞争轻量级锁，轻量级锁通过`inflate`进行膨胀升级为重量级锁\n  lock->set_displaced_header(markOopDesc::unused_mark());\n  ObjectSynchronizer::inflate(THREAD, obj())->enter(THREAD);\n}\n~~~\n\n<span style=\"color:#FC5531; font-weight:bold;\">简单说明：</span> \n\n1、在关闭偏向锁、或多线程竞争是发现偏向锁已经被获取时，就会升级为轻量级锁（自旋锁）\n\n2、Atomic::cmpxchg_ptr：cas修改资源对象markword 中指向当前线程的lockrecord对象\n\n总：当多次(10次,-XX:PreBlockSpin可以修改)cas修改markword指向锁记录的指针失败，就会升级为重量级锁\n\n#### d、加锁流程\n\n![image-20210411165941361](amWiki_datas/amWiki/images/lib_img/image-20210411165941361.png)\n\n#### e、解锁流程\n\n![image-20210411165959511](amWiki_datas/amWiki/images/lib_img/image-20210411165959511.png)\n\n### 5、重量级锁\n\n#### a、java代码\n\n~~~java\npublic class HeavyweightLock {\n    private static Object o;\n    public static void main(String[] args) throws InterruptedException {\n        Thread.sleep(5000L);\n        o = new Object();\n        System.out.println(ClassLayout.parseInstance(o).toPrintable());\n        new Thread(HeavyweightLock::lock).start();\n        lock();\n        System.out.println(ClassLayout.parseInstance(o).toPrintable());\n    }\n\n    private static void lock() {\n        synchronized (o) {\n            System.out.println(ClassLayout.parseInstance(o).toPrintable());\n        }\n    }\n}\n~~~\n\n\n\n#### b、jol\n\n> 运行java代码查看，探讨\n\n\n\n#### c、指令源码\n\n* 第一段\n\n~~~c++\nvoid ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) {\n  markOop mark = obj->mark();\n  assert(!mark->has_bias_pattern(), \"should not see bias pattern here\");\n\n  if (mark->is_neutral()) {//如果当前是无锁状态, markword的\n    //直接把mark保存到BasicLock对象的_displaced_header字段\n    lock->set_displaced_header(mark);\n    //通过CAS将mark word更新为指向BasicLock对象的指针，更新成功表示获得了轻量级锁\n    if (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()->mark_addr(), mark)) {\n      TEVENT (slow_enter: release stacklock) ;\n      return ;\n    }\n    // Fall through to inflate() ...\n  } \n  //如果markword处于加锁状态、且markword中的ptr指针指向当前线程的栈帧，表示为重入操作，不需要争抢锁\n  else\n  if (mark->has_locker() && THREAD->is_lock_owned((address)mark->locker())) {\n    assert(lock != mark->locker(), \"must not re-lock the same lock\");\n    assert(lock != (BasicLock*)obj->mark(), \"don\'t relock with same BasicLock\");\n    lock->set_displaced_header(NULL);\n    return;\n  }\n\n#if 0\n  // The following optimization isn\'t particularly useful.\n  if (mark->has_monitor() && mark->monitor()->is_entered(THREAD)) {\n    lock->set_displaced_header (NULL) ;\n    return ;\n  }\n#endif\n\t//代码执行到这里，说明有多个线程竞争轻量级锁，轻量级锁通过`inflate`进行膨胀升级为重量级锁\n  lock->set_displaced_header(markOopDesc::unused_mark());\n  ObjectSynchronizer::inflate(THREAD, obj())->enter(THREAD);\n}\n~~~\n\n* 第二段\n\n~~~c++\nObjectMonitor * ATTR ObjectSynchronizer::inflate (Thread * Self, oop object) {\n  ...\n\n  for (;;) {\n      const markOop mark = object->mark() ;\n      assert (!mark->has_bias_pattern(), \"invariant\") ;\n    \n      // mark是以下状态中的一种：\n      // *  Inflated（重量级锁状态）     - 直接返回\n      // *  Stack-locked（轻量级锁状态） - 膨胀\n      // *  INFLATING（膨胀中）    - 忙等待直到膨胀完成\n      // *  Neutral（无锁状态）      - 膨胀\n      // *  BIASED（偏向锁）       - 非法状态，在这里不会出现\n\n      // CASE: inflated\n      if (mark->has_monitor()) {\n          // 已经是重量级锁状态了，直接返回\n          ObjectMonitor * inf = mark->monitor() ;\n          ...\n          return inf ;\n      }\n\n      // CASE: inflation in progress\n      if (mark == markOopDesc::INFLATING()) {\n         // 正在膨胀中，说明另一个线程正在进行锁膨胀，continue重试\n         TEVENT (Inflate: spin while INFLATING) ;\n         // 在该方法中会进行spin/yield/park等操作完成自旋动作 \n         ReadStableMark(object) ;\n         continue ;\n      }\n \n      if (mark->has_locker()) {\n          // 当前轻量级锁状态，先分配一个ObjectMonitor对象，并初始化值\n          ObjectMonitor * m = omAlloc (Self) ;\n          \n          m->Recycle();\n          m->_Responsible  = NULL ;\n          m->OwnerIsThread = 0 ;\n          m->_recursions   = 0 ;\n          m->_SpinDuration = ObjectMonitor::Knob_SpinLimit ;   // Consider: maintain by type/class\n  // 将锁对象的mark word设置为INFLATING (0)状态 \n          markOop cmp = (markOop) Atomic::cmpxchg_ptr (markOopDesc::INFLATING(), object->mark_addr(), mark) ;\n          if (cmp != mark) {\n             omRelease (Self, m, true) ;\n             continue ;       // Interference -- just retry\n          }\n\n          // 栈中的displaced mark word\n          markOop dmw = mark->displaced_mark_helper() ;\n          assert (dmw->is_neutral(), \"invariant\") ;\n\n          // 设置monitor的字段\n          m->set_header(dmw) ;\n          // owner为Lock Record\n          m->set_owner(mark->locker());\n          m->set_object(object);\n          ...\n          // 将锁对象头设置为重量级锁状态\n          object->release_set_mark(markOopDesc::encode(m));\n\n         ...\n          return m ;\n      }\n\n      // CASE: neutral\n    \n      // 分配以及初始化ObjectMonitor对象\n      ObjectMonitor * m = omAlloc (Self) ;\n      // prepare m for installation - set monitor to initial state\n      m->Recycle();\n      m->set_header(mark);\n      // owner为NULL\n      m->set_owner(NULL);\n      m->set_object(object);\n      m->OwnerIsThread = 1 ;\n      m->_recursions   = 0 ;\n      m->_Responsible  = NULL ;\n      m->_SpinDuration = ObjectMonitor::Knob_SpinLimit ;       // consider: keep metastats by type/class\n  // 用CAS替换对象头的mark word为重量级锁状态\n      if (Atomic::cmpxchg_ptr (markOopDesc::encode(m), object->mark_addr(), mark) != mark) {\n          // 不成功说明有另外一个线程在执行inflate，释放monitor对象\n          m->set_object (NULL) ;\n          m->set_owner  (NULL) ;\n          m->OwnerIsThread = 0 ;\n          m->Recycle() ;\n          omRelease (Self, m, true) ;\n          m = NULL ;\n          continue ;\n          // interference - the markword changed - just retry.\n          // The state-transitions are one-way, so there\'s no chance of\n          // live-lock -- \"Inflated\" is an absorbing state.\n      }\n\n      ...\n      return m ;\n  }\n}\n~~~\n\n* 第三段\n\n~~~c++\nvoid ATTR ObjectMonitor::enter(TRAPS) {\n   \n  Thread * const Self = THREAD ;\n  void * cur ;\n  // owner为null代表无锁状态，如果能CAS设置成功，则当前线程直接获得锁\n  cur = Atomic::cmpxchg_ptr (Self, &_owner, NULL) ;\n  if (cur == NULL) {\n     ...\n     return ;\n  }\n  // 如果是重入的情况\n  if (cur == Self) {\n     // TODO-FIXME: check for integer overflow!  BUGID 6557169.\n     _recursions ++ ;\n     return ;\n  }\n  // 当前线程是之前持有轻量级锁的线程。由轻量级锁膨胀且第一次调用enter方法，那cur是指向Lock Record的指针\n  if (Self->is_lock_owned ((address)cur)) {\n    assert (_recursions == 0, \"internal state error\");\n    // 重入计数重置为1\n    _recursions = 1 ;\n    // 设置owner字段为当前线程（之前owner是指向Lock Record的指针）\n    _owner = Self ;\n    OwnerIsThread = 1 ;\n    return ;\n  }\n\n  ...\n\n  // 在调用系统的同步操作之前，先尝试自旋获得锁\n  if (Knob_SpinEarly && TrySpin (Self) > 0) {\n     ...\n     //自旋的过程中获得了锁，则直接返回\n     Self->_Stalled = 0 ;\n     return ;\n  }\n\n  ...\n\n  { \n    ...\n\n    for (;;) {\n      jt->set_suspend_equivalent();\n      // 在该方法中调用系统同步操作\n      EnterI (THREAD) ;\n      ...\n    }\n    Self->set_current_pending_monitor(NULL);\n    \n  }\n\n  ...\n\n}\n~~~\n\n\n\n<span style=\"color:#FC5531; font-weight:bold;\">简单说明：</span> \n\n1、当代码执行到上述代码的最后两行时，有轻量级锁升级为重量级锁\n\n2、此时引入了“ObjectMonitor“对象\n\n3、膨胀完后再用第三段代码 中的enter方法获得锁\n\n#### d、ObjectMonitor\n\n~~~ c++\n\nObjectMonitor::ObjectMonitor() {  \n  _header       = NULL;  \n  _count       = 0;  \n  _waiters      = 0,  \n  _recursions   = 0;       //线程的重入次数\n  _object       = NULL;  \n  _owner        = NULL;    //标识拥有该monitor的线程\n  _WaitSet      = NULL;    //等待线程组成的双向循环链表，_WaitSet是第一个节点\n  _WaitSetLock  = 0 ;  \n  _Responsible  = NULL ;  \n  _succ         = NULL ;  \n  _cxq          = NULL ;    //多线程竞争锁进入时的单向链表\n  FreeNext      = NULL ;  \n  _EntryList    = NULL ;    //_owner从该双向循环链表中唤���线程结点，_EntryList是第一个节点\n  _SpinFreq     = 0 ;  \n  _SpinClock    = 0 ;  \n  OwnerIsThread = 0 ;  \n} \n~~~\n\n\n\n#### d、锁膨胀流程\n\n![image-20210411170026522](amWiki/images/lib_img/image-20210411170026522.png)\n\n#### e、加锁流程\n\n![img](https://img-blog.csdnimg.cn/2020032811351930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxODY1OTgz,size_16,color_FFFFFF,t_70)\n\n#### f、wait流程\n\n~~~c++\n  //1.调用ObjectSynchronizer::wait方法\nvoid ObjectSynchronizer::wait(Handle obj, jlong millis, TRAPS) {\n  /*省略 */\n  //2.获得Object的monitor对象(即内置锁)\n  ObjectMonitor* monitor = ObjectSynchronizer::inflate(THREAD, obj());\n  DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), THREAD, millis);\n  //3.调用monitor的wait方法\n  monitor->wait(millis, true, THREAD);\n  /*省略*/\n}\n  //4.在wait方法中调用addWaiter方法\n  inline void ObjectMonitor::AddWaiter(ObjectWaiter* node) {\n  /*省略*/\n  if (_WaitSet == NULL) {\n    //_WaitSet为null，就初始化_waitSet\n    _WaitSet = node;\n    node->_prev = node;\n    node->_next = node;\n  } else {\n    //否则就尾插\n    ObjectWaiter* head = _WaitSet ;\n    ObjectWaiter* tail = head->_prev;\n    assert(tail->_next == head, \"invariant check\");\n    tail->_next = node;\n    head->_prev = node;\n    node->_next = head;\n    node->_prev = tail;\n  }\n}\n  //5.然后在ObjectMonitor::exit释放锁，接着 thread_ParkEvent->park  也就是wait\n~~~\n\n\n\n![img](https://img-blog.csdnimg.cn/2020032811351930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxODY1OTgz,size_16,color_FFFFFF,t_70)\n\n#### g、notify流程\n\n~~~c++\n //1.调用ObjectSynchronizer::notify方法\n    void ObjectSynchronizer::notify(Handle obj, TRAPS) {\n    /*省略*/\n    //2.调用ObjectSynchronizer::inflate方法\n    ObjectSynchronizer::inflate(THREAD, obj())->notify(THREAD);\n}\n    //3.通过inflate方法得到ObjectMonitor对象\n    ObjectMonitor * ATTR ObjectSynchronizer::inflate (Thread * Self, oop object) {\n    /*省略*/\n     if (mark->has_monitor()) {\n          ObjectMonitor * inf = mark->monitor() ;\n          assert (inf->header()->is_neutral(), \"invariant\");\n          assert (inf->object() == object, \"invariant\") ;\n          assert (ObjectSynchronizer::verify_objmon_isinpool(inf), \"monitor is inva;lid\");\n          return inf \n      }\n    /*省略*/ \n      }\n    //4.调用ObjectMonitor的notify方法\n    void ObjectMonitor::notify(TRAPS) {\n    /*省略*/\n    //5.调用DequeueWaiter方法移出_waiterSet第一个结点\n    ObjectWaiter * iterator = DequeueWaiter() ;\n    //6.后面省略是将上面DequeueWaiter尾插入_EntrySet的操作\n    /**省略*/\n  }\n~~~\n\n\n\n![img](https://img-blog.csdnimg.cn/20200328200119362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxODY1OTgz,size_16,color_FFFFFF,t_70)\n\n#### h、解锁流程\n\n![img](https://img-blog.csdnimg.cn/20200328210803767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxODY1OTgz,size_16,color_FFFFFF,t_70)\n\n### 6、总述\n\n#### a、整体加锁流程\n\n![img](https://img-blog.csdnimg.cn/2020032320204669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxODY1OTgz,size_16,color_FFFFFF,t_70)\n\n#### b、整体解锁流程\n\n![img](https://img-blog.csdnimg.cn/2020032309275286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxODY1OTgz,size_16,color_FFFFFF,t_70)\n\n## 五、锁优化\n\n### 1、锁粗化\n\n<span style=\"color:#FC5531; font-weight:bold;\">锁粗化 : </span> \n\n如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的</br>\n\n那即使没有出现线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</br>\n\n如果虚拟机检测到有一串零碎的操作都是对同一对象的加锁，将会把加锁同步的范围扩展（粗化）到</br>\n\n整个操作序列的外部。</br>\n\n<span style=\"color:#FC5531; font-weight:bold;\">举栗子</span>\n\n~~~java\npublic class StringBufferTest {\n    StringBuffer stringBuffer = new StringBuffer();\n\n    public void append(){\n        stringBuffer.append(\"a\");\n        stringBuffer.append(\"b\");\n        stringBuffer.append(\"c\");\n    }\n}\n~~~\n\n> 这里每次调用stringBuffer.append方法都需要加锁和解锁，如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。\n\n### 2、锁消除\n\n<span style=\"color:#FC5531; font-weight:bold;\">锁消除 : </span>\n\n即删除不必要的加锁操作。虚拟机即时编辑器在运行时，对一些“代码上要求同步</br>\n\n但是被检测到不可能存在共享数据竞争”的锁进行消除。</br>\n\n根据代码<span style=\"color:#42B983;font-weight:bold;\"> 逃逸技术 </span>，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，</br>\n\n那么可以认为这段代码是线程安全的，不必要加锁。</br>\n\n<span style=\"color:#FC5531; font-weight:bold;\">举栗子</span>\n\n~~~java\npublic class SynchronizedTest {\n\n    public static void main(String[] args) {\n        SynchronizedTest test = new SynchronizedTest();\n\n        for (int i = 0; i < 100000000; i++) {\n            test.append(\"abc\", \"def\");\n        }\n    }\n\n    public void append(String str1, String str2) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(str1).append(str2);\n    }\n}\n~~~\n\n> 虽然StringBuffer的append是一个同步方法，但是这段程序中的StringBuffer属于一个局部变量，并且不会从该方法中逃逸出去（即StringBuffer sb的引用没有传递到该方法外，不可能被其他线程拿到该引用），所以其实这过程是线程安全的，可以将锁消除。\n\n## 附录\n\n### 面试经\n\n1、简述锁膨胀原理？锁粗化、锁消除。。。\n\n### 解惑\n\n#### 1、大端模式&小段模式\n\n<span style=\"color:#FC5531; font-weight:bold;\">大端模式</span> 是高位字节存储在底地址段，低位字节存储在高地址段</br>\n<span style=\"color:#FC5531; font-weight:bold;\">小端模式</span> 是低位字节存储在底地址段，高位字节存储在高地址段</br>\n\n~~~java\n0x 00 00 00 00 00 00 00 01 表示MarkWord的8个字节，最左边就是高位字节，最右边就是地位字节\n小端模式在内存中存储顺序：\n0x 01 00 00 00 00 00 00 00\n大端模式在内存中存储顺序:\n0x 00 00 00 00 00 00 00 01 \n~~~\n\n#### 2、monitorenter指令实现\n\n~~~c++\n\nvoid TemplateTable::monitorenter() {\n  //校验当前指令的栈顶缓存类型是否正确\n  transition(atos, vtos);\n \n  //校验rax中值是否为空，栈顶缓存就保存在rax寄存器中，如果为NULL会触发底层操作系统的NULL异常\n  //此时rax中保存的是用于获取锁的实例oop\n  __ null_check(rax);\n \n  const Address monitor_block_top(\n        rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize);\n  const Address monitor_block_bot(\n        rbp, frame::interpreter_frame_initial_sp_offset * wordSize);\n  const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;\n \n  Label allocated;\n \n  //xorl用于按位异或，相同的位置为0，不同的位置为1，此处是将c_rarg1置为NULL\n  __ xorl(c_rarg1, c_rarg1); // points to free slot or NULL\n \n  //找到一个空闲的monitor_block，结果保存在c_rarg1中\n  {\n    Label entry, loop, exit;\n    //将monitor_block_top拷贝到c_rarg3中\n    __ movptr(c_rarg3, monitor_block_top); // points to current entry,\n                                     // starting with top-most entry\n    //将monitor_block_bot拷贝到c_rarg2                             \n    __ lea(c_rarg2, monitor_block_bot); // points to word before bottom\n                                     // of monitor block\n    //跳转到entry标签处执行                     \n    __ jmpb(entry);\n \n    __ bind(loop);\n    //判断c_rarg3指向的BasicObjectLock的obj属性是否为空，如果为空表示未使用\n    __ cmpptr(Address(c_rarg3, BasicObjectLock::obj_offset_in_bytes()), (int32_t) NULL_WORD);\n    //如果相等，即BasicObjectLock的obj属性为空，则将c_rarg3的值拷贝到c_rarg1\n    __ cmov(Assembler::equal, c_rarg1, c_rarg3);\n    // 判断c_rarg3指向的BasicObjectLock的obj属性与rax中实例是否一致\n    __ cmpptr(rax, Address(c_rarg3, BasicObjectLock::obj_offset_in_bytes()));\n    // 如果一致则退出，一致说明BasicObjectLock的obj属性不为空，此时c_rarg1为空，就是重新分配一个新的\n    __ jccb(Assembler::equal, exit);\n    // 如果不一致则把c_rarg3地址加上entry_size，即开始遍历前面一个monitor_block，即存在空闲的，但是没有obj属性相同的时候会把所有的\n    //BasicObjectLock都遍历一遍，找到最上面的地址最大一个空闲的BasicObjectLock\n    __ addptr(c_rarg3, entry_size);\n    __ bind(entry);\n    //判断两个寄存器的值是否相等\n    __ cmpptr(c_rarg3, c_rarg2);\n    //如果不等于则跳转到loop标签，否则跳转到exit\n    __ jcc(Assembler::notEqual, loop);\n    __ bind(exit);\n  }\n   \n  //判断c_rarg1是否为空，如果不为空则跳转到allocated处\n  __ testptr(c_rarg1, c_rarg1); // check if a slot has been found\n  __ jcc(Assembler::notZero, allocated); // if found, continue with that one\n \n  //如果没有找到空闲的monitor_block则分配一个\n  {\n    Label entry, loop;\n    // 将monitor_block_bot拷贝到c_rarg1            // rsp: old expression stack top\n    __ movptr(c_rarg1, monitor_block_bot); // c_rarg1: old expression stack bottom\n    //向下（低地址端）移动rsp指针entry_size字节\n    __ subptr(rsp, entry_size);            // move expression stack top\n    //将c_rarg1减去entry_size\n    __ subptr(c_rarg1, entry_size);        // move expression stack bottom\n    //将rsp拷贝到c_rarg3\n    __ mov(c_rarg3, rsp);                  // set start value for copy loop\n    //将c_rarg1中的值写入到monitor_block_bot\n    __ movptr(monitor_block_bot, c_rarg1); // set new monitor block bottom\n    //跳转到entry处开始循环\n    __ jmp(entry);\n    // 2.移动monitor_block_bot到栈顶的数据，将从栈顶分配的一个monitor_block插入到原来的monitor_block_bot下面\n    __ bind(loop);\n    //将c_rarg3之后的entry_size处的地址拷贝到c_rarg2，即原来的rsp地址\n    __ movptr(c_rarg2, Address(c_rarg3, entry_size)); // load expression stack\n                                                      // word from old location\n    //将c_rarg2中的数据拷贝到c_rarg3处，即新的rsp地址                                                  \n    __ movptr(Address(c_rarg3, 0), c_rarg2);          // and store it at new location\n    //c_rarg3加上一个字宽，即准备复制下一个字宽的数据\n    __ addptr(c_rarg3, wordSize);                     // advance to next word\n    __ bind(entry);\n    //比较两个寄存器的值\n    __ cmpptr(c_rarg3, c_rarg1);            // check if bottom reached\n    //如果不等于则跳转到loop\n    __ jcc(Assembler::notEqual, loop);      // if not at bottom then\n                                            // copy next word\n  }\n \n  // call run-time routine\n  // c_rarg1: points to monitor entry\n  __ bind(allocated);\n \n  //增加r13，使其指向下一个字节码指令\n  __ increment(r13);\n \n  //将rax中保存的获取锁的oop保存到c_rarg1指向的BasicObjectLock的obj属性中\n  __ movptr(Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()), rax);\n  //获取锁\n  __ lock_object(c_rarg1);\n \n  //保存bcp，为了出现异常时能够返回到原来的执行位置\n  __ save_bcp();  // in case of exception\n  __ generate_stack_overflow_check(0);\n  \n  //恢复字节码指令的正常执行\n  //因为上面已经增加r13了，所以此处dispatch_next的第二个参数使用默认值0，即执行r13指向的字节码指令即可，不用跳转到下一个指令\n  __ dispatch_next(vtos);\n}\n \nvoid InterpreterMacroAssembler::lock_object(Register lock_reg) {\n  assert(lock_reg == c_rarg1, \"The argument is only for looks. It must be c_rarg1\");\n \n  //UseHeavyMonitors表示是否只使用重量级锁，默认为false，如果为true则调用InterpreterRuntime::monitorenter方法获取重量级锁\n  if (UseHeavyMonitors) {\n    call_VM(noreg,\n            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n            lock_reg);\n  } else {\n    Label done;\n \n    const Register swap_reg = rax; // Must use rax for cmpxchg instruction\n    const Register obj_reg = c_rarg3; // Will contain the oop\n \n    const int obj_offset = BasicObjectLock::obj_offset_in_bytes();\n    const int lock_offset = BasicObjectLock::lock_offset_in_bytes ();\n    const int mark_offset = lock_offset +\n                            BasicLock::displaced_header_offset_in_bytes();\n \n    Label slow_case;\n    \n    //进入此方法目标obj要么是无锁状态，要么是对同一个对象的synchronized嵌套情形下的有锁状态\n    //将用于获取锁的实例oop拷贝到obj_reg中\n    movptr(obj_reg, Address(lock_reg, obj_offset));\n    \n    //UseBiasedLocking默认为true\n    if (UseBiasedLocking) {\n      //首先尝试获取偏向锁，获取成功会跳转到done，否则走到slow_case\n      biased_locking_enter(lock_reg, obj_reg, swap_reg, rscratch1, false, done, &slow_case);\n    }\n    \n    //如果UseBiasedLocking为false或者目标对象的锁不是偏向锁了会走此逻辑\n    movl(swap_reg, 1);\n \n    //计算 object->mark() | 1，结果保存到swap_reg，跟1做或运算将其标记为无锁状态\n    orptr(swap_reg, Address(obj_reg, 0));\n \n    //将(object->mark() | 1)的结果保存到BasicLock的displaced_header中，保存原来的对象头\n    movptr(Address(lock_reg, mark_offset), swap_reg);\n \n    //lock_reg即是里面的lock属性的地址\n    assert(lock_offset == 0,\n           \"displached header must be first word in BasicObjectLock\");\n \n    if (os::is_MP()) lock(); //如果是多核系统，通过lock指令保证cmpxchgp的操作是原子的，即只可能有一个线程操作obj对象头\n    //将obj的对象头同rax即swap_reg比较，如果相等将lock_reg写入obj对象头，即lock属性写入obj对象头，如果不等于则将obj对象头放入rax中\n    cmpxchgptr(lock_reg, Address(obj_reg, 0));\n    if (PrintBiasedLockingStatistics) {\n      //增加计数器\n      cond_inc32(Assembler::zero,\n                 ExternalAddress((address) BiasedLocking::fast_path_entry_count_addr()));\n    }\n    //如果等于，说明obj的对象头是无锁状态的，此时跟1做或运算，结果不变\n    jcc(Assembler::zero, done);\n    \n    //如果不等于，说明obj的对象头要么是偏向锁，要么是重量级锁，多线程下可能其他线程已经获取了该对象的轻量级锁\n    //下面的汇编指令相当于执行如下判断，判断目标对应的对象头是否属于当前调用栈帧，如果是说明还是当前线程占有该轻量级锁，如果不是则说明其他线程占用了轻量级锁或者已经膨胀成重量级锁\n    //  1) (mark & 7) == 0, and\n    //  2) rsp <= mark < mark + os::pagesize()\n    subptr(swap_reg, rsp);\n    andptr(swap_reg, 7 - os::vm_page_size());\n \n    //在递归即synchronized嵌套使用的情形下，上述指令计算的结果就是0\n    //当BasicLock的displaced_header置为NULL\n    movptr(Address(lock_reg, mark_offset), swap_reg);\n    if (PrintBiasedLockingStatistics) {\n      //增加计数器\n      cond_inc32(Assembler::zero,\n                 ExternalAddress((address) BiasedLocking::fast_path_entry_count_addr()));\n    }\n    //如果andptr的结果为0，说明当前线程已经获取了轻量级锁则跳转到done\n    jcc(Assembler::zero, done);\n    //否则执行InterpreterRuntime::monitorenter将轻量级锁膨胀成重量级锁或者获取重量级锁\n    bind(slow_case);\n \n    // Call the runtime routine for slow case\n    call_VM(noreg,\n            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n            lock_reg);\n \n    bind(done);\n  }\n}\n~~~\n\n#### 3、monitorexit指令实现\n\n~~~c++\nvoid TemplateTable::monitorexit() {\n  //检查栈顶缓存的类型是否正确\n  transition(atos, vtos);\n \n  //检查rax包含的跟锁关联的对象oop是否为空\n  __ null_check(rax);\n \n  const Address monitor_block_top(\n        rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize);\n  const Address monitor_block_bot(\n        rbp, frame::interpreter_frame_initial_sp_offset * wordSize);\n  const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;\n \n  Label found;\n \n  // find matching slot\n  {\n    Label entry, loop;\n    //把monitor_block_top拷贝到c_rarg1\n    __ movptr(c_rarg1, monitor_block_top); // points to current entry,\n                                     // starting with top-most entry\n    //把monitor_block_bot拷贝到c_rarg2                    \n    __ lea(c_rarg2, monitor_block_bot); // points to word before bottom\n                                     // of monitor block\n    __ jmpb(entry);\n \n    __ bind(loop);\n    //比较rax中对象oop与obj属性是否一致\n    __ cmpptr(rax, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));\n    //如果一致则表示找到了跳转到found\n    __ jcc(Assembler::equal, found);\n    //如果没有找到则增加entry_size，即开始遍历前面一个BasicObjectLock\n    __ addptr(c_rarg1, entry_size);\n    __ bind(entry);\n    //比较这两个是否相等，如果相等表示遍历完成\n    __ cmpptr(c_rarg1, c_rarg2);\n    //如果不等则跳转到loop标签\n    __ jcc(Assembler::notEqual, loop);\n  }\n \n  //没有在当前线程的栈帧中找到关联的BasicObjectLock，抛出异常\n  __ call_VM(noreg, CAST_FROM_FN_PTR(address,\n                   InterpreterRuntime::throw_illegal_monitor_state_exception));\n  __ should_not_reach_here();\n \n  // call run-time routine\n  // rsi: points to monitor entry\n  __ bind(found);\n  //将这个锁对象放入栈帧中\n  __ push_ptr(rax); // make sure object is on stack (contract with oopMaps)\n  //执行解锁逻辑\n  __ unlock_object(c_rarg1);\n  //从栈帧中弹出锁对象\n  __ pop_ptr(rax); // discard object\n}\n \nvoid InterpreterMacroAssembler::unlock_object(Register lock_reg) {\n  assert(lock_reg == c_rarg1, \"The argument is only for looks. It must be rarg1\");\n \n  if (UseHeavyMonitors) {\n    //如果只使用重量级锁，UseHeavyMonitors默认为false\n    call_VM(noreg,\n            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit),\n            lock_reg);\n  } else {\n    Label done;\n \n    const Register swap_reg   = rax;  // Must use rax for cmpxchg instruction\n    const Register header_reg = c_rarg2;  // Will contain the old oopMark\n    const Register obj_reg    = c_rarg3;  // Will contain the oop\n \n    save_bcp(); //保存bcp，方便解锁异常时回滚\n \n    //将lock属性的地址复制到swap_reg\n    lea(swap_reg, Address(lock_reg, BasicObjectLock::lock_offset_in_bytes()));\n \n    //将obj属性复制到obj_reg\n    movptr(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()));\n \n    //将obj属性置为NULL\n    movptr(Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()), (int32_t)NULL_WORD);\n \n    if (UseBiasedLocking) {\n      //如果持有偏向锁，则解锁完成后跳转到done\n      biased_locking_exit(obj_reg, header_reg, done);\n    }\n \n    //将BasicLock的displaced_header属性复制到header_reg中，即该对象原来的对象头\n    movptr(header_reg, Address(swap_reg,\n                               BasicLock::displaced_header_offset_in_bytes()));\n \n    //判断这个是否为空\n    testptr(header_reg, header_reg);\n \n    //如果为空说明这是对同一目标对象的synchronized嵌套情形，则跳转到done，等到外层的synchronized解锁恢复目标对象的对象头\n    jcc(Assembler::zero, done);\n \n    // Atomic swap back the old header\n    if (os::is_MP()) lock();//如果是多核系统则通过lock指令前缀将cmpxchg变成一个原子操作，即只能有一个线程同时操作obj的对象头\n    //将obj的对象头同rax即swap_reg，即lock属性地址比较，如果相等把header_reg写入到obj的对象头中即恢复对象头，如果不等把obj对象头写入rax中\n    cmpxchgptr(header_reg, Address(obj_reg, 0));\n \n    //如果相等，说明还是轻量级锁，解锁完成\n    jcc(Assembler::zero, done);\n \n    //如果不等于，说明轻量级锁被膨胀成重量级锁，恢复obj属性，因为上面将该属性置为NULL\n    movptr(Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()),\n         obj_reg); // restore obj\n    //调用InterpreterRuntime::monitorexit，完成重量级锁退出     \n    call_VM(noreg,\n            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit),\n            lock_reg);\n \n    bind(done);\n    //恢复bcp\n    restore_bcp();\n  }\n}\n \n//偏向锁的解锁只是判断目标对象是否持有偏向锁，如果持有就跳转到done，没有实际的解锁动作\nvoid MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label& done) {\n  assert(UseBiasedLocking, \"why call this otherwise?\");\n  //将obj的对象头拷贝到temp_reg\n  movptr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n  //将对象头指针同biased_lock_mask_in_place求且\n  andptr(temp_reg, markOopDesc::biased_lock_mask_in_place);\n  //判断且运算后的结果是否是5\n  cmpptr(temp_reg, markOopDesc::biased_lock_pattern);\n  //如果相等则跳转到done\n  jcc(Assembler::equal, done);\n}\n~~~\n\n#### 4、自适应的自旋锁\n\n* 简述\n\n  JDK1.6引入自适应的自旋锁，自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：如果在同一个锁的对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。简单来说，就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。\n\n* 场景\n\n  从轻量级锁获取的流程中我们知道，当线程在获取轻量级锁的过程中执行CAS操作失败时，是要通过自旋来获取重量级锁的。（见前面“轻量级锁”）\n\n### 参考\n\n[深入理解synchronized底层源码，小白这篇足够了_MarkJava-CSDN博客](https://blog.csdn.net/realize_dream/article/details/106968443)\n\n[深入OpenJDK源码核心探秘Unsafe(含JNI完整使用流程)_黄智霖的博客-CSDN博客](https://blog.csdn.net/huangzhilin2015/article/details/101158137)\n\n[synchronized的锁升级过程和详细的代码演示_killerofjava的博客-CSDN博客](https://blog.csdn.net/killerofjava/article/details/112445366)\n\n[Hotspot synchronized与volatile关键字实现（一） 源码解析_菜鸟进阶之路-CSDN博客](https://blog.csdn.net/qq_31865983/article/details/104875342)\n\n[Hotspot 三种锁实现总结_菜鸟进阶之路-CSDN博客](https://blog.csdn.net/qq_31865983/article/details/105024397)\n\n[死磕Synchronized底层实现--重量级锁-Java架构笔记-51CTO博客](https://blog.51cto.com/14440216/2427707?source=dra)\n\n","timestamp":1618132041402},{"name":"01-sikulix快速上手.md","path":"02-java篇/03-第三方/03-上帝之眼sikulix/01-sikulix快速上手.md","content":"# sikulix快速上手\n\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2020年12月19日15:47:31</span>\n\n## 一、第三方依赖\n\n* maven依赖坐标\n\n  ~~~xml\n  <!-- sikulix maven坐标 版本按需选择 -->\n  <dependency>\n     <groupId>com.sikulix</groupId>\n     <artifactId>sikulixapi</artifactId>\n     <version>1.1.2</version>\n  </dependency>\n  ~~~\n\n  \n\n## 二、快速上手\n\n### 1、开启浏览器\n\n~~~java\n// 浏览器图标自行截图 存放至制定目录\ntry {\n   Pattern pattern = new Pattern(\"浏览器图标图片路径\");\n   Screen screen = new Screen();\n   screen.click(pattern);\n} catch (Exception e) {\n\te.printStackTrace();\n}\n~~~\n\n\n\n### 2、访问百度\n\n~~~java\nPattern pattern = new Pattern(\"浏览器地址栏图片路径\");\nScreen screen = new Screen();\nscreen.click(pattern);\nscreen.paste(\"浏览器地址栏图片路径\",\"www.baidu.com\");\n~~~\n\n\n\n## 三、进阶使用\n\n>sikulix参考文档：http://doc.sikuli.org/region.html#Region.text\n\n### 1、文本框输入中文\n\n~~~java\nPattern pattern = new Pattern(\"输入框图片路径\");\nScreen screen = new Screen();\nscreen.click(pattern);\nscreen.paste(\"输入框图片路径\",要输入的文本); // 方法一\nscreen.type(\"输入框图片路径\"，要输入的文本)； // 方法二\n~~~\n\n<span style=\"color:red;\">注：使用screen类输入文本的两种方法，type存在文本长度的问题，而paste方法没有此类问题</span>","timestamp":1618132041402},{"name":"01-selenium初探.md","path":"02-java篇/03-第三方/04-selenium/01-selenium初探.md","content":"# selenium初探\n\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2020年12月19日18:47:54</span>\n\n## 一、第三方依赖\n\n### 1、maven依赖坐标\n\n~~~xml\n<!-- selenium 的java api ：版本按需选择 -->\n<dependency>\n    <groupId>org.seleniumhq.selenium</groupId>\n    <artifactId>selenium-java</artifactId>\n    <version>3.4.0</version>\n</dependency>\n~~~\n\n\n\n### 2、浏览器驱动\n\n> 当selenium升级到3.0之后，对不同的浏览器驱动进行了规范。如果想使用selenium驱动不同的浏览器，必须单独下载并设置不同的浏览器驱动。\n\n* 各浏览器驱动\n\n  Firefox浏览器驱动：[geckodriver](https://github.com/mozilla/geckodriver/releases) </br>\n  Chrome浏览器驱动：[chromedriver](https://sites.google.com/a/chromium.org/chromedriver/home)[taobao备用地址 </br>](https://npm.taobao.org/mirrors/chromedriver)\n  IE浏览器驱动：[IEDriverServer](http://selenium-release.storage.googleapis.com/index.html) </br>\n  Edge浏览器驱动：[MicrosoftWebDriver](https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/) </br>\n  Opera浏览器驱动：[operadriver](https://github.com/operasoftware/operachromiumdriver/releases) </br>\n  PhantomJS浏览器驱动：[phantomjs](http://phantomjs.org/) </br>\n\n  <span style=\"color:red;\">注：部分浏览器驱动地址需要科学上网。</span>\n\n\n\n## 二、快速上手\n\n### 1、开启浏览器\n\n> 这里我们以谷歌浏览器为例（访问百度）\n\n~~~java\n// 设置浏览器驱动程序位置\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \n\n// 开启一个谷歌浏览器\nWebDriver webDriver = new ChromeDriver();\n\n// 窗口最大化\nwebDriver.manage().window().maximize();\n\n// 访问百度\nwebDriver.get(\"https://www.baidu.com\")\n~~~\n\n","timestamp":1618132041402},{"name":"02-selenium进阶.md","path":"02-java篇/03-第三方/04-selenium/02-selenium进阶.md","content":"# selenium进阶\n\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2020年12月19日 19:48:17</span>\n\n## 一、元素定位\n\n### 1、定位方法\n\n<span style=\"color:#FF531A;font-weight:bold;\">id:</span><span style=\"color:#42B983;font-weight:bold;\">    findElement(By.id())</span></br>\n<span style=\"color:#FF531A;font-weight:bold;\">name:</span><span style=\"color:#42B983;font-weight:bold;\">    findElement(By.name())</span></br>\n<span style=\"color:#FF531A;font-weight:bold;\">class name:</span> <span style=\"color:#42B983;font-weight:bold;\">   findElement(By.className())</span></br>\n<span style=\"color:#FF531A;font-weight:bold;\">tag name: </span> <span style=\"color:#42B983;font-weight:bold;\">  findElement(By.tagName())</span></br>\n<span style=\"color:#FF531A;font-weight:bold;\">link text:</span><span style=\"color:#42B983;font-weight:bold;\">    findElement(By.linkText())</span></br>\n<span style=\"color:#FF531A;font-weight:bold;\">partial link text:</span><span style=\"color:#42B983;font-weight:bold;\">    findElement(By.partialLinkText())</span></br>\n<span style=\"color:#FF531A;font-weight:bold;\">xpath:</span><span style=\"color:#42B983;font-weight:bold;\">    findElement(By.xpath())</span></br>\n<span style=\"color:#FF531A;font-weight:bold;\">css selector:</span> <span style=\"color:#42B983;font-weight:bold;\">   findElement(By.cssSelector())</span></br>\n\n### 2、定位方法用法\n\n~~~html\n<html>\n  <head>\n  <body link=\"#0000cc\">\n    <a id=\"result_logo\" href=\"/\" onmousedown=\"return c({\'fm\':\'tab\',\'tab\':\'logo\'})\">\n    <form id=\"form\" class=\"fm\" name=\"f\" action=\"/s\">\n      <span class=\"soutu-btn\"></span>\n        <input id=\"kw\" class=\"s_ipt\" name=\"wd\" value=\"\" maxlength=\"255\" autocomplete=\"off\">\n~~~\n\n#### <span style=\"color:red;\">Q1:我们的目的是要定位input标签的输入框。</span>\n\n- 通过id定位：\n\n  ```java\n  driver.findElement(By.id(\"kw\"))\n  ```\n\n- 通过name定位：\n\n  ```java\n  driver.findElement(By.name(\"wd\"))\n  ```\n\n- 通过class name定位：\n\n  ```java\n  driver.findElement(By.className(\"s_ipt\"))\n  ```\n\n- 通过tag name定位：\n\n  ```java\n  driver.findElement(By.tagName(\"input\"))\n  ```\n\n- 通过xpath定位，xpath定位有N种写法，这里列几个常用写法：\n\n  ```java\n  driver.findElement(By.xpath(\"//*[@id=\'kw\']\"))\n  driver.findElement(By.xpath(\"//*[@name=\'wd\']\"))\n  driver.findElement(By.xpath(\"//input[@class=\'s_ipt\']\"))\n  driver.findElement(By.xpath(\"/html/body/form/span/input\"))\n  driver.findElement(By.xpath(\"//span[@class=\'soutu-btn\']/input\"))\n  driver.findElement(By.xpath(\"//form[@id=\'form\']/span/input\"))\n  driver.findElement(By.xpath(\"//input[@id=\'kw\' and @name=\'wd\']\"))\n  ```\n\n- 通过css定位，css定位有N种写法，这里列几个常用写法：\n\n  ```java\n  driver.findElement(By.cssSelector(\"#kw\")\n  driver.findElement(By.cssSelector(\"[name=wd]\")\n  driver.findElement(By.cssSelector(\".s_ipt\")\n  driver.findElement(By.cssSelector(\"html > body > form > span > input\")\n  driver.findElement(By.cssSelector(\"span.soutu-btn> input#kw\")\n  driver.findElement(By.cssSelector(\"form#form > span > input\")\n  ```\n\n#### <span style=\"color:red;\">Q2:我们的页面上有一组文本链接。</span>\n\n```java\n<a class=\"mnav\" href=\"http://news.baidu.com\" name=\"tj_trnews\">新闻</a>\n<a class=\"mnav\" href=\"http://www.hao123.com\" name=\"tj_trhao123\">hao123</a>\n```\n\n- 通过link text定位：\n\n  ```java\n  driver.findElement(By.linkText(\"新闻\")\n  driver.findElement(By.linkText(\"hao123\")\n  ```\n\n- 通过partialLink text定位：\n\n  ```java\n  driver.findElement(By.partialLinkText(\"新\")\n  driver.findElement(By.partialLinkText(\"hao\")\n  driver.findElement(By.partialLinkText(\"123\")\n  ```\n\n关于xpaht和css的定位比较复杂，请参考：[ xpath语法](http://www.w3school.com.cn/xpath/xpath_syntax.asp)、[css选择器](http://www.w3school.com.cn/cssref/css_selectors.asp)\n\n#### <span style=\"color:red;\">Q3:定位一组元素</span>\n\n~~~java\nWebDriver driver = new ChromeDriver();\ndriver.get(\"https://www.baidu.com/\");\n\nWebElement search_text = driver.findElement(By.id(\"kw\"));\nsearch_text.sendKeys(\"selenium\");\nsearch_text.submit();\nThread.sleep(2000);\n\n//匹配第一页搜索结果的标题， 循环打印\nList<WebElement> search_result = driver.findElements(By.xpath(\"//div/div/h3\"));\n\n//打印元素的个数\nSystem.out.println(search_result.size());\n\n// 循环打印搜索结果的标题\nfor(WebElement result : search_result){\n    System.out.println(result.getText());\n}\n\nSystem.out.println(\"-------我是分割线---------\");\n\n//打印第n结果的标题\nWebElement text = search_result.get(search_result.size() - 10);\nSystem.out.println(text.getText());\n\ndriver.quit();\n~~~\n\n\n\n## 二、控制浏览器窗口\n\n### 1、浏览器窗口大小\n\n>- maximize() 设置浏览器最大化\n>- setSize() 设置浏览器宽高\n\n~~~java\n// 设置浏览器驱动程序位置\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \n\n// 开启浏览器 访问pc版百度\nWebDriver driver= new ChromeDriver();\ndriver.get(\"https://www.baidu.cn\");\n \n// 设置窗口最大话\ndriver.manage().window().maximize();\nThread.sleep(2000);\n \n// 访问移动版百度，自定义窗口大小\ndriver.get(\"https://m.baidu.cn\");\ndriver.manage().window().setSize(new Dimension(480, 800));\nThread.sleep(2000);\n \n// 关闭浏览器（注：这种有时候会关不掉）\ndriver.quit();\n~~~\n\n\n\n### 2、浏览器前进后退\n\n~~~java\n// 设置浏览器驱动程序位置 & 开启浏览器\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \nWebDriver driver = new ChromeDriver();\n \n//get 到百度首页\ndriver.get(\"https://www.baidu.com/\");\nSystem.out.printf(\"now accesss %s \\n\", driver.getCurrentUrl());\nThread.sleep(2000);\n\n//点击“新闻” 链接\ndriver.findElement(By.linkText(\"新闻\")).click();\nSystem.out.printf(\"now accesss %s \\n\", driver.getCurrentUrl());\nThread.sleep(2000);\n\n//执行浏览器后退\ndriver.navigate().back();\nSystem.out.printf(\"back to %s \\n\", driver.getCurrentUrl());\nThread.sleep(2000);\n\n//执行浏览器前面\ndriver.navigate().forward();\nSystem.out.printf(\"forward to %s \\n\", driver.getCurrentUrl());\nThread.sleep(2000);\n\ndriver.quit();\n~~~\n\n### 3、刷新页面\n\n> refresh() 刷新页面（F5）\n\n~~~java\n……\n// 刷新页面\ndriver.navigate().refresh();\n……\n~~~\n\n## 三、webDriver常用方法\n\n### 1、常用方法\n\n> - clear() 清除文本。\n> - sendKeys(*value) 模拟按键输入。\n> - click() 单击元素\n\n~~~java\n// 设置浏览器驱动程序位置 & 开启浏览器\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \nWebDriver driver = new ChromeDriver();\ndriver.get(\"https://www.baidu.com/\");\n\n// 获取目标元素\nWebElement search_text = driver.findElement(By.id(\"kw\"));\nWebElement search_button = driver.findElement(By.id(\"su\"));\n\n// clear & sendKeys & click\nsearch_text.sendKeys(\"Java\");\nsearch_text.clear();\nsearch_text.sendKeys(\"Selenium\");\nsearch_button.click();\n\ndriver.quit();\n~~~\n\n### 2、其他方法\n\n> submit()\n\n~~~java\n……\nWebElement search_text = driver.findElement(By.id(\"kw\"));\nsearch_text.sendKeys(\"Selenium\");\nsearch_text.submit();// 模拟执行提交\n……\n~~~\n\n> - getSize() 返回元素的尺寸。\n> - getText() 获取元素的文本。\n> - getAttribute(name) 获得属性值。\n> - isDisplayed() 设置该元素是否用户可见。\n\n~~~java\n// 设置浏览器驱动程序位置 & 开启浏览器\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \nWebDriver driver = new ChromeDriver();\ndriver.get(\"https://www.baidu.com/\");\n\n//获得百度输入框的尺寸\nWebElement size = driver.findElement(By.id(\"kw\"));\nSystem.out.println(size.getSize());\n\n//返回百度页面底部备案信息\nWebElement text = driver.findElement(By.id(\"cp\"));\nSystem.out.println(text.getText());\n\n//返回元素的属性值， 可以是 id、 name、 type 或元素拥有的其它任意属性\nWebElement ty = driver.findElement(By.id(\"kw\"));\nSystem.out.println(ty.getAttribute(\"type\"));\n\n//返回元素的结果是否可见， 返回结果为 True 或 False\nWebElement display = driver.findElement(By.id(\"kw\"));\nSystem.out.println(display.isDisplayed());\n\ndriver.quit();\n~~~\n\n## 四、鼠标操作\n\n> - contextClick() 右击\n> - clickAndHold() 鼠标点击并控制\n> - doubleClick() 双击\n> - dragAndDrop() 拖动\n> - release() 释放鼠标\n> - perform() 执行所有Actions中存储的行为\n\n### 1、悬停显示下拉菜单\n\n~~~java\n// 设置浏览器驱动程序位置 & 开启浏览器\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \nWebDriver driver = new ChromeDriver();\ndriver.get(\"https://www.baidu.com/\");\n\nWebElement search_setting = driver.findElement(By.linkText(\"设置\"));\nActions action = new Actions(driver);\naction.clickAndHold(search_setting).perform();\n\ndriver.quit();\n~~~\n\n\n\n### 2、鼠标其他操作\n\n~~~java\n......\nActions action = new Actions(driver);\n \n// 鼠标右键点击指定的元素\naction.contextClick(driver.findElement(By.id(\"element\"))).perform();\n \n// 鼠标右键点击指定的元素\naction.doubleClick(driver.findElement(By.id(\"element\"))).perform();\n \n// 鼠标拖拽动作， 将 source 元素拖放到 target 元素的位置。\nWebElement source = driver.findElement(By.name(\"element\"));\nWebElement target = driver.findElement(By.name(\"element\"));\naction.dragAndDrop(source,target).perform();\n \n// 释放鼠标\naction.release().perform();\n......\n~~~\n\n## 五、键盘操作\n\n> sendKeys(Keys.BACK_SPACE) 回格键（BackSpace）\n> sendKeys(Keys.SPACE) 空格键(Space)\n> sendKeys(Keys.TAB) 制表键(Tab)\n> sendKeys(Keys.ESCAPE) 回退键（Esc）\n> sendKeys(Keys.ENTER) 回车键（Enter）\n> sendKeys(Keys.CONTROL,‘a’) 全选（Ctrl+A）\n> sendKeys(Keys.CONTROL,‘c’) 复制（Ctrl+C）\n> sendKeys(Keys.CONTROL,‘x’) 剪切（Ctrl+X）\n> sendKeys(Keys.CONTROL,‘v’) 粘贴（Ctrl+V）\n> sendKeys(Keys.F1) 键盘 F1\n> ……\n\n### 1、模拟键盘操作\n\n~~~java\n// 设置浏览器驱动程序位置 & 开启浏览器\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \nWebDriver driver = new ChromeDriver();\ndriver.get(\"https://www.baidu.com\");\n\nWebElement input = driver.findElement(By.id(\"kw\"));\n\n//输入框输入内容\ninput.sendKeys(\"seleniumm\");\nThread.sleep(2000);\n\n//删除多输入的一个 m\ninput.sendKeys(Keys.BACK_SPACE);\nThread.sleep(2000);\n\n//输入空格键+“教程”\ninput.sendKeys(Keys.SPACE);\ninput.sendKeys(\"教程\");\nThread.sleep(2000);\n\n//ctrl+a 全选输入框内容\ninput.sendKeys(Keys.CONTROL,\"a\");\nThread.sleep(2000);\n\n//ctrl+x 剪切输入框内容\ninput.sendKeys(Keys.CONTROL,\"x\");\nThread.sleep(2000);\n\n//ctrl+v 粘贴内容到输入框\ninput.sendKeys(Keys.CONTROL,\"v\");\nThread.sleep(2000);\n\n//通过回车键盘来代替点击操作\ninput.sendKeys(Keys.ENTER);\nThread.sleep(2000);\n\ndriver.quit();\n~~~\n\n## 六、元素等待\n\n> WebDriver提供了两种类型的等待：<span style=\"color:#42B983;font-weight:bold;\">显式等待</span> 和 <span style=\"color:#42B983;font-weight:bold;\">隐式等待</span>。\n\n### 1、显示等待\n\n~~~java\n// 设置浏览器驱动程序位置 & 开启浏览器\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \nWebDriver driver = new ChromeDriver();\ndriver.get(\"https://www.baidu.com\");\n\n//显式等待， 针对某个元素等待\nWebDriverWait wait = new WebDriverWait(driver,10,1);\n\nwait.until(new ExpectedCondition<WebElement>(){\n    @Override\n    public WebElement apply(WebDriver text) {\n        return text.findElement(By.id(\"kw\"));\n    }\n}).sendKeys(\"selenium\");\n\ndriver.findElement(By.id(\"su\")).click();\nThread.sleep(2000);\n\ndriver.quit();\n~~~\n\n\n\n### 2、隐式等待\n\n~~~java\n// 设置浏览器驱动程序位置 & 开启浏览器\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \nWebDriver driver = new ChromeDriver();\n\n//页面加载超时时间设置为 5s\ndriver.manage().timeouts().pageLoadTimeout(5, TimeUnit.SECONDS);\ndriver.get(\"https://www.baidu.com/\");\n\n//定位对象时给 10s 的时间, 如果 10s 内还定位不到则抛出异常\ndriver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);\ndriver.findElement(By.id(\"kw\")).sendKeys(\"selenium\");\n\n//异步脚本的超时时间设置成 3s\ndriver.manage().timeouts().setScriptTimeout(3, TimeUnit.SECONDS);\n\ndriver.quit();\n\n~~~\n\n## 七、多表单切换\n\n> 在 Web 应用中经常会遇到 frame/iframe 表单嵌套页面的应用， WebDriver 只能在一个页面上对元素识别与 定位， 对于 frame/iframe 表单内嵌页面上的元素无法直接定位。 这时就需要通过 switchTo().frame()方法将当前定 位的主体切换为 frame/iframe 表单的内嵌页面中。\n\n~~~html\n<html>\n  <body>\n    ...\n    <iframe id=\"x-URS-iframe\" ...>\n      <html>\n         <body>\n           ...\n           <input name=\"email\" >\n~~~\n\n> 126邮箱登录框的结构大概是这样子的，想要操作登录框必须要先切换到iframe表单。\n\n~~~java\n// 设置浏览器驱动程序位置 & 开启浏览器\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \nWebDriver driver = new ChromeDriver();\ndriver.get(\"http://www.126.com\");\n\nWebElement xf = driver.findElement(By.xpath(\"//*[@id=\'loginDiv\']/iframe\"));\ndriver.switchTo().frame(xf);\ndriver.findElement(By.name(\"email\")).clear();\ndriver.findElement(By.name(\"email\")).sendKeys(\"username\");\ndriver.findElement(By.name(\"password\")).clear();\ndriver.findElement(By.name(\"password\")).sendKeys(\"password\");\ndriver.findElement(By.id(\"dologin\")).click();\ndriver.switchTo().defaultContent();\n//……\n~~~\n\n<span style=\"color:red;\">注:如果完成了在当前表单上的操作，则可以通过switchTo().defaultContent()方法跳出表单。</span>\n\n## 八、多窗口切换\n\n> - getWindowHandle()： 获得当前窗口句柄。\n> - getWindowHandles()： 返回的所有窗口的句柄到当前会话。\n> - switchTo().window()： 用于切换到相应的窗口，与上一节的switchTo().frame()类似，前者用于不同窗口的切换， 后者用于不同表单之间的切换。\n\n~~~java\n// 设置浏览器驱动程序位置 & 开启浏览器\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \nWebDriver driver = new ChromeDriver();\ndriver.get(\"https://www.baidu.com\");\n\n//获得当前窗口句柄\nString search_handle = driver.getWindowHandle();\n\n//打开百度注册窗口\ndriver.findElement(By.linkText(\"登录\")).click();\nThread.sleep(3000);\ndriver.findElement(By.linkText(\"立即注册\")).click();\n\n//获得所有窗口句柄\nSet<String> handles = driver.getWindowHandles();\n\n//判断是否为注册窗口， 并操作注册窗口上的元素\nfor(String handle : handles){\n    if (handle.equals(search_handle)==false){\n        //切换到注册页面\n        driver.switchTo().window(handle);\n        System.out.println(\"now register window!\");\n        Thread.sleep(2000);\n        driver.findElement(By.name(\"userName\")).clear();\n        driver.findElement(By.name(\"userName\")).sendKeys(\"user name\");\n        driver.findElement(By.name(\"phone\")).clear();\n        driver.findElement(By.name(\"phone\")).sendKeys(\"phone number\");\n        //......\n        Thread.sleep(2000);\n        //关闭当前窗口\n        driver.close();\n    }\n}\nThread.sleep(2000);\n\ndriver.quit();\n~~~\n\n## 九、下拉框选择\n\n> 有时我们会碰到下拉框，WebDriver提供了Select类来处理下接框。\n\n* html 代码\n\n  ~~~java\n  <select id=\"nr\" name=\"NR\">\n    <option value=\"10\" selected>每页显示 10 条</option>\n    <option value=\"20\">每页显示 20 条</option>\n    <option value=\"50\">每页显示 50 条</option>\n  <select>\n  ~~~\n\n* java代码\n\n  ~~~java\n  // 设置浏览器驱动程序位置 & 开启浏览器\n  System.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \n  WebDriver driver = new ChromeDriver();\n  driver.get(\"https://www.baidu.com\");\n  \n  driver.findElement(By.linkText(\"设置\")).click();\n  driver.findElement(By.linkText(\"搜索设置\")).click();\n  Thread.sleep(2000);\n  \n  //<select>标签的下拉框选择\n  WebElement el = driver.findElement(By.xpath(\"//select\"));\n  Select sel = new Select(el);\n  sel.selectByValue(\"20\");\n  Thread.sleep(2000);\n  \n  driver.quit();\n  ~~~\n\n  \n\n## 十、警告框处理\n\n> - getText()： 返回 alert/confirm/prompt 中的文字信息。\n> - accept()： 接受现有警告框。\n> - dismiss()： 解散现有警告框。\n> - sendKeys(keysToSend)： 发送文本至警告框。\n> - keysToSend： 将文本发送至警告框。\n\n~~~java\n// 设置浏览器驱动程序位置 & 开启浏览器\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \nWebDriver driver = new ChromeDriver();\ndriver.get(\"https://www.baidu.com\");\n\ndriver.findElement(By.linkText(\"设置\")).click();\ndriver.findElement(By.linkText(\"搜索设置\")).click();\nThread.sleep(2000);\n\n//保存设置\ndriver.findElement(By.className(\"prefpanelgo\")).click();\n\n//接收弹窗\ndriver.switchTo().alert().accept();\nThread.sleep(2000);\n\ndriver.quit();\n~~~\n\n\n\n\n\n## 十一、Cookies操作\n\n> - getCookies() 获得所有 cookie 信息。\n> - getCookieNamed(String name) 返回字典的key为“name”的Cookie信息。\n> - addCookie(cookie dict) 添加Cookie。“cookie_dict”指字典对象，必须有 name和value值。\n> - deleteCookieNamed(String name) 删除Cookie 信息。 “name”是要删除的 cookie的名称； “optionsString” 是该Cookie的选项，目前支持的选项包括“路径” ， “域” 。\n> - deleteAllCookies() 删除所有 cookie 信息\n\n~~~java\n// 设置浏览器驱动程序位置 & 开启浏览器\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \nWebDriver driver = new ChromeDriver();\ndriver.get(\"https://www.baidu.com\");\n\nCookie c1 = new Cookie(\"name\", \"key-aaaaaaa\");\nCookie c2 = new Cookie(\"value\", \"value-bbbbbb\");\ndriver.manage().addCookie(c1);\ndriver.manage().addCookie(c2);\n\n//获得 cookie\nSet<Cookie> coo = driver.manage().getCookies();\nSystem.out.println(coo);\n\n//删除所有 cookie\n//driver.manage().deleteAllCookies();\n\ndriver.quit();\n\n~~~\n\n\n\n## 十二、执行js\n\n>window.scrollTo()方法用于设置浏览器窗口滚动条的水平和垂直位置。方法的第一个参数表示水平的左间距，第二个参数表示垂直的上边距\n\n~~~java\n// 设置浏览器驱动程序位置 & 开启浏览器\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \nWebDriver driver = new ChromeDriver();\n\n//设置浏览器窗口大小\ndriver.manage().window().setSize(new Dimension(700, 600));\ndriver.get(\"https://www.baidu.com\");\n\n//进行百度搜索\ndriver.findElement(By.id(\"kw\")).sendKeys(\"webdriver api\");\ndriver.findElement(By.id(\"su\")).click();\nThread.sleep(2000);\n\n//将页面滚动条拖到底部\n((JavascriptExecutor)driver).executeScript(\"window.scrollTo(100,450);\");\nThread.sleep(3000);\n\ndriver.quit();\n~~~\n\n\n\n## 小进阶\n\n### 1、页面缩放\n\n~~~java\nJavascriptExecutor js = (JavascriptExecutor) driver;\njs.executeScript(\"document.body.style.zoom = \'30%\'\");\n// 或\n((JavascriptExecutor)driver).executeScript(\"document.body.style.zoom =\'70%\'\");\n~~~\n\n### 2、强制杀死浏览器及驱动程序\n\n~~~java\nWindowsUtils.killByName(\"chrome.exe\");\nWindowsUtils.killByName(\"firefox.exe\");\nWindowsUtils.killByName(\"chromedriver.exe\");\nWindowsUtils.killByName(\"geckodriver.exe\");\n// 注：由于selenium的版本问题 可能会存在方法名不一样情况\n~~~\n\n### 3、获取新窗口关闭原窗口\n\n~~~java\nString currentHand = driver.getWindowHandle();\nfor(String hand : driver.getWindowHandles()){\n    if(!currentHand.equals(hand)){\n        driver.close();\n        driver.switchTo().window(hand);\n        break;\n    }\n}\n~~~\n\n### 4、selenium获取验证码图片\n\n~~~java\nSystem.setProperty(\"webdriver.chrome.driver\",\"C:/chromedriver.exe\");\nWebDriver driver = new ChromeDriver();\ndriver.manage().window().maximize();\ndriver.get(\"https://agent.lionairthai.com/B2BAdmin/Login.aspx?CU=207&culture=en-GB\");\n\nWebElement ele = driver.findElement(By.id(\"ucAgentLogin_rdCapImage_CaptchaImageUP\"));\nWrapsDriver wrapsDriver = (WrapsDriver) ele;\nFile screenshot = ((TakesScreenshot)wrapsDriver.getWrappedDriver()).getScreenshotAs(OutputType.FILE);\nBufferedImage fullImg=ImageIO.read(screenshot);\nint screenshotWidth = fullImg.getWidth();\nDimension dimension = driver.manage().window().getSize();\ndouble scale = (double) dimension.getWidth() / screenshotWidth;\nPoint point= ele.getLocation();\nint eleWidth= ele.getSize().getWidth()+10;\nint eleHeight= ele.getSize().getHeight()+10;\nBufferedImage eleScreenshot= fullImg.getSubimage((int)(point.getX() / scale),(int)(point.getY() / scale), (int)(eleWidth / scale), (int)(eleHeight / scale));\nImageIO.write(eleScreenshot, \"jpg\", screenshot);\nFile screenshotLocation= new File(\"D:\\\\tmp\\\\test.jpg\");\nFileUtils.copyFile(screenshot, screenshotLocation);\ndriver.quit();\n~~~\n\n","timestamp":1618132041402}]