if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m02']=[{"name":"01-设计模式总述.md","path":"02-java篇/02-技术栈/01-设计模式/01-设计模式总述.md","content":"# 设计模式总述\r\n\r\n> 设计模式总体来说分为三大类：<span style=\"color:#42B983;font-weight:bold;\">创建型、结构型 和 行为型</span></br>\r\n>\r\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2020年12月16日19:45:40</span>\r\n\r\n## 一、设计模式分类\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">创建型模式</span>\r\n共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">结构型模式</span>\r\n共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">行为型模式</span>\r\n共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。\r\n\r\n其实还有两类：<span style=\"color:#FF531A;font-weight:bold;\">并发型模式</span> 和 <span style=\"color:#FF531A;font-weight:bold;\">线程池模式</span>。\r\n\r\n## 二、设计模式遵循原则\r\n\r\n> 设计模式的    <span style=\"color:#42B983;font-weight:bold;\">六大原则</span>\r\n\r\n### 总原则：开闭原则\r\n\r\n> **开闭原则**：即 <span style=\"color:#42B983;font-weight:bold;\">开放-封闭</span> 原则，软件实体可以扩展但不可修改。\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">个人理解：</span>\r\n\r\n**这个原则其实是有两个特征的：**\r\n\r\n* 一、对于扩展是开放的：</br>\r\n  设计程序实体不可能达到绝对的封闭，也不可能做到一次设计就能应对日后的变化</br>\r\n  所以需要在设计程序实体时就:<span style=\"color:#FF531A;font-weight:bold;\">考虑   到日后可能的变化，尽可能的抽象变化使程序实体能够被扩展。</span>\r\n\r\n* 二、对于更改是封闭的：</br>\r\n  就像在“一”中提到的，程序实体的设计是没有办法做的一次设计就应对日后所有的变换，</br>\r\n  在程序实体设计完成,开发工作也完成后，需求是会有变更或新增。</br>\r\n  而我们设计的程序实体在面对需求时：<span style=\"color:#FF531A;font-weight:bold;\">对程序实体的改动是通过新增代码\r\n  而不是更改现有的代码</span>\r\n\r\n\r\n\r\n### 1、单一职责原则\r\n\r\n> **单一职责原则：**就一个程序实体而言，<span style=\"color:#42B983;font-weight:bold;\">有且仅有</span> 一个引起它变化的原因\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">个人理解：</span>\r\n\r\n就设计过程中的一个类而言，应该仅有一个能引起它变化的原因；不要存在多余一个导致其发生变化的原因。</br>\r\n<span style=\"color:#FF531A;font-weight:bold;\">也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。</span>\r\n\r\n\r\n\r\n### 2、里氏替换原则\r\n\r\n> **里氏替换原则：**又称“**里氏代换原则**” <span style=\"color:#42B983;font-weight:bold;\">子类型</span> 必须能够替换掉  <span style=\"color:#42B983;font-weight:bold;\">它们的父类型</span>\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">百科阅读：</span>\r\n\r\n<span style=\"border-bottom: 2px solid #0081EF;\">**里氏代换原则(**Liskov Substitution Principle LSP)面向对象设计的基本原则之一。</span> </br>\r\n<span style=\"border-bottom: 2px solid #0081EF;\">里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。</span> </br>\r\n<span style=\"border-bottom: 2px solid #0081EF;\">LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，</span></br>\r\n<span style=\"border-bottom: 2px solid #0081EF;\">基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</span></br>\r\n<span style=\"border-bottom: 2px solid #0081EF;\">里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。</span></br>\r\n<span style=\"border-bottom: 2px solid #0081EF;\">而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</span>\r\n\r\n\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">个人理解：</span>\r\n\r\n一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它<span style=\"color:#FF531A;font-weight:bold;\">察觉不出父亲对象和子类对象的区别</span></br>\r\n<span style=\"color:#FF531A;font-weight:bold;\">也就是说：在软件实体中，把父类替换成它的子类，程序实体没有影响</span>\r\n\r\n\r\n\r\n### 3、依赖倒转原则\r\n\r\n> **依赖倒转原则：**\r\n> ​\t\tA、高层模块不应该依赖底层模块，两个都应该抽象依赖\r\n> ​\t\tB、抽象不应该依赖细节，细节已改依赖抽象\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">个人理解：</span>\r\n\r\n**这个是开闭原则的基础，具体内容：**</br>\r\n\r\n   <span style=\"color:#FF531A;font-weight:bold;\">面向接口编程，依赖于抽象而不依赖于具体。</span></br>\r\n\r\n   <span style=\"color:#FF531A;font-weight:bold;\">写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</span></br>\r\n\r\n\r\n\r\n### 4、接口隔离原则\r\n\r\n> **依赖倒转原则：**\r\n> 程序实体不应该依赖它不需要的接口。一个程序实体对另一个程序实体的依赖应该建立在最小的接口上。\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">个人理解：</span>\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。</span></br>\r\n使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。\r\n\r\n\r\n\r\n### 5、迪米特法则\r\n\r\n> **迪米特法则：**又称 **最少知识原则** 一个程序实体对另一个程序实体知道的<span style=\"color:#42B983;font-weight:bold;\"> 越少越好</span>\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">个人理解：</span>\r\n\r\n一个类对自己依赖的类知道的越少越好。<br>\r\n也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。</br>\r\n这样当被依赖的类变化时，才能最小的影响该类。</br>\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用</span></br>\r\n<span style=\"color:#FF531A;font-weight:bold;\">如果其中一个程序实体需要调用另外一个程序实体，可以通过第三者转发这个调用</span></br>\r\n\r\n<span style=\"border-bottom: 2px solid #42B983;\">**最少知道原则** 的另一个表达方式是：只与直接的朋友通信。</span></br>\r\n<span style=\"border-bottom: 2px solid #42B983;\">类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。</span></br>\r\n<span style=\"border-bottom: 2px solid #42B983;\">我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。</span></br>\r\n<span style=\"border-bottom: 2px solid #42B983;\">我们要求陌生的类不要作为局部变量出现在类中。</span></br>\r\n\r\n\r\n\r\n### 6、合成复用原则\r\n\r\n> **合成复用原则：**尽量使用<span style=\"color:#42B983;font-weight:bold;\">   合成/聚合</span>，尽量不要使用<span style=\"color:#42B983;font-weight:bold;\">   类继承</span>\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">个人理解：</span>\r\n\r\n* **聚合**</br>\r\n\r\n  聚合表示一种弱的“拥有”关系，体现的是<span style=\"color:#FF531A;font-weight:bold;\">A对象可以包含B对象</span>，但是<span style=\"color:#FF531A;font-weight:bold;\">B对象不是A对象的一部分</span>\r\n\r\n* **合成**  </br>\r\n\r\n  合成则是一种强的“拥有”关系，体现了<span style=\"color:#FF531A;font-weight:bold;\">严格的部分和整体的关系，部分和整体的生命周期一样</span>\r\n","timestamp":1642514536573},{"name":"01-工厂方法模式.md","path":"02-java篇/02-技术栈/01-设计模式/02-创建型/01-工厂方法模式.md","content":"# 工厂方法模式\r\n\r\n> 前置：<span style=\"color:#42B983;font-weight:bold;\">工厂方法模式</span> 之前我们先来解读以下 <span style=\"color:#FF531A;font-weight:bold;\">简单工厂模式</span></br>\r\n>\r\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2020年12月20日10:46:06</span>\r\n\r\n## 一、简单工厂模式\r\n\r\n### 1、模式类图\r\n\r\n![image-20201220101334913](amWiki/images/lib_img/image-20201220101334913.png \"简单工厂模式类图\")\r\n\r\n### 2、简单工厂解读\r\n\r\n#### a、_Algorithm(inf : 产品规则)\r\n\r\n><span style=\"color:#42B983;font-weight:bold;\">规则制定</span>：规定产品的规格(例：算法要实现什么功能)\r\n\r\n~~~java\r\npublic interface _Algorithm {\r\n\r\n    // 产品规格：计算\r\n\tpublic void calc(int num1,int num2);\r\n\r\n}\r\n~~~\r\n\r\n\r\n\r\n#### b、_XXXAlgorithm(class：具体产品)\r\n\r\n> <span style=\"color:#42B983;font-weight:bold;\">具体的产品</span>：产品在满足产品规格情况下的具体细节(加法算法、减法算法 or 乘法算法...)我们以加法为例\r\n\r\n~~~java\r\npublic class _AddAlgorithm implements _Algorithm {\r\n\r\n    // 具体产品：时间 num1 和 num2 的求和\r\n\tpublic void calc(int num1,int num2) {\r\n\t\tSoutUtil.soutObject(num1 + \"+\" + num2 + \"=\" + (num1 + num2));\r\n\t}\r\n\r\n}\r\n~~~\r\n\r\n\r\n\r\n#### c、_AlgorithmFactory(class：产品工厂)\r\n\r\n> <span style=\"color:#42B983;font-weight:bold;\">产品工厂</span>：按照客户的需求生产具体的产品（生成 加法算法、减法算法。。。产品）\r\n\r\n~~~java\r\npublic class _AlgorithmFactory {\r\n\r\n    // 算法标识\r\n\tpublic static final String ALG_MARK_ADD = \"+\";\r\n\tpublic static final String ALG_MARK_SUB = \"-\";\r\n\tpublic static final String ALG_MARK_MUL = \"*\";\r\n\tpublic static final String ALG_MARK_DIV = \"/\";\r\n\r\n\t// 依据客户端的算法请求，生产对应的算法产品\r\n\tpublic _Algorithm produceAlgorithm(String algMark) {\r\n\t\t_Algorithm target = null;\r\n\t\tswitch (algMark) {\r\n\t\t\tcase ALG_MARK_ADD :\r\n\t\t\t\ttarget = new _AddAlgorithm(); break;\r\n\t\t\tcase ALG_MARK_SUB :\r\n\t\t\t\ttarget = new _SubAlgorithm(); break;\r\n\t\t\tcase ALG_MARK_MUL :\r\n\t\t\t\ttarget = new _MulAlgorithm(); break;\r\n\t\t\tcase ALG_MARK_DIV :\r\n\t\t\t\ttarget = new _DivAlgorithm(); break;\r\n\t\t}\r\n\t\treturn target;\r\n\t}\r\n}\r\n~~~\r\n\r\n#### d、test\r\n\r\n~~~java\r\n/**\r\n *  简单工厂模式\r\n */\r\n@Test\r\npublic void simpleFactoryPattern() {\r\n    SoutUtil.soutFrame(\"*\", Constant.SOUT_FRAME_START);\r\n    int a = 10,b = 5;\r\n    // 简单算法工厂\r\n    _AlgorithmFactory factory = new _AlgorithmFactory();\r\n\r\n    _Algorithm add = factory.produceAlgorithm(factory.ALG_MARK_ADD);\r\n    add.calc(a, b);\r\n\r\n    _Algorithm sub = factory.produceAlgorithm(factory.ALG_MARK_SUB);\r\n    sub.calc(a, b);\r\n\r\n    _Algorithm mul = factory.produceAlgorithm(factory.ALG_MARK_MUL);\r\n    mul.calc(a, b);\r\n\r\n    _Algorithm div = factory.produceAlgorithm(factory.ALG_MARK_DIV);\r\n    div.calc(a, b);\r\n\r\n    SoutUtil.soutFrame(\"*\", Constant.SOUT_FRAME_END);\r\n}\r\n~~~\r\n\r\n\r\n\r\n## 二、工厂方法模式\r\n\r\n### 1、模式类图\r\n\r\n![image-20201220111836726](amWiki/images/lib_img/image-20201220111836726.png \"工厂方法模式类图\")\r\n\r\n### 2、工厂方法解读\r\n\r\n#### a、Algorithm(inf：产品规则)\r\n\r\n> <span style=\"color:#42B983;font-weight:bold;\">规则制定</span>：规定产品的规格(例：算法要实现什么功能)\r\n\r\n~~~java\r\npublic interface Algorithm {\r\n\t// 产品的规格\r\n\tpublic void calc(int num1,int num2);\r\n\r\n}\r\n~~~\r\n\r\n\r\n\r\n#### b、xxxAlgorithm(class：具体产品)\r\n\r\n> <span style=\"color:#42B983;font-weight:bold;\">具体的产品</span>：产品在满足产品规格情况下的具体细节(加法算法、减法算法 or 乘法算法...)我们以加法为例\r\n\r\n~~~java\r\npublic class AddAlgorithm implements Algorithm {\r\n\r\n    // 产品的具体细节\r\n\t@Override\r\n\tpublic void calc(int num1, int num2) {\r\n\t\tSoutUtil.soutObject(num1 + \"+\" + num2 + \"=\" + (num1 + num2));\t\t\r\n\t}\r\n\r\n\r\n}\r\n~~~\r\n\r\n\r\n\r\n#### c、IFactory(inf：工厂标准)\r\n\r\n> <span style=\"color:#42B983;font-weight:bold;\">工厂标准</span>：制定产品供应商的生产标准\r\n\r\n~~~java\r\npublic interface IFactory {\r\n    // 工厂的生产标准\r\n\tpublic Algorithm produceAlgorithm();\r\n}\r\n~~~\r\n\r\n\r\n\r\n#### d、xxxFactory(class：产品供应商-工厂)\r\n\r\n> <span style=\"color:#42B983;font-weight:bold;\">产品供应商</span>：在满足产品供应商标准的情况下生产产品\r\n\r\n~~~java\r\npublic class AddFactory implements IFactory {\r\n\t// 供应商生产产品的具体细节\r\n\t@Override\r\n\tpublic Algorithm produceAlgorithm() {\r\n\t\treturn new AddAlgorithm();\r\n\t}\r\n\r\n}\r\n~~~\r\n\r\n#### f、test\r\n\r\n~~~java\r\n/**\r\n * 工厂方法模式\r\n */\r\n@Test\r\npublic void factoryFunctionPattern() {\r\n    SoutUtil.soutFrame(\"*\", Constant.SOUT_FRAME_START);\r\n\r\n    int a = 10,b = 5;\r\n\r\n    // 加法供货商\r\n    IFactory addFactory = new AddFactory();\r\n    Algorithm add  = addFactory.produceAlgorithm();\r\n    add.calc(a, b);\r\n\r\n    IFactory subFactory = new SubFactory();\r\n    Algorithm sub  = subFactory.produceAlgorithm();\r\n    sub.calc(a, b);\r\n\r\n    IFactory mulFactory = new MulFactory();\r\n    Algorithm mul  = mulFactory.produceAlgorithm();\r\n    mul.calc(a, b);\r\n\r\n    IFactory divFactory = new DivFactory();\r\n    Algorithm div  = divFactory.produceAlgorithm();\r\n    div.calc(a, b);\r\n\r\n\r\n    SoutUtil.soutFrame(\"*\", Constant.SOUT_FRAME_END);\r\n}\r\n~~~\r\n\r\n\r\n\r\n## 三、综述\r\n\r\n### 1、简单工厂模式\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">简单工厂模式</span>   <span style=\"border-bottom: 2px solid #0081EF;\">的最大有点在于工厂类中包含了必要的逻辑判断</span></br>\r\n\r\n根据客户端的选择条件动态的实例化相关类，对于客户端来说，是去除了于具体产品的依赖\r\n\r\n### 2、工厂方法模式\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">工厂方法模式</span>    定义一个用于创建对象的接口，让子类决定实例化哪个类</br>\r\n\r\n<span style=\"border-bottom: 2px solid #0081EF;\">**工厂方法使一个类的实例化延迟到其子类**</span>\r\n\r\n\r\n\r\n## 四、附录\r\n\r\n### 1、工具类SoutUtil\r\n\r\n~~~java\r\npublic class SoutUtil {\r\n    /**\r\n     * 打印边框 行为\r\n     * @param flagBit  打印边框的样式 ：*、》、> 、+ 、= 、-\r\n     */\r\n    public static void soutFrame(String flagBit, String action){\r\n        int loopSize = Constant.SOUT_FRAME_START.equals(action) ? 120 : 122;\r\n        System.out.print(Constant.SOUT_FRAME_START.equals(action) \r\n             ? action : \">>\\n\" + action);\r\n        \r\n        for (int i = 0; i < loopSize; i++) {\r\n            System.out.print(flagBit);\r\n        }\r\n        System.out.println(Constant.SOUT_FRAME_START.equals(action) ? \"\\n>>\":\"\");\r\n    }\r\n\r\n\r\n    /**\r\n     * 格式化输出obj 依赖 soutFrame\r\n     * @param obj\r\n     */\r\n    public static void soutObject(Object obj){\r\n        System.out.println(\">>   \" + obj);\r\n    }\r\n}\r\n~~~\r\n","timestamp":1642514536573},{"name":"02-抽象工厂模式.md","path":"02-java篇/02-技术栈/01-设计模式/02-创建型/02-抽象工厂模式.md","content":"# 抽象工厂模式\r\n\r\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2020年12月20日14:42:14</span>\r\n\r\n## 一、模式类图\r\n\r\n![image-20201220144416892](amWiki/images/lib_img/image-20201220144416892.png \"抽象工厂模式类图\")\r\n\r\n\r\n\r\n## 二、抽象工厂解读\r\n\r\n### 1、AbstractFactory(abst：工厂抽象)\r\n\r\n> <span style=\"color:#42B983;font-weight:bold;\">工厂抽象</span>：包含所有产品的生产规格\r\n\r\n~~~java\r\npublic abstract class AbstractFactory {\r\n\r\n\t// 普通算法生产规格\r\n\tpublic abstract NormalAlgorithm produceNormalAlg();\r\n\t\r\n\t// 科学算法生产规格\r\n\tpublic abstract ScienceAlgorithm produceScienceAlg();\r\n\t\r\n}\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n### 2、NormalAlgorithmIFactory(class：normal工厂)\r\n\r\n><span style=\"color:#42B983;font-weight:bold;\">normal工厂</span>：normal产品的生产细节\r\n\r\n~~~java\r\npublic class NormalAlgorithmIFactory extends AbstractFactory {\r\n\r\n\t@Override\r\n\tpublic NormalAlgorithm produceNormalAlg() {\r\n\t\treturn new AddAlgorithm();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic ScienceAlgorithm produceScienceAlg() {\r\n\t\treturn null;\r\n\t}\r\n\r\n\t\r\n}\r\n~~~\r\n\r\n\r\n\r\n### 2.1、NorMalAlgorithm(inf：normal产品规则)\r\n\r\n> <span style=\"color:#42B983;font-weight:bold;\">normal产品规则</span>：normal的使用规格（api）\r\n\r\n~~~java\r\npublic interface NormalAlgorithm {\r\n\r\n\t// 普通算法：求两数之和\r\n\tpublic void calc(int num1,int num2);\r\n\t\r\n}\r\n~~~\r\n\r\n\r\n\r\n### 2.1.1、AddAlgorithm(class：add产品)\r\n\r\n> <span style=\"color:#42B983;font-weight:bold;\">add产品</span>：normal类产品的一种具体产品\r\n\r\n~~~java\r\npublic class AddAlgorithm implements NormalAlgorithm {\r\n\r\n\t// 普通算法具体实现：求和\r\n\t@Override\r\n\tpublic void calc(int num1, int num2) {\r\n\t\tSoutUtil.soutObject(num1 + \"+\" + num2 + \"=\" + (num1 + num2));\t\t\r\n\t}\r\n\r\n}\r\n~~~\r\n\r\n### -------\r\n\r\n### 3、ScienceAlgorithmIFactory(class：science工厂)\r\n\r\n> <span style=\"color:#42B983;font-weight:bold;\">science工厂</span>：science产品的生产细节\r\n\r\n~~~java\r\npublic class ScienceAlgorithmIFactory extends AbstractFactory {\r\n\r\n\t@Override\r\n\tpublic NormalAlgorithm produceNormalAlg() {\r\n\t\treturn null;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic ScienceAlgorithm produceScienceAlg() {\r\n\t\treturn new AbsAlgorithm();\r\n\t}\r\n\r\n}\r\n~~~\r\n\r\n\r\n\r\n### 3.1、ScienceAlgorithm(inf：science产品规则)\r\n\r\n> <span style=\"color:#42B983;font-weight:bold;\">science产品规则</span>：science的使用规格（api）\r\n\r\n~~~java\r\npublic interface ScienceAlgorithm {\r\n\r\n\t// 科学算法接口标准：求平方\r\n\tpublic void abs(int num);\r\n}\r\n\r\n~~~\r\n\r\n\r\n\r\n### 3.1.1、AbsAlgorithm(class：asb产品)\r\n\r\n> <span style=\"color:#42B983;font-weight:bold;\">asb产品</span>：science类产品的一种具体产品\r\n\r\n~~~java\r\npublic class AbsAlgorithm implements ScienceAlgorithm {\r\n\r\n\t// 科学算法具体实现：求方\r\n\t@Override\r\n\tpublic void abs(int num) {\r\n\t\tSoutUtil.soutObject(num + \"² =\" + (num * num));\t\t\r\n\t}\r\n\r\n}\r\n~~~\r\n\r\n### 4、test\r\n\r\n~~~java\r\n@Test\r\npublic void abstractFactoryPattern(){\r\n    SoutUtil.soutFrame(\"*\", Constant.SOUT_FRAME_START);\r\n\r\n    int a = 10,b = 5;\r\n\r\n    // 普通算法\r\n    AbstractFactory normalFactory = new NormalAlgorithmIFactory();\r\n    normalFactory.produceNormalAlg().calc(a, b);\r\n\r\n    // 科学算法\r\n    AbstractFactory scienceFactory = new ScienceAlgorithmIFactory();\r\n    scienceFactory.produceScienceAlg().abs(a);\r\n\r\n    SoutUtil.soutFrame(\"*\", Constant.SOUT_FRAME_END);\r\n}\r\n~~~\r\n\r\n\r\n\r\n## 三、综述\r\n\r\n### 1、简单说明\r\n\r\n​\ta、本例只对工厂进行了抽象，感兴趣的小伙伴可以自行对产品规格也进行抽象的定制化</br>\r\n\r\n​\tb、对于产品的实例化一律采用了new的方式，小伙伴们也可以用反射等高大上方式\r\n\r\n\r\n\r\n## 四、附录\r\n\r\n### 1、工具类SoutUtil\r\n\r\n~~~ java\r\npublic class SoutUtil {\r\n    /**\r\n     * 打印边框 行为\r\n     * @param flagBit  打印边框的样式 ：*、》、> 、+ 、= 、-\r\n     */\r\n    public static void soutFrame(String flagBit, String action){\r\n        int loopSize = Constant.SOUT_FRAME_START.equals(action) ? 120 : 122;\r\n        System.out.print(Constant.SOUT_FRAME_START.equals(action) \r\n              ? action : \">>\\n\" + action);\r\n        \r\n        for (int i = 0; i < loopSize; i++) {\r\n            System.out.print(flagBit);\r\n        }\r\n        System.out.println(Constant.SOUT_FRAME_START.equals(action) ? \"\\n>>\":\"\");\r\n    }\r\n\r\n\r\n    /**\r\n     * 格式化输出obj 依赖 soutFrame\r\n     * @param obj\r\n     */\r\n    public static void soutObject(Object obj){\r\n        System.out.println(\">>   \" + obj);\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n","timestamp":1642514536573},{"name":"03-单例模式.md","path":"02-java篇/02-技术栈/01-设计模式/02-创建型/03-单例模式.md","content":"# 单例模式\r\n\r\n> <span style=\"color:#42B983;font-weight:bold;\">单例模式：</span>保证一个类有且仅有一个实例，并提供一个访问它（单例实例）的全局访问点\r\n>\r\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2021年01月10日22:37:07</span>\r\n\r\n## 一、单例类图结构\r\n\r\n![image-20210110225313174](amWiki/images/lib_img/image-20210110225313174.png)\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">即：</span>\r\n\r\n​     <span style=\"border-bottom: 2px solid #0081EF;\">通常我们可以让一个全局变量使得一个对象被访问，但是它不能防止你实例化多个对象。</span></br>\r\n<span style=\"border-bottom: 2px solid #0081EF;\">而解决其最好的方法就是：让其自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建</span></br>\r\n<span style=\"border-bottom: 2px solid #0081EF;\">并且它可以提供一个访问其自身唯一实例的方法。</span>\r\n\r\n</br></br></br>\r\n\r\n## 二、懒汉式单例\r\n\r\n> <span style=\"color:#42B983;font-weight:bold;\">懒汉式：</span>指全局单例实例在第一次被使用时构建\r\n\r\n### 1、简单版本\r\n\r\n~~~java\r\npublic class Single1 {\r\n    private static Single1 instance;\r\n    public static Single1 getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single1();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n~~~\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">注：</span>基本按照单例原则实现单例模式，对外提供了唯一的实例访问节点。</br>\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">缺：</span>没有将实例构造器私有化，外界依旧可以获取新的实例，破坏了单一实例的原则。</br>\r\n\r\n</br></br>\r\n\r\n### 1.1、简单版本升级\r\n\r\n~~~java\r\npublic class Single1 {\r\n    private static Single1 instance;\r\n    private Single1() {}\r\n    public static Single1 getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single1();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n~~~\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">注：</span>针对简单版本所暴露的不足，进行改善将其构造器私有化，实例的初始化交由实例类自己管理。</br>\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">缺：</span>看似完美，世界近乎和平！但是人一多起来一切就都变了。开个玩笑<span style=\"color:#FF531A;font-weight:bold;\">^.- !! </span></br>\r\n​         <span style=\"border-bottom: 2px solid #0081EF;\">这种写法在大多数的时候也是没问题的。问题在于，当多线程工作的时候，如果有多个线程</span><br>\r\n<span style=\"border-bottom: 2px solid #0081EF;\">同时运行到if (instance == null),都判断为null,那么两个线程就各自会创建一个实例——这样一来，就不是单例了。</span></br>\r\n\r\n</br></br>\r\n\r\n### 2、Synchronized版本\r\n\r\n> 既然简单版本对多线程的场景考虑不足，那我们就为其加入同步机制——同步锁\r\n\r\n~~~java\r\npublic class Single2 {\r\n    private static Single2 instance;\r\n    private Single2() {}\r\n    public static synchronized Single2 getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single2();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n~~~\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">注：</span>在单例模式实例单一原则的基础上，加入同步机制（对实例判空和初始化操作同步）确保实例唯一。</br>\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">缺：</span>对唯一实例访问节点加入同步机制，解决了多个实例出现的问题，但是给 <span style=\"border-bottom: 2px solid #0081EF;color:#FF531A;font-weight:bold;\">除了进入同步之外的线程强制增加了等待时间</span></br>\r\n\r\n</br></br>\r\n\r\n### 3、双重检查（Double-Check）\r\n\r\n> Synchronized版本其实是用了100%会出现的防护盾(延迟问题),去避免了1%几率出现的问题(多线程多实例)问题\r\n>\r\n> <span style=\"color:#42B983;font-weight:bold;\">双重检查：</span>优化了这个问题，我们继续来看\r\n\r\n~~~java\r\npublic class Single3 {\r\n    private static Single3 instance;\r\n    private Single3() {}\r\n    public static Single3 getInstance() {\r\n        // 无同步 - 初始化检查\r\n        if (instance == null) {\r\n            synchronized (Single3.class) {\r\n                // 同步 - 初始化检查\r\n                if (instance == null) {\r\n                    instance = new Single3();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n~~~\r\n\r\n这个版本的代码看起来有点复杂\r\n注意其中有两次if (instance == null)的判断，这个叫做<span style=\"color:#FF531A;font-weight:bold;\">『双重检查 Double-Check』</span>。\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">注：</span>\r\n\r\n* **第一个if (instance == null)：**</br>\r\n\r\n  其实是为了解决Version2中的效率问题，只有instance为null的时候，才进入synchronized的代码段——大大减少了几率。</br>\r\n\r\n* **第二个if (instance == null)：**</br>\r\n\r\n   则是跟Synchronized版本一样，是为了防止可能出现多个实例的情况。</br>\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">缺：</span>这里需要前置知识：<span style=\"color:#FF531A;font-weight:bold;\">原子操作</span>  &  <span style=\"color:#FF531A;font-weight:bold;\">指令重排</span></br>\r\n\r\n而问题就出在：instance = new Single3(); </br>\r\n\r\n**1 、该操作非原子操作，分为如下三步：**\r\n\r\n​\t\ta、给instance分配内存</br>\r\n​       b、调用Single3构造函数初始化成员变量，完成实例化</br>\r\n​       c、将instance的引用指向，实例的堆内存空间</br>\r\n\r\n**2、jvm有指令重排优化，就有可能是 a - c - b**</br>\r\n\r\n​      这时问题就出现了：</br>\r\n​               线程t1完成了a、c，但是还未完成b，CPU时间片到了。</br>\r\n​               线程t2上来就判断了instance不为空，但是这时候b还未完成，此时使用实例就顺利成章的报错了</br>\r\n\r\n</br></br>\r\n\r\n### 4、volatile版本\r\n\r\n>  <span style=\"color:#42B983;font-weight:bold;\">终极版本：volatile</span>  解决了  <span style=\"color:#FF531A;font-weight:bold;\">双重检查(Double-Check)</span> 中遗留的问题，我们继续看  0.o\r\n\r\n~~~java\r\npublic class Single4 {\r\n    // 内存可见 &  禁止指令重排\r\n    private static volatile Single4 instance;\r\n    private Single4() {}\r\n    public static Single4 getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Single4.class) {\r\n                if (instance == null) {\r\n                    instance = new Single4();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n~~~\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">注：</span>\r\n\r\nvolatile关键字的一个作用是禁止指令重排，把instance声明为volatile之后，\r\n对它的写操作就会有一个内存屏障（什么是内存屏障？），这样，在它的赋值完成之前，就不用会调用读操作。</br>\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">缺：</span>经过4个版本的迭代应该完美了吧，世界该和平了吧！</br>\r\n然而并没有，这只是暴风雨（强大的反射）来临前的宁静  <span style=\"color:#FF531A;font-weight:bold;\">^.- !! </span></br>\r\n\r\n</br></br></br>\r\n\r\n## 三、饿汉式单例\r\n\r\n> <span style=\"color:#42B983;font-weight:bold;\">饿汉式：</span>指全局单例实例在类被装载时构建。下面我们接着看\r\n\r\n~~~java\r\npublic class SingleB {\r\n    // 实例在类被加载时就实例化\r\n    private static final SingleB INSTANCE = new SingleB();\r\n    private SingleB() {}\r\n    public static SingleB getInstance() {\r\n        return INSTANCE;\r\n    }\r\n}\r\n~~~\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">注：</span>对于一个恶汉式单例的写法，就<span style=\"border-bottom: 2px solid #0081EF;\">目前来看式完美</span>的。\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">缺：</span>实例初始化是在类加载时进行，开发者无法精准把我实例的初始化时机，引申出以下问题：\r\n\r\n1、可能初始化的太早，造成资源浪费\r\n\r\n2、如果初始化本身依赖于一些其他资源，就很难保证其他数据在它初始化前准备就绪\r\n\r\n故：<span style=\"border-bottom: 2px solid #0081EF;\">如果所需的单例占用的资源很少，并且也不依赖于其他数据，那么这种实现方式也是很好的。</span>\r\n\r\n</br></br></br>\r\n\r\n## 四、其他单例实现\r\n\r\n### 1、静态内部类版本\r\n\r\n> <span style=\"color:#42B983;font-weight:bold;\">静态内部类写法 </span>是《Effective》一书中提倡的一种<span style=\"color:#FF531A;font-weight:bold;\">“神乎其技”</span>写法\r\n\r\n~~~java\r\npublic class Singleton {\r\n    // 静态内部类管理实例\r\n    private static class SingletonHolder {\r\n        private static final Singleton INSTANCE = new Singleton();\r\n    }\r\n    private Singleton (){}\r\n    public static final Singleton getInstance() {\r\n        return SingletonHolder.INSTANCE;\r\n    }\r\n}\r\n~~~\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">注：</span>这种写法非常巧妙\r\n\r\n​\t\t1、对于内部类SingletonHolder，它是一个饿汉式的单例实现，在SingletonHolder初始化的时候会由ClassLoader来保证同步，使INSTANCE是一个真·单例</br>\r\n\r\n​\t\t2、同时，由于SingletonHolder是一个内部类，只在外部类的Singleton的getInstance()中被使用，所以它被加载的时机也就是在getInstance()方法第一次被调用的时候。\r\n\r\n<span style=\"border-bottom: 2px solid #0081EF;color:#FF531A;font-weight:bold;\">——它利用了ClassLoader来保证了同步，同时又能让开发者控制类加载的时机。从内部看是一个饿汉式的单例，但是从外部看来，又的确是懒汉式的实现。简直神乎其技！！！佩服</span>\r\n\r\n</br></br>\r\n\r\n### 2、 枚举终极版本\r\n\r\n> <span style=\"color:#42B983;font-weight:bold;\">枚举写法 </span>是《Effective》一书中提倡的另一种<span style=\"color:#FF531A;font-weight:bold;\">“神乎其技”</span>的写法\r\n\r\n~~~java\r\npublic enum SingleInstance {\r\n\r\n    INSTANCE;\r\n    \r\n    public void fun1() { \r\n        // do something\r\n    }\r\n}\r\n// 使用\r\nSingleInstance.INSTANCE.fun1();\r\n~~~\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">注：</span>看到了么？这是一个枚举类型……连class都不用了，极简。由于创建枚举实例的过程是线程安全的，所以这种写法也没有同步的问题。</br>\r\n\r\n<span style=\"border-bottom: 2px solid #0081EF;color:#FF531A;font-weight:bold;\">这种写法在功能上与共有域方法相近，但是它更简洁，无偿地提供了序列化机制，绝对防止对此实例化，即使是在面对复杂的序列化或者反射攻击的时候。单元素的枚举类型已经成为实现Singleton的最佳方法。</span></br>\r\n\r\n\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">缺：金无赤足，人无完人！</span>\r\n\r\n个人观点：枚举极简、安全、杜绝多实例非常优秀，但是也有不适用的场景：在需要继承场景时，它就不适用了。\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……\r\n\r\n</br></br>\r\n\r\n<span style=\"border-bottom: 2px solid #0081EF;color:#FF531A;font-weight:bold;\">所以，尽力做到能做到的最好就行了。</span>\r\n\r\n","timestamp":1642514536573},{"name":"04-建造者模式.md","path":"02-java篇/02-技术栈/01-设计模式/02-创建型/04-建造者模式.md","content":"","timestamp":1642514536573},{"name":"05-原型模式.md","path":"02-java篇/02-技术栈/01-设计模式/02-创建型/05-原型模式.md","content":"","timestamp":1642514536573},{"name":"01-适配器模式.md","path":"02-java篇/02-技术栈/01-设计模式/03-结构型/01-适配器模式.md","content":"","timestamp":1642514536573},{"name":"02-装饰器模式.md","path":"02-java篇/02-技术栈/01-设计模式/03-结构型/02-装饰器模式.md","content":"","timestamp":1642514536573},{"name":"03-代理模式.md","path":"02-java篇/02-技术栈/01-设计模式/03-结构型/03-代理模式.md","content":"","timestamp":1642514536573},{"name":"04-外观模式.md","path":"02-java篇/02-技术栈/01-设计模式/03-结构型/04-外观模式.md","content":"","timestamp":1642514536573},{"name":"05-桥接模式.md","path":"02-java篇/02-技术栈/01-设计模式/03-结构型/05-桥接模式.md","content":"","timestamp":1642514536573},{"name":"06-组合模式.md","path":"02-java篇/02-技术栈/01-设计模式/03-结构型/06-组合模式.md","content":"","timestamp":1642514536573},{"name":"07-享元模式.md","path":"02-java篇/02-技术栈/01-设计模式/03-结构型/07-享元模式.md","content":"","timestamp":1642514536573},{"name":"01-策略模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/01-策略模式.md","content":"","timestamp":1642514536573},{"name":"02-模板方法模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/02-模板方法模式.md","content":"","timestamp":1642514536573},{"name":"03-观察者模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/03-观察者模式.md","content":"","timestamp":1642514536573},{"name":"04-迭代子模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/04-迭代子模式.md","content":"","timestamp":1642514536573},{"name":"05-责任链模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/05-责任链模式.md","content":"","timestamp":1642514536573},{"name":"06-命令模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/06-命令模式.md","content":"","timestamp":1642514536573},{"name":"07-备忘录模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/07-备忘录模式.md","content":"","timestamp":1642514536573},{"name":"08-状态模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/08-状态模式.md","content":"","timestamp":1642514536573},{"name":"09-访问者模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/09-访问者模式.md","content":"","timestamp":1642514536573},{"name":"10-中介者模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/10-中介者模式.md","content":"","timestamp":1642514536573},{"name":"11-解释器模式.md","path":"02-java篇/02-技术栈/01-设计模式/04-行为型/11-解释器模式.md","content":"","timestamp":1642514536573},{"name":"01-class类文件结构.md","path":"02-java篇/02-技术栈/02-jvm/01-class类文件结构.md","content":"# java类（.class）文件结构\r\n\r\n>Class文件结构是了解虚拟机的重要基础之一，如果想深入的了解虚拟机，Class文件结构是不能不了解的。\r\n>\r\n>时间：<span style=\"color:#42B983;font-weight:bold;\">2021年3月29日14:48:33</span>\r\n\r\n## 一 、概述\r\n\r\nClass文件格式只有两种数据类型：<span style=\"color:#FC5531; font-weight:bold;\">无符号数</span>  和  <span style=\"color:#FC5531; font-weight:bold;\">表</span>。\r\n\r\n* <span style=\"color:#42B983; font-weight:bold;\">无符号数 : </span>\r\n\r\n   属于基本的数据类型，以\r\n\r\n   u1 ：代表1个字节\r\n   u2 ：代表2个字节\r\n   u4 ：代表4个字节\r\n   u8 ：代表8个字节  的无符号数；\r\n\r\n  可用来描述数字，索引引用，数量值或者按照UTF-8编码构成的字符串值\r\n\r\n* <span style=\"color:#42B983; font-weight:bold;\">表 : </span>\r\n\r\n  由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以 <span style=\"color:#FC5531; font-weight:bold;\">“_info”</span> 结尾。\r\n\r\n  表用于描述由层次关系的复合结构的数据，整个Class文件本质上就是一张表\r\n\r\n## 二、class文件内容\r\n\r\nclass文件内容：\r\n\r\n<span style=\"color:#42B983; font-weight:bold;\">\t\t\t魔数、次版本号、主版本号、常量池计数器、常量池、访问标志、类索引、父类索引、接口计数器 </span></br>\r\n\r\n<span style=\"color:#42B983; font-weight:bold;\">接口索引集合，字段计数器、字段表集合、方法计数器、方法表集合、属性计数器、属性表集合</span></br>\r\n\r\n具体表现形式：\r\n\r\n![image-20210411184653273](amWiki/images/lib_img/image-20210411184653273.png)\r\n\r\n## 三、魔数与class文件版本\r\n\r\n* <span style=\"color:#42B983; font-weight:bold;\">魔数 : </span>\r\n\r\n  Class 文件的头 4 个字节称为魔数，用来表示这个 Class 文件的类型</br>\r\n\r\n  Class 文件的魔数是用 16 进制表示的“CAFE BABE”，是不是很具有浪漫色彩？</br>\r\n\r\n  ![image-20210411184737898](amWiki/images/lib_img/image-20210411184737898.png)\r\n\r\n> 魔数相当于文件后缀名，只不过后缀名容易被修改，不安全，因此在 Class 文件中标识文件类型比较合适。\r\n\r\n\r\n\r\n* <span style=\"color:#42B983; font-weight:bold;\">class文件版本 : </span></br>\r\n\r\n  **紧接着魔数的4个字节是Class文件的版本号**：</br>\r\n\r\n  第5,6字节是次版本号（Minor Version）</br>\r\n\r\n  第7,8字节是主版本号（Major Version）</br>\r\n\r\n  ![1617009187240](assets\\1617009187240.png)\r\n\r\n> 如上例：0x00000034  十进制版本代号：52.0 即jdk1.8.0\r\n\r\n\r\n## 四、常量池\r\n\r\n### 1、简述\r\n\r\n版本信息之后就是常量池，常量池中存放两种类型的常量：</br>\r\n\r\n<span style=\"color:#42B983; font-weight:bold;\">字面值常量 : </span></br>\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">字面值常量就是我们在程序中定义的字符串、被 final 修饰的值。</span></br>\r\n\r\n<span style=\"color:#42B983; font-weight:bold;\">符号引用 : </span></br>\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">符号引用就是我们定义的各种名字：类和接口的全限定名、字段的名字和描述符、方法的名字和描述符。</span></br>\r\n\r\n### 2、常量池特点\r\n\r\n- 常量池中常量数量不固定，因此常量池开头放置一个 u2 类型的无符号数，用来存储当前常量池的容量。\r\n\r\n  \r\n\r\n  > 一个U2无符号数：0X00 12  代表十进制常量个数:1*16 +2 -1 =17个\r\n  >\r\n  > <span style=\"color:#FC5531; font-weight:bold;\">注：</span>这里说有17个常量，不是指往后数17个字节都是常量，<span style=\"color:#FC5531; font-weight:bold;\">切记常量的个数是从1计数的</span>\r\n\r\n- 常量池的每一项常量都是一个表，表开始的第一位是一个 u1 类型的标志位（tag），代表当前这个常量属于哪种常量类型。\r\n\r\n![image-20210411185014603](amWiki/images/lib_img/image-20210411185014603.png)\r\n\r\n> 一个U1无符号数：0X0A  表示第一个常量的tag \r\n>\r\n> 即：tag=10 表示：CONSTANT_Methodref_info类中方法的符号引用\r\n\r\n![image-20210411185041364](amWiki/images/lib_img/image-20210411185041364.png)\r\n\r\n> 上表详见：常量类型结构\r\n>\r\n> 故：该常量由：U1_tag，U2_index，U2_index组成 ：0x 0A 00 03 00 0F\r\n>\r\n> ![1617009332453](assets\\1617009332453.png)\r\n\r\n### 3、常量池类型\r\n\r\n| 类型                             | tag  | 描述                   |\r\n| -------------------------------- | ---- | ---------------------- |\r\n| CONSTANT_utf8_info               | 1    | UTF-8 编码的字符串     |\r\n| CONSTANT_Integer_info            | 3    | 整型字面量             |\r\n| CONSTANT_Float_info              | 4    | 浮点型字面量           |\r\n| CONSTANT_Long_info               | 5    | 长整型字面量           |\r\n| CONSTANT_Double_info             | 6    | 双精度浮点型字面量     |\r\n| CONSTANT_Class_info              | 7    | 类或接口的符号引用     |\r\n| CONSTANT_String_info             | 8    | 字符串类型字面量       |\r\n| CONSTANT_Fieldref_info           | 9    | 字段的符号引用         |\r\n| CONSTANT_Methodref_info          | 10   | 类中方法的符号引用     |\r\n| CONSTANT_InterfaceMethodref_info | 11   | 接口中方法的符号引用   |\r\n| CONSTANT_NameAndType_info        | 12   | 字段或方法的符号引用   |\r\n| CONSTANT_MethodHandle_info       | 15   | 表示方法句柄           |\r\n| CONSTANT_MethodType_info         | 16   | 标识方法类型           |\r\n| CONSTANT_InvokeDynamic_info      | 18   | 表示一个动态方法调用点 |\r\n\r\n### 4、常量类型结构表\r\n\r\n![image-20210411190015135](amWiki/images/lib_img/image-20210411190015135.png)\r\n\r\n![image-20210411190030282](/home/ryan/locallibconf/git_lib_conf/ryan_amWiki/amWiki_datas/amWiki/images/lib_img/image-20210411190030282.png)\r\n\r\n## 五、访问标志\r\n\r\n> <span style=\"color:#42B983;font-weight:bold;\">访问标志 ：</span>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否被 abstract/final 修饰\r\n\r\n![image-20210411185307773](amWiki/images/lib_img/image-20210411185307773.png)\r\n\r\n在本例中：0x00 21 == 0x0001|0x0020表示是一个用户定义的public类\r\n\r\n![image-20210411190051009](amWiki/images/lib_img/image-20210411190051009.png)\r\n\r\n## 六、索引\r\n\r\n> <span style=\"color:#42B983;font-weight:bold;\">索引：</span> <span style=\"color:#FC5531; font-weight:bold;\">类索引、父类索引</span> 和 <span style=\"color:#FC5531; font-weight:bold;\">接口索引集合</span>\r\n\r\n访问标志符紧接着的二进制表示本例中类的继承关系，共三项\r\n\r\n###  <span style=\"color:#FC5531; font-weight:bold;\">1、类索引</span>\r\n\r\nU2 两个字节，常量池中的对本类的描述\r\n\r\n![image-20210411185341635](amWiki/images/lib_img/image-20210411185341635.png)\r\n\r\n> 0x0002 表示常量池中第2个常量为类索引\r\n\r\n### <span style=\"color:#FC5531; font-weight:bold;\">2、父类索引</span>\r\n\r\nU2 两个字节，常量池中对父类的描述\r\n\r\n![image-20210411185403612](amWiki/images/lib_img/image-20210411185403612.png)\r\n\r\n> 0x0003 表示常量池中第3个常量为类索引\r\n\r\n### <span style=\"color:#FC5531; font-weight:bold;\">3、接口索引 、</span> <span style=\"color:#FC5531; font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px\">接口索引集合</span>\r\n\r\n头两个字节表示接口数，然后，紧跟进接口列表\r\n\r\n![image-20210411185433874](amWiki/images/lib_img/image-20210411185433874.png)\r\n\r\n> 0x0000表示实现的接口个数为0个,也就没有接口索引集合了\r\n\r\n## 七、字段表集合\r\n\r\n接着的二进制表示字段表，头两位为个数，个数后边是字段内容\r\n\r\n### <span style=\"color:#42B983;font-weight:bold;\">1、字段描述规则：</span>\r\n\r\n![image-20210411190112404](amWiki/images/lib_img/image-20210411190112404.png)\r\n\r\n###  <span style=\"color:#42B983;font-weight:bold;\">2、access_flags的取值表：</span>\r\n\r\n![image-20210411190120331](amWiki/images/lib_img/image-20210411190120331.png)\r\n\r\n###  <span style=\"color:#42B983;font-weight:bold;\">3、name_index</span>\r\n\r\n\tname_index的含义，同上，映射至常量池中的常量索引\r\n\r\n### <span style=\"color:#42B983;font-weight:bold;\">4、descriptor_index</span>\r\n\r\n\tdescriptor_index，描述符，表示该变量的类型，此处插一下描述符的表示规则：\r\n\t\r\n\t 4.1 描述符中的字符含义如下：\r\n\r\n![image-20210411190138262](amWiki/images/lib_img/image-20210411190138262.png)\r\n\r\n\t4.2 表示数组时，每一个维度前用“[”表示\r\n\t\r\n\t4.3 描述方法，先参后返回值\r\n\r\n### <span style=\"color:#42B983;font-weight:bold;\">5、本例字段</span>\r\n\r\n* 字段计数\r\n\r\n  ![image-20210411185514320](amWiki/images/lib_img/image-20210411185514320.png)\r\n\r\n  > 0x0001 表示只有一个字段\r\n\r\n* 字段内容\r\n\r\n  ![image-20210411185551074](amWiki/images/lib_img/image-20210411185551074.png)\r\n\r\n  > 0x0002000400050000表示：0002(private)00040005(查看第四、第五常量)0000(attributes_count)\r\n\r\n## 八、方法表集合\r\n\r\n接着的二进制表示方法表，头两位为个数\r\n\r\n### <span style=\"color:#42B983;font-weight:bold;\">1、方法描述规则：</span>\r\n\r\n![image-20210411190152249](amWiki/images/lib_img/image-20210411190152249.png)\r\n\r\n### <span style=\"color:#42B983;font-weight:bold;\">2、access_flags的取值表：</span>\r\n\r\n![image-20210411190202097](amWiki/images/lib_img/image-20210411190202097.png)\r\n\r\n### <span style=\"color:#42B983;font-weight:bold;\">3、本例方法</span>\r\n\r\n* 方法计数器\r\n\r\n![image-20210411185618297](amWiki/images/lib_img/image-20210411185618297.png)\r\n\r\n> 0x0001 表示本例中方法个数为1\r\n\r\n![image-20210411185653663](amWiki/images/lib_img/image-20210411185653663.png)\r\n\r\n> 0x0001 表示方法为public   \r\n\r\n> 0x0006 表示常量池中第六个常量   : 表示初始化方法（构造器）\r\n\r\n![image-20210411185710640](amWiki/images/lib_img/image-20210411185710640.png)\r\n\r\n> 0x0007 表示常量池中第七个常量 ：依据“描述字符含义表” v 为void返回值\r\n\r\n![1617090991978](assets\\1617090991978.png)\r\n\r\n## 九、属性表集合\r\n\r\n\r\n\r\n## 十、附录\r\n\r\n### 1、java类\r\n\r\n~~~java\r\npackage site.ryanc;\r\n\r\npublic class User {\r\n    private String name;\r\n}\r\n~~~\r\n\r\n### 2、class文件\r\n\r\n~~~java\r\n//\r\n// Source code recreated from a .class file by IntelliJ IDEA\r\n// (powered by FernFlower decompiler)\r\n//\r\n\r\npackage site.ryanc;\r\n\r\npublic class User {\r\n    private String name;\r\n\r\n    public User() {\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n### 3、class二进制文件\r\n\r\n~~~txt\r\n\t\t\t0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\r\n00000000h: CA FE BA BE 00 00 00 34 00 12 0A 00 03 00 0F 07 ; 漱壕...4........\r\n00000010h: 00 10 07 00 11 01 00 04 6E 61 6D 65 01 00 12 4C ; ........name...L\r\n00000020h: 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 ; java/lang/String\r\n00000030h: 3B 01 00 06 3C 69 6E 69 74 3E 01 00 03 28 29 56 ; ;...<init>...()V\r\n00000040h: 01 00 04 43 6F 64 65 01 00 0F 4C 69 6E 65 4E 75 ; ...Code...LineNu\r\n00000050h: 6D 62 65 72 54 61 62 6C 65 01 00 12 4C 6F 63 61 ; mberTable...Loca\r\n00000060h: 6C 56 61 72 69 61 62 6C 65 54 61 62 6C 65 01 00 ; lVariableTable..\r\n00000070h: 04 74 68 69 73 01 00 11 4C 73 69 74 65 2F 72 79 ; .this...Lsite/ry\r\n00000080h: 61 6E 63 2F 55 73 65 72 3B 01 00 0A 53 6F 75 72 ; anc/User;...Sour\r\n00000090h: 63 65 46 69 6C 65 01 00 09 55 73 65 72 2E 6A 61 ; ceFile...User.ja\r\n000000a0h: 76 61 0C 00 06 00 07 01 00 0F 73 69 74 65 2F 72 ; va........site/r\r\n000000b0h: 79 61 6E 63 2F 55 73 65 72 01 00 10 6A 61 76 61 ; yanc/User...java\r\n000000c0h: 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74 00 21 00 02 ; /lang/Object.!..\r\n000000d0h: 00 03 00 00 00 01 00 02 00 04 00 05 00 00 00 01 ; ................\r\n000000e0h: 00 01 00 06 00 07 00 01 00 08 00 00 00 2F 00 01 ; ............./..\r\n000000f0h: 00 01 00 00 00 05 2A 3F 00 01 3F 00 00 00 02 00 ; ......*?..?.....\r\n00000100h: 09 00 00 00 06 00 01 00 00 00 02 00 0A 00 00 00 ; ................\r\n00000110h: 0C 00 01 00 00 00 05 00 0B 00 0C 00 00 00 01 00 ; ................\r\n00000120h: 0D 00 00 00 02 00 0E                            ; .......\r\n~~~\r\n\r\n### 4、class二进制解读\r\n\r\n___\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">（魔数）</span>      <span style=\"color:#ed7d31; font-weight:bold;\">CA FE BA BE</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（版本）</span>      <span style=\"color:#ffc000; font-weight:bold;\">00 00 00 34</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（常量容量</span>\t<span style=\"color:#70ad47; font-weight:bold;\">00 12</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（常量01）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">0A 00 03 00 0F</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（常量02）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">07 00 10</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（常量03）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">07 00 11</span></br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（常量04）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 04 6E 61 6D 65</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（常量05）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 12 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 3B</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（常量06）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 06 3C 69 6E 69 74 3E</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（常量07）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 03 28 29 56</span></br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（常量08）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 04 43 6F 64 65</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（常量09）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 0F 4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（常量10）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 12 4C 6F 63 61 6C 56 61 72 69 61 62 6C 65 54 61 62 6C 65</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（常量11）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 04 74 68 69 73</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（常量12）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 11 4C 73 69 74 65 2F 72 79 61 6E 63 2F 55 73 65 72 3B</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（常量13）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 0A 53 6F 75 72 63 65 46 69 6C 65</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（常量14）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 09 55 73 65 72 2E 6A 61 76 61</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（常量15）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">0C 00 06 00 07</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（常量16）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 0F 73 69 74 65 2F 72 79 61 6E 63 2F 55 73 65 72</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（常量17）</span>    <span style=\"color:#5b73d5; font-weight:bold;\">01 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（访问标志） </span><span style=\"color:#7030a0; font-weight:bold;\">00 21</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（类索引）</span>     <span style=\"color:#c00000; font-weight:bold;\">00 02</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（父类索引） </span><span style=\"color:#c00000; font-weight:bold;\">00 03</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（接口个数） </span><span style=\"color:#c00000; font-weight:bold;\">00 00</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（接口索引）</span><span style=\"color:#c00000; font-weight:bold;\"> NULL</span></br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（字段计数）</span> <span style=\"color:#000000; font-weight:bold;\">00 01</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（字段一）</span>     <span style=\"color:#000000; font-weight:bold;\">00 02 00 04 00 05 00 00</span> </br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">（方法计数） </span><span style=\"color:#000000; font-weight:bold;\">00 01</span> </br>\r\n\r\n00 01 00 06 00 07 00 01 00 08 00 00 00 2F 00 01 </br>\r\n\r\n00 01 00 00 00 05 2A 3F 00 01 3F 00 00 00 02 00 </br>\r\n\r\n09 00 00 00 06 00 01 00 00 00 02 00 0A 00 00 00 </br>\r\n\r\n0C 00 01 00 00 00 05 00 0B 00 0C 00 00 00 01 00 </br>\r\n\r\n0D 00 00 00 02 00 0E</br>\r\n\r\n___\r\n\r\n### 面试经\r\n\r\n暂无\r\n\r\n\r\n\r\n### 参考\r\n\r\n👉 [Java中的类文件结构之一：如何分析一个.class文件的二进制码内容_kcstrong的博客-CSDN博客](https://blog.csdn.net/kcstrong/article/details/79460262)\r\n\r\n👉 [Java类文件结构详解_A_zhenzhen的专栏-CSDN博客_java类文件结构](https://blog.csdn.net/A_zhenzhen/article/details/77977345)\r\n\r\n👉 https://github.com/doocs/jvm/blob/main/docs/07-class-structure.md\r\n\r\n","timestamp":1642514536573},{"name":"02-jvm内存结构.md","path":"02-java篇/02-技术栈/02-jvm/02-jvm内存结构.md","content":"# jvm 内存结构\r\n\r\n>本文所有内容基于: \t<span style=\"color:#42B983;font-weight:bold;\">HotSpot    jdk1.8</span>\t\r\n>\r\n>时间：<span style=\"color:#42B983;font-weight:bold;\">2021年4月7日14:15:21</span>\r\n\r\n## 一、简述\r\n\r\njava 虚拟机的内存空间可以分为（基于jvm设计规范的概念）：</br>\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">五部分：</span><span style=\"color:#FC5531; font-weight:bold;\">程序计数器、java虚拟机栈、本地方法栈，堆 和 方法区</span> **直接内存**</br>\r\n\r\n\r\n\r\n![jvm-memory-structure.jpg](https://github.com/doocs/jvm/blob/main/docs/images/jvm-memory-structure.jpg?raw=true)\r\n\r\n---\r\n\r\n\r\n\r\n![image-20210411165306022](amWiki/images/lib_img/image-20210411165306022.png)\r\n\r\n---\r\n\r\n![image-20210411165421771](amWiki/images/lib_img/image-20210411165421771.png)\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">扩展：</span>\r\n\r\n<span style=\"border-bottom: 2px solid #0081EF;\">JDK 1.8 同 JDK 1.7 比，最大的差别就是：</span><span style=\"border-bottom: 2px solid #0081EF;color:#FC5531;\">元数据区取代了永久代。</span></br>\r\n\r\n<span style=\"border-bottom: 2px solid #0081EF;\">元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。</span></br>\r\n\r\n<span style=\"border-bottom: 2px solid #0081EF;\">不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。</span></br>\r\n\r\n\r\n\r\n## 二、程序计数器\r\n\r\n### 1、定义\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">\t程序计数器</span>  是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。</br>\r\n\r\n若当前线程正在执行的是一个本地方法，那么此时程序计数器为`Undefined`。</br>\r\n\r\n每个线程都具有各自独立的程序计数器，所以该区域是  <span style=\"color:#FC5531; font-weight:bold;\">★非线程共享的内存区域★</span></br>\r\n\r\n### 2、作用\r\n\r\n- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。\r\n- 在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。\r\n\r\n### 3、特点\r\n\r\n- 是一块较小的内存空间。\r\n- 线程私有，每条线程都有自己的程序计数器。\r\n- 生命周期：随着线程的创建而创建，随着线程的结束而销毁。\r\n- 是唯一一个  <span style=\"color:#FC5531; font-weight:bold;\">不会出现`OutOfMemoryError`的内存区域。</span>\r\n\r\n## 三 、java虚拟机栈\r\n\r\n### 1、定义\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">Java 虚拟机栈</span>  是描述 Java 方法运行过程的内存模型。\r\n\r\nJava 虚拟机栈会为每一个即将运行的 Java 方法创建一块叫做“栈帧”的区域，用于存放该方法运行过程中的一些信息，如：\r\n\r\n- 局部变量表\r\n- 操作数栈\r\n- 动态链接\r\n- 方法出口信息\r\n- ......\r\n\r\n![image-20210411165529231](amWiki/images/lib_img/image-20210411165529231.png)\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">扩展：</span> \r\n\r\n* 栈帧：局部变量表、操作栈、动态链接、方法返回地址\r\n\r\n  * <span style=\"color:#42B983;font-weight:bold;\">局部变量表</span>\r\n\r\n    存放方法参数和局部变量\r\n    相对于类属性变量的准备阶段和初始化阶段来说，局部变量没有准备阶段，必须显式初始化\r\n    如果是非静态方法，则在index[0]位置上存储的是方法所属对象的实例引用，随后存储的是参数和局部变量\r\n    字节码指令中的STORE指令就是将操作栈中计算完成的局部变量写回局部变量表的存储空间内\r\n\r\n  * <span style=\"color:#42B983;font-weight:bold;\">操作栈</span>\r\n\r\n    操作栈是一个初始状态为空的桶式结构栈 在方法执行过程中，会有各种指令往栈中写入和提取信息 JVM的执行引擎是基于栈的执行引擎，其中的栈指的就是操作栈 字节码指令集的定义都是基于栈类型的,栈的深度在方法元信息的stack属性中\r\n\r\n  * <span style=\"color:#42B983;font-weight:bold;\">动态链接</span>\r\n\r\n    每个栈帧中包含一个在常量池中对当前方法的引用，目的是支持方法调用过程的动态连接\r\n\r\n  * <span style=\"color:#42B983;font-weight:bold;\">方法返回地址</span>\r\n\r\n    方法执行时有两种退出情况 正常退出 正常执行到任何方法的返回字节码指令，如RETURN、IRETURN、ARETURN等 异常退出 无论何种退出情况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧\r\n\r\n\r\n\r\n### 2、压栈出栈过程\r\n\r\n当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。\r\n\r\nJava 虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。\r\n\r\n方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。\r\n\r\n> 由于 Java 虚拟机栈是与线程对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题。\r\n\r\n\r\n\r\n### 3、特点\r\n\r\n- 局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。</br>\r\n- Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</br>\r\n  - <span style=\"border-bottom: 2px solid #0081EF;color:#FC5531;\">StackOverFlowError</span> <span style=\"border-bottom: 2px solid #0081EF;\">若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。</br></span>\r\n  - <span style=\"border-bottom: 2px solid #0081EF;color:#FC5531;\">OutOfMemoryError</span> <span style=\"border-bottom: 2px solid #0081EF;\">若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OutOfMemoryError 异常。</span></br>\r\n- Java 虚拟机栈也是线程私有，随着线程创建而创建，随着线程的结束而销毁。</br>\r\n\r\n> 出现 StackOverFlowError 时，内存空间可能还有很多。\r\n\r\n\r\n\r\n\r\n## 四、本地方法栈\r\n\r\n### 1、定义\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">本地方法栈</span>  是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。\r\n\r\n\r\n\r\n### 2、栈帧变化过程\r\n\r\n本地方法被执行时，在本地方法栈也会创建一块栈帧，\r\n用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。\r\n\r\n方法执行结束后，相应的栈帧也会出栈，并释放内存空间。\r\n也会抛出 StackOverFlowError 和OutOfMemoryError 异常。\r\n\r\n> 如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。\r\n\r\n## 五、堆\r\n\r\n### 1、定义\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">堆 </span> 是用来存放对象的内存空间，<span style=\"color:#FC5531; font-weight:bold;\"> 几乎 </span>所有的对象都存储在堆中。\r\n\r\n### 2、特点\r\n\r\n对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。\r\n\r\n堆内存是所有线程共有的，可以分为两个部分：<span style=\"color:#FC5531; font-weight:bold;\"> 年轻代</span> 和 <span style=\"color:#FC5531; font-weight:bold;\"> 老年代</span>。\r\n\r\n<span style=\"border-bottom: 2px solid #0081EF;\">Perm代表的是永久代，但是注意永久代并不属于堆内存中的一部分</span>，<span style=\"border-bottom: 2px solid #0081EF;color:#FC5531;\">同时jdk1.8之后永久代已经被移除。</span>\r\n\r\n![image-20210411165604127](amWiki/images/lib_img/image-20210411165604127.png)\r\n\r\n- 线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。\r\n- 在虚拟机启动时创建。\r\n- 是垃圾回收的主要场所。\r\n- 进一步可分为：新生代（Eden 区：`From Survior`，`To Survivor`）、老年代。\r\n\r\n不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。\r\n\r\n堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出 OutOfMemoryError 异常。\r\n\r\n> Java 堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。\r\n\r\n## 六、方法区\r\n\r\n### 1、定义\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">方法区 ：</span>Java 虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息：\r\n\r\n- 已经被虚拟机加载的类信息\r\n- 常量\r\n- 静态变量\r\n- 即时编译器编译后的代码\r\n\r\n### 2、特点\r\n\r\n- 线程共享。 方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。\r\n- 永久代。 方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区称为“永久代”。\r\n- 内存回收效率低。 方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：对常量池的回收；对类型的卸载。\r\n- Java 虚拟机规范对方法区的要求比较宽松。 和堆一样，允许固定大小，也允许动态扩展，还允许不实现垃圾回收。\r\n\r\n### 3、运行时常量池\r\n\r\n方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码。常量就存放在运行时常量池中。\r\n\r\n当类被 Java 虚拟机加载后， .class 文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如 String 类的 `intern()` 方法就能在运行期间向常量池中添加字符串常量。\r\n\r\n\r\n\r\n## 七、直接内存\r\n\r\n### 1、定义\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">直接内存 </span> 并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。\r\n\r\njdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。\r\n\r\n### 2、操作直接内存\r\n\r\n在 NIO 中引入了一种基于通道和缓冲的 IO 方式。它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的`DirectByteBuffer`对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。\r\n\r\n<span style=\"border-bottom: 2px solid #0081EF;color:#FC5531;\">直接内存的大小不受 Java 虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError 异常。</span>\r\n\r\n### 3、直接内存与堆内存比较\r\n\r\n- 直接内存申请空间耗费更高的性能\r\n- 直接内存读取 IO 的性能要优于普通的堆内存。\r\n- 直接内存作用链： 本地 IO -> 直接内存 -> 本地 IO\r\n- 堆内存作用链：本地 IO -> 直接内存 -> 非直接内存 -> 直接内存 -> 本地 IO\r\n\r\n> 服务器管理员在配置虚拟机参数时，会根据实际内存设置`-Xmx`等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现`OutOfMemoryError`异常。\r\n\r\n\r\n\r\n## 附录\r\n\r\n### 面试经\r\n\r\n1、JVM管理的内存结构是怎样的？\r\n2、不同的虚拟机在实现运行时内存的时候有什么区别？\r\n3、运行时数据区中哪些区域是线程共享的？哪些是独享的？\r\n4、除了JVM运行时内存以外，还有什么区域可以用吗？\r\n5、堆和栈的区别是什么？\r\n6、Java中的数组是存储在堆上还是栈上的？\r\n7、Java中的对象创建有多少种方式？\r\n8、Java中对象创建的过程是怎么样的？\r\n9、Java中的对象一定在堆上分配内存吗？\r\n10、如何获取堆和栈的dump文件？\r\n\r\n解惑：[JVM内存结构的面试题_Virgil_K2017的博客-CSDN博客](https://blog.csdn.net/virgil_k2017/article/details/98851768)\r\n\r\n### 参考\r\n\r\n👉 [jvm/01-jvm-memory-structure.md at main · doocs/jvm (github.com)](https://github.com/doocs/jvm/blob/main/docs/01-jvm-memory-structure.md)\r\n\r\n👉 [JAVA高级面试题——2019_longzhutengyue的博客-CSDN博客_java 高级面试题](https://blog.csdn.net/longzhutengyue/article/details/95534447)\r\n\r\n\r\n\r\n\r\n\r\n","timestamp":1642514536573},{"name":"03-类加载的时机、过程和加载器.md","path":"02-java篇/02-技术栈/02-jvm/03-类加载的时机、过程和加载器.md","content":"# 类加载的时机、过程和加载器\r\n\r\n> 本文所有内容基于: \t<span style=\"color:#42B983;font-weight:bold;\">HotSpot    jdk1.8</span>\r\n>\r\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2021年4月6日14:42:44</span>\r\n\r\n## 一、类加载过程\r\n\r\n> 类加载主要分为：<span style=\"color:#FC5531; font-weight:bold;\">加载、链接(验证、准备，解析)，初始化 </span>三步\r\n\r\n![image-20210411165630344](amWiki/images/lib_img/image-20210411165630344.png)\r\n\r\n### 1、加载\r\n\r\n“加载”是“类加载”过程的一个阶段，不能混淆这两个名词。在加载阶段，虚拟机需要完成 3 件事：</br>\r\n\r\n- <span style=\"border-bottom: 2px solid #0081EF;\">通过类的全限定名获取该类的二进制字节流。</span>\r\n- <span style=\"border-bottom: 2px solid #0081EF;\">将二进制字节流所代表的静态结构转化为方法区的运行时数据结构。</span>\r\n- <span style=\"border-bottom: 2px solid #0081EF;\">在内存中创建一个代表该类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</span>\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">扩展:</span>\r\n\r\n * 获取二进制字节流\r\n   <span style=\"border-bottom: 2px solid #0081EF;\">对于 Class 文件，虚拟机没有指明要从哪里获取、怎样获取。</span></br>\r\n   <span style=\"border-bottom: 2px solid #0081EF;\">除了直接从编译好的 .class 文件中读取，还有以下几种方式</span>：</br>\r\n   * 从 zip 包中读取，如 jar、war 等\r\n   * 从网络中获取，如 Applet\r\n   * 通过动态代理技术生成代理类的二进制字节流\r\n   * 由 JSP 文件生成对应的 Class 类\r\n   * 从数据库中读取，如 有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分发。\r\n* “数组类” & “非数组类“ 比较\r\n  * <span style=\"border-bottom: 2px solid #0081EF;\">非数组类加载阶段可以使用系统提供的引导类加载器，也可以由用户自定义的类加载器完成，开发人员可以通过定义自己的类加载器控制字节流的获取方式（如重写一个类加载器的 `loadClass()` 方法）</span>\r\n  * <span style=\"border-bottom: 2px solid #0081EF;color:#FC5531;\">数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的，再由类加载器创建数组中的元素类。</span>\r\n\r\n\r\n\r\n### 2、链接\r\n\r\n#### a、验证\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述:</span>验证阶段确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求,并且不会危害虚拟机自身的安全。</br>\r\n\r\n- <span style=\"color:#FC5531; font-weight:bold;\">文件格式验证</span> 验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理，验证点如下：\r\n  - 是否以魔数 0XCAFEBABE 开头\r\n  - 主次版本号是否在当前虚拟机处理范围内\r\n  - 常量池是否有不被支持的常量类型\r\n  - 指向常量的索引值是否指向了不存在的常量\r\n  - CONSTANT_Utf8_info 型的常量是否有不符合 UTF8 编码的数据\r\n  - ......（详：类文件结构）\r\n- <span style=\"color:#FC5531; font-weight:bold;\">元数据验证</span> 对字节码描述信息进行语义分析，确保其符合 Java 语法规范。\r\n  - 是否有父类；\r\n  - 是否继承了不被允许继承的类；\r\n  - 如果该类不是抽象类，是否实现了其父类或接口要求实现的所有方法；\r\n  - ......\r\n- <span style=\"color:#FC5531; font-weight:bold;\">字节码验证</span> 本阶段是验证过程中最复杂的一个阶段，是对方法体进行语义分析，保证方法在运行时不会出现危害虚拟机的事件。\r\n  - 保证任何时候操作数栈的数据类型与指令代码序列的一致性；\r\n  - 跳转指令不会跳转到方法体以外的字节码指令上；\r\n  - ......\r\n- <span style=\"color:#FC5531; font-weight:bold;\">符号引用验证</span> 本阶段发生在解析阶段，确保解析正常执行。\r\n  - 符号引用的类、字段、方法的访问性（public、private等）是否可被当前类访问；\r\n  - 指定类是否存在符合方法的字段描述符；\r\n  - ......\r\n\r\n\r\n\r\n#### b、准备\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述: </span> 负责为类变量（或称“静态成员变量”）分配内存，并设置默认初始值。</br>\r\n\t   <span style=\"color:#FC5531; font-weight:bold;\">这些变量（★不包括实例变量★）所使用的内存都在方法区中进行分配</span></br>\r\n\r\n初始值“通常情况下”是数据类型的零值（0, null...），假设一个类变量的定义为：</br>\r\n\r\n```java\r\npublic static int value = 123;\r\n```\r\n\r\n那么变量 value 在准备阶段过后的初始值为 0 而不是 123，因为这时候尚未开始执行任何 Java 方法。</br>\r\n\r\n存在“特殊情况”：如果类字段的字段属性表中存在 ConstantValue 属性，</br>\r\n\r\n那么在准备阶段 value 就会被初始化为 ConstantValue 属性所指定的值，假设上面类变量 value 的定义变为：</br>\r\n\r\n```java\r\npublic static final int value = 123;\r\n```\r\n\r\n那么在准备阶段虚拟机会根据 ConstantValue 的设置将 value 赋值为 123。\r\n\r\n\r\n\r\n#### c、解析\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述:</span> 解析阶段是虚拟机将常量池内的符号引用替换成直接引用的过程。</br>\r\n\t  直接引用是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。</br>\r\n\t  直接引用和虚拟机实现的内存有关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用不尽相同。</br>\r\n\r\n\r\n\r\n### 3、初始化\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述:</span> 初始化阶段是类加载过程的最后一步，到了该阶段才真正开始执行类定义的Java程序代码，根据程序员通过代码定制的主观计划去初始化类变量和其他资源，是执行类构造器初始化方法的过程。</br>\r\n\r\n类初始化阶段是类加载过程的最后一步，是执行类构造器 `<clinit>()` 方法的过程。\r\n\r\n`<clinit>()` 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static {} 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。\r\n\r\n静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但不能访问。如下方代码所示：\r\n\r\n```java\r\npublic class Test {\r\n    static {\r\n        i = 0;  // 给变量赋值可以正常编译通过\r\n        System.out.println(i);  // 这句编译器会提示“非法向前引用”\r\n    }\r\n    static int i = 1;\r\n}\r\n```\r\n\r\n`<clinit>()` 方法不需要显式调用父类构造器，虚拟机会保证在子类的 `<clinit>()` 方法执行之前，父类的 `<clinit>()` 方法已经执行完毕。\r\n\r\n由于父类的 `<clinit>()` 方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作。如下方代码所示：\r\n\r\n```java\r\nstatic class Parent {\r\n    public static int A = 1;\r\n    static {\r\n        A = 2;\r\n    }\r\n}\r\n\r\nstatic class Sub extends Parent {\r\n    public static int B = A;\r\n}\r\n\r\npublic static void main(String[] args) {\r\n    System.out.println(Sub.B); // 输出 2\r\n}\r\n```\r\n\r\n`<clinit>()` 方法不是必需的，如果一个类没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成 `<clinit>()` 方法。\r\n\r\n接口中不能使用静态代码块，但接口也需要通过 `<clinit>()` 方法为接口中定义的静态成员变量显式初始化。但接口与类不同，接口的 `<clinit>()` 方法不需要先执行父类的 `<clinit>()` 方法，只有当父接口中定义的变量使用时，父接口才会初始化。\r\n\r\n虚拟机会保证一个类的 `<clinit>()` 方法在多线程环境中被正确加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 `<clinit>()` 方法。\r\n\r\n\r\n\r\n\r\n\r\n## 二、类加载时机\r\n\r\n### 1、类加载的生命周期\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">类加载的生命周期</span> 是从类被加载到内存开始，直到卸载出内存为止的。\r\n整个生命周期分为7个阶段：<span style=\"color:#FC5531; font-weight:bold;\">加载、验证、准备、解析、初始化、使用、卸载。</span>\r\n其中，<span style=\"border-bottom: 2px solid #0081EF;\">验证、准备、解析</span> 三部分统称为连接。\r\n\r\n![image-20210411165653573](amWiki/images/lib_img/image-20210411165653573.png)\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">注：</span>\r\n\r\n<span style=\"border-bottom: 2px solid #0081EF;\">加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的</span></br>\r\n\r\n<span style=\"border-bottom: 2px solid #0081EF;\">类的加载过程必须按照这种顺序按部就班地开始（注意是“开始”，而不是“进行”或“完成”）</span></br>\r\n\r\n<span style=\"border-bottom: 2px solid #0081EF;\">而解析阶段则不一定:它在某些情况下可以在初始化后再开始,这是为了支持 Java 语言的运行时绑定。</span></br>\r\n\r\n\r\n\r\n### 2、“初始化”的时机\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述:</span>   Java 虚拟机规范没有强制约束类加载过程的第一阶段（即：加载）什么时候开始，但对于“初始化”阶段，有着严格的规定。有且仅有 5 种情况必须立即对类进行“初始化”：\r\n\r\n- 在遇到 new、putstatic、getstatic、invokestatic 字节码指令时，如果类尚未初始化，则需要先触发其初始化。\r\n- 对类进行反射调用时，如果类还没有初始化，则需要先触发其初始化。\r\n- 初始化一个类时，如果其父类还没有初始化，则需要先初始化父类。\r\n- 虚拟机启动时，用于需要指定一个包含 `main()` 方法的主类，虚拟机会先初始化这个主类。\r\n- 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类还没初始化，则需要先触发其初始化。\r\n\r\n这 5 种场景中的行为称为对一个类进行**主动引用**，除此之外，其它所有引用类的方式都不会触发初始化，称为**被动引用**。\r\n\r\n\r\n\r\n#### a、被动引用Demo1\r\n\r\n```java\r\n/**\r\n * 被动引用 Demo1:\r\n * 通过子类引用父类的静态字段，不会导致子类初始化。\r\n *\r\n * @author Ryan丶璟芮\r\n *\r\n */\r\nclass SuperClass {\r\n    static {\r\n        System.out.println(\"SuperClass init!\");\r\n    }\r\n\r\n    public static int value = 123;\r\n}\r\n\r\nclass SubClass extends SuperClass {\r\n    static {\r\n        System.out.println(\"SubClass init!\");\r\n    }\r\n}\r\n\r\npublic class NotInitialization {\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(SubClass.value);\r\n        // SuperClass init!\r\n    }\r\n\r\n}\r\n```\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">注：</span>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。\r\n\r\n#### b、被动引用Demo2\r\n\r\n```java\r\n/**\r\n * 被动引用 Demo2:\r\n * 通过数组定义来引用类，不会触发此类的初始化。\r\n *\r\n * @author Ryan丶璟芮\r\n *\r\n */\r\n\r\npublic class NotInitialization {\r\n\r\n    public static void main(String[] args) {\r\n        SuperClass[] superClasses = new SuperClass[10];\r\n    }\r\n\r\n}\r\n```\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">注：</span>这段代码不会触发父类的初始化，但会触发“[L 全类名”这个类的初始化，它由虚拟机自动生成，直接继承自 java.lang.Object，创建动作由字节码指令 newarray 触发。\r\n\r\n#### c、被动引用Demo3\r\n\r\n```java\r\n/**\r\n * 被动引用 Demo3:\r\n * 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。\r\n *\r\n * @author Ryan丶璟芮\r\n *\r\n */\r\nclass ConstClass {\r\n    static {\r\n        System.out.println(\"ConstClass init!\");\r\n    }\r\n\r\n    public static final String HELLO_RYAN = \"Hello Ryan\";\r\n\r\n}\r\n\r\npublic class NotInitialization {\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(ConstClass.HELLO_RYAN);\r\n    }\r\n\r\n}\r\n```\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">注：</span>编译通过之后，常量存储到 NotInitialization 类的常量池中，NotInitialization 的 Class 文件中并没有 ConstClass 类的符号引用入口，这两个类在编译成 Class 之后就没有任何联系了。\r\n\r\n\r\n\r\n### 3、接口加载过程\r\n\r\n接口加载过程与类加载过程稍有不同。\r\n\r\n<span style=\"border-bottom: 2px solid #0081EF;color:#FC5531;\">当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，当真正用到父接口的时候才会初始化。</span>\r\n\r\n## 三、类加载器\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">类加载器</span> 主要分为三类：<span style=\"color:#FC5531; font-weight:bold;\">启动类加载器、扩展类加载器</span> 和 <span style=\"color:#FC5531; font-weight:bold;\">应用程序加载器</span>\r\n\r\n![image-20210411182803704](/amWiki/images/lib_img/image-20210411182803704.png)\r\n\r\n---\r\n\r\n![image-20210411165727903](amWiki/images/lib_img/image-20210411165727903.png)\r\n\r\n\r\n\r\n### 1、启动类加载器\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">启动类加载器（Bootstrap ClassLoader）：</span>\r\n\r\n<span style=\"border-bottom: 2px solid #0081EF;\">负责将存放在 <JAVA_HOME>\\lib 目录中的，并且能被虚拟机识别的（仅按照文件名识别，如 rt.jar</span></br>\r\n\r\n<span style=\"border-bottom: 2px solid #0081EF;\">名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。</span></br>\r\n\r\n### 2、扩展类加载器\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">扩展类加载器（Extension ClassLoader）：</span>\r\n\r\n <span style=\"border-bottom: 2px solid #0081EF;\">负责加载 `<JAVA_HOME>\\lib\\ext` 目录中的所有类库，开发者可以直接使用扩展类加载器。</span></br>\r\n\r\n### 3、应用程序类加载器\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">应用程序类加载器（Application ClassLoader）： </span>\r\n\r\n<span style=\"border-bottom: 2px solid #0081EF;\">由于这个类加载器是 ClassLoader 中的 `getSystemClassLoader()` 方法的返回值</span></br>\r\n\r\n<span style=\"border-bottom: 2px solid #0081EF;\">所以一般也称它为“系统类加载器”。它负责加载用户类路径（classpath）上所指定的类库</span></br>\r\n\r\n<span style=\"border-bottom: 2px solid #0081EF;\">开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器</span></br>\r\n\r\n<span style=\"border-bottom: 2px solid #0081EF;\">一般情况下这个就是程序中默认的类加载器。</span></br>\r\n\r\n\r\n\r\n### 4、双亲委派\r\n\r\n#### a 、简述\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">双亲委派模型</span> 是描述类加载器之间的层次关系。它要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。（父子关系一般不会以继承的关系实现，而是以组合关系来复用父加载器的代码）\r\n\r\n\r\n\r\n#### b、工作过程\r\n\r\n~~~java\r\n//类加载过程\r\n\r\n public Class<?> loadClass(String name) throws ClassNotFoundException {\r\n        return loadClass(name, false);\r\n    }\r\n\r\n protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException\r\n\r\n    {\r\n\t\t    // 首先判断该类型是否已经被加载\r\n\t\t    Class c = findLoadedClass(name);\r\n\t\t    if (c == null) {\r\n\t\t    //没有被加载，就委托给父类加载器或者委派给启动类加载器加载\r\n\r\n    try {\r\n\t\t    if (parent != null) {\r\n\t\t    // 如果存在父类加载器，就委派给父类加载器加载\r\n\t\t    c = parent.loadClass(name, false);\r\n\t\t    } else {\r\n\t\t        // 如果不存在父类加载器，就检查是否是由启动类加载器加载的类\r\n\t\t        c = findBootstrapClassOrNull(name);\r\n\t\t    }\r\n        } catch (ClassNotFoundException e) {\r\n        }\r\n\r\n      if (c == null) {\r\n        // 如果父类加载器和启动类加载器都不能完成加载任务，调用自身的加载工程\r\n        c = findClass(name);\r\n    }\r\n\r\n}\r\n\r\n    if (resolve) {\r\n        resolveClass(c);\r\n    }\r\n\r\nreturn c;\r\n\r\n }\r\n\r\n~~~\r\n\r\n如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（找不到所需的类）时，子加载器才会尝试自己去加载。\r\n\r\n在 java.lang.ClassLoader 中的 `loadClass` 方法中实现该过程。\r\n\r\n\r\n\r\n#### c、存在背景\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">为什么使用双亲委派模型？</span>\r\n\r\n像 java.lang.Object 这些存放在 rt.jar 中的类，无论使用哪个类加载器加载，最终都会委派给最顶端的启动类加载器加载，从而使得不同加载器加载的 Object 类都是同一个。\r\n\r\n相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在 classpath 下，那么系统将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证。\r\n\r\n\r\n\r\n## 附录\r\n\r\n### 面试经\r\n\r\n1、所有new出来的对象都在堆上嘛？\r\n\r\n2、什么是逃逸分析\r\n\r\n3、双亲委派机制原理、可以打破该机制嘛？how？\r\n\r\n### 参考\r\n\r\n👉 [常见JVM面试题及答案整理_Java笔记-CSDN博客_jvm面试题](https://blog.csdn.net/qq_41701956/article/details/100074023)\r\n","timestamp":1642514536573},{"name":"04-内存分配策略.md","path":"02-java篇/02-技术栈/02-jvm/04-内存分配策略.md","content":"# 内存分配策略\r\n\r\n> 本文所有内容基于: <span style=\"color:#42B983;font-weight:bold;\">HotSpot    jdk1.8</span>\t\r\n>\r\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2021年4月8日09:38:04</span>\r\n\r\n## 一、内存分配\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">对象的内存分配 :</span>  <span style=\"color:#FC5531; font-weight:bold;\">三大原则</span> 和 <span style=\"color:#FC5531; font-weight:bold;\">担保机制</span>\r\n\r\n* 就是在  <span style=\"color:#FC5531; font-weight:bold;\">堆上分配</span>（<span style=\"border-bottom: 2px solid #0081EF;\">也可能经过 JIT 编译后被拆散为标量类型并间接在栈上分配</span>）\r\n* 对象主要分配在新生代的 Eden 区上，少数情况下可能直接分配在老年代，\r\n* **分配规则不固定**，取决于当前使用的垃圾收集器组合以及相关的参数配置。\r\n\r\n![image-20210417150625369](amWiki/images/lib_img/image-20210417150625369.png)\r\n\r\n\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">注：</span> 内存分配主要是在堆上的分配，上述各个模块详见   **jvm内存结构**\r\n\r\n\r\n\r\n### 1、原则一 对象优先在Eden上分配\r\n\r\n大多数情况下，对象在新生代 Eden 区中分配。</br>\r\n\r\n👇**Minor GC** vs **Major GC**/**Full GC**：</br>\r\n\r\n- <span style=\"color:#FC5531; font-weight:bold;\">Minor GC：</span>回收新生代（包括 Eden 和 Survivor 区域），因为 Java 对象大多都具备朝生夕灭的特性</br>\r\n\r\n  所以 Minor GC 非常频繁，一般回收速度也比较快。</br>\r\n\r\n- <span style=\"color:#FC5531; font-weight:bold;\">Major GC / Full GC: </span>回收老年代，出现了 Major GC，经常会伴随至少一次的 Minor GC</br>\r\n\r\n  但这并非绝对。Major GC 的速度一般会比 Minor GC 慢 10 倍 以上。</br>\r\n\r\n> 在 JVM 规范中，Major GC 和 Full GC 都没有一个正式的定义，所以有人也简单地认为 Major GC 清理老年代，而 Full GC 清理整个内存堆。\r\n\r\n\r\n\r\n大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。我们来进行实际测试一下。实例代码如下：\r\n\r\n~~~java\r\n/**\r\n * @Description: 对象优先在eden区分配 \r\n *      -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails -XX:SurvivorRatio=8 -verbose:gc \r\n * @Author: Ryan丶璟芮 \r\n * @Date: 2021年4月12日10:12:30\r\n * @Blog: ryanc-site.gitee.io\r\n */\r\npublic class EdenAllocateFirstTest {\r\n    public static final int _1M = 1024 * 1024;\r\n\r\n    public static void main(String[] args) {\r\n        byte[] a1, a2, a3;\r\n        a1 = new byte[2 * _1M];\r\n        a2 = new byte[2 * _1M];\r\n\r\n        // 为a3分配内存之前会进行一次Minor GC ，默认占用了2MB多的空间，同时a1和a2进入\r\n        // 老年代，Minor GC完后，将a3在eden区分配，可以看到eden占用了25%，也就是2MB\r\n        // a3 = new byte[2 * _1M];\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n这里通过-Xmn参数指定了年轻代的大小为10MB，同时指定Eden区与两个Servivor区的比例为8:1:1</br>\r\n那么Eden区为8MB,两个Servivor区大小为1MB.需要注意的是即使什么也不做也会占用大概2.24MB的空间</br>\r\n运行打印输入如下：</br> \r\n\r\n![image-20210417152933296](amWiki/images/lib_img/image-20210417152933296.png)\r\n\r\n:mag_right: <span style=\"color:#FC5531; font-weight:bold;\">注：</span>这里我设置新生代是10M 为啥这里答应出来是9216k（9M）？(考察点：复制算法原理)\r\n\r\n可以看到只有Eden区空间占用了58%，也就是6.24MB,其中a1和a2分别总共占用了4MB,而维持程序运行占用了2.24MB,都分配到了Eden区。接下来我们再为a3分配空间，如下：\r\n\r\n~~~java\r\n/**\r\n * @Description: 对象优先在eden区分配 \r\n *      -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails -XX:SurvivorRatio=8 -verbose:gc \r\n * @Author: Ryan丶璟芮 \r\n * @Date: 2021年4月12日10:12:30\r\n * @Blog: ryanc-site.gitee.io\r\n */\r\npublic class EdenAllocateFirstTest {\r\n    public static final int _1M = 1024 * 1024;\r\n\r\n    public static void main(String[] args) {\r\n        byte[] a1, a2, a3;\r\n        a1 = new byte[4 * _1M];\r\n        a2 = new byte[2 * _1M];\r\n\r\n        // 为a3分配内存之前会进行一次Minor GC ，默认占用了2MB多的空间，同时a1和a2进入\r\n        // 老年代，Minor GC完后，将a3在eden区分配，可以看到eden占用了25%，也就是2MB\r\n        a3 = new byte[2 * _1M];\r\n    }\r\n}\r\n~~~\r\n\r\n运行结果如下：\r\n\r\n![image-20210417153643768](amWiki/images/lib_img/image-20210417153643768.png)\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">简单说明 : </span>进行一次GC，这是因为在a1和a2分配完后，Eden区剩余的空间不足2MB</br>\r\n不足以容纳a3，所以触发了Minor GC</br>\r\n\r\n\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">面试经</span> 为什么老年代的内存空间占用了62%，也就是6MB?\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">解惑 ：</span>这是因为在发生Minor GC后,a1和a2都还存活,但是一个Servivor的大小为1MB,不足以容纳a1和a2</br>\r\n所以在Minor GC完后,Survivor区放不下的对象直接放入老年代,但是Survivor仍占用了大约0.7MB的空间</br>\r\n就是上面说的JVM自己创建的一些对象,回收后还剩大约0.7MB,此时Eden却占用了大于2MB多</br>\r\n就是为a3分配的空间。</br>\r\n\r\n\r\n\r\n### 2、原则二 大对象直入老年代\r\n\r\n大对象是指需要大量连续内存空间的 Java 对象，如很长的字符串或数据。</br>\r\n一个大对象能够存入 Eden 区的概率比较小，发生分配担保的概率比较大，而分配担保需要涉及大量的复制</br>\r\n就会造成效率低下。</br>\r\n\r\n虚拟机提供了一个<span style=\"color:#42B983;font-weight:bold;\"> -XX:PretenureSizeThreshold</span> 参数，令大于这个设置值的对象直接在老年代分配</br>\r\n这样做的目的是避免在Eden区及两个Survivor 区之间发生大量的内存复制(新生代采用 <span style=\"color:#42B983;font-weight:bold;\">复制算法</span> 回收垃圾)</br>\r\n在启动JVM参数加上<span style=\"color:#42B983;font-weight:bold;\">-XX:+UseConcMarkSweepGC </span>，这个参数表示对于老年代的回收采用CMS。</br>\r\n\r\n我们通过一个实例加深对该参数的理解：\r\n\r\n~~~java\r\n/** @Description: 大对象直接进入老年代\r\n *  -verbose:gc -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails -XX:SurvivorRatio=8 \r\n *  -XX:PretenureSizeThreshold=3145728 -XX:+UseConcMarkSweepGC\r\n * @Author: Ryan丶璟芮\r\n * @Date: 2021年4月12日10:12:30\r\n * @Blog: ryanc-site.gitee.io\r\n */\r\npublic class BigObjectAllocateTest {\r\n    public static final int _1M = 1024 * 1024;\r\n    public static void main(String[] args) {\r\n        byte[] a1;\r\n        // 大对象直接在老年代分配\r\n        a1 = new byte[4 * _1M];\r\n    }\r\n}\r\n~~~\r\n\r\n运行结果如下：\r\n\r\n![image-20210417154238413](amWiki/images/lib_img/image-20210417154238413.png)\r\n\r\n通过日志可以看到，老年代占用了40%的空间，也就是4MB\r\n当然年轻代也占用了大约1MB不到的空间，这是程序运行占用的空间。\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">需要说明的是 : </span>**-XX:PretenureSizeThreshold参数只对Serial和ParNew两款新生代收集器有效，**\r\n**所以这里使用-XX:+UseConcMarkSweepGC参数指定老年代使用CMS垃圾收集器，**\r\n**那么默认的新生代会使用ParNew收集器**。\r\n\r\n当你把 -XX:+UseConcMarkSweepGC这个参数去掉后JDK模式使用Parallel Scavenge，那么这个参数就失效了，a1会直接在Eden区分配(JDK1.8 默认使用的是Parallel Scavenge)，日志如下：\r\n\r\n![image-20210417154349321](amWiki/images/lib_img/image-20210417154349321.png)\r\n\r\n### 3、原则三 长期存活对象直入老年代\r\n\r\nJVM 给每个对象定义了一个对象年龄计数器。<span style=\"border-bottom: 2px solid #0081EF;\">当新生代发生一次 Minor GC 后，存活下来的对象年龄 +1</span></br>\r\n当年龄超过一定值时，就将超过该值的所有对象转移到老年代中去。</br>\r\n使用<span style=\"color:#42B983;font-weight:bold;\"> -XXMaxTenuringThreshold</span> 设置新生代的最大年龄，只要超过该参数的新生代对象都会被转移到老年代中去。</br>\r\n\r\n对象在 Survivor 中每熬过一次 MinorGC，年龄就增加1岁，当它的年龄增加到一定程度(默认为15岁)</br>\r\n就会被晋升到老年代中。对象晋升到老年代的年龄阈值可以通过参数 -XX:MaxTenuringThreshold 来设置</br>\r\n接下来通过指定<span style=\"color:#42B983;font-weight:bold;\"> -XX:MaxTenuringThreshold=1</span>和 <span style=\"color:#42B983;font-weight:bold;\"> -XX:MaxTenuringThreshold=15</span>来测试</br>\r\n\r\n示例代码如下：\r\n\r\n~~~java\r\n/**\r\n *  @Description: 长期存活的对象进入老年代\r\n *  -Xms60m -Xmx60m -Xmn20m -XX:+PrintGCDetails -XX:SurvivorRatio=8 \r\n *  -verbose:gc -XX:PretenureSizeThreshold=20971520\r\n *  -XX:+UseConcMarkSweepGC -XX:MaxTenuringThreshold=1\r\n * @Author: Ryan丶璟芮\r\n * @Date: 2021年4月12日10:12:30\r\n * @Blog: ryanc-site.gitee.io\r\n */\r\npublic class LongTermSurvivalTest {\r\n    public static final int _1M = 1024 * 1024;\r\n    public static void main(String[] args) {\r\n        byte[] a1, a2, a3;\r\n        // 2.88m\r\n        a1 = new byte[_1M / 4];\r\n        a2 = new byte[8 * _1M];\r\n        a3 = new byte[8 * _1M];\r\n        a3 = null;\r\n        a3 = new byte[8 * _1M];\r\n    }\r\n}\r\n~~~\r\n\r\n首先将-XX:MaxTenuringThreshold=1运行结果如下：\r\n\r\n![image-20210417154634457](amWiki/images/lib_img/image-20210417154634457.png)\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">分述1：</span>首先来看一下参数设置，Eden区为16MB,两个Survivor区分别为2MB，老年区为40MB。</br>\r\n在为a3分配之前，Eden区空间已经不足以容纳a3，所以触发了一次Minor GC</br>\r\n通过日志可以看到第一次Minor GC完成后年轻代还有538K占用，而总内存占用8733K:</br>\r\n\r\n![image-20210417154908966](amWiki/images/lib_img/image-20210417154908966.png)\r\n\r\n\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">分述2：</span>所以a2不再年轻代，而是直接进入老年代，这是由于Survivor区放不下a2的原因</br>\r\n在第一Minor GC完后此时a1(当然还包括程序创建的一些对象)的分代年龄为1</br>\r\n那么将a3置为空并且再次分配时此时又触发了一下Minor GC,这里Minor GC完后年轻代的占用接近0k:</br>\r\n\r\n![image-20210417155000042](amWiki/images/lib_img/image-20210417155000042.png)\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">分述3：</span>这是因为a1及其他对象分代年龄超过了设置的阈值，直接晋升到了老年代，所以年轻代为0K，然后将a3再次分配，年轻代又有了8MB的占用空间。接下来将分代年龄的阈值设置为15,运行结果如下：\r\n\r\n![image-20210417155108133](amWiki/images/lib_img/image-20210417155108133.png)\r\n\r\n通过这次的运行结果可以看到老年代只有a2占用的8MB空间，并且在第二次Minor GC完成后年轻化仍有空间占用：\r\n\r\n![image-20210417155152548](amWiki/images/lib_img/image-20210417155152548.png)\r\n\r\n### 动态对象年龄判定\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\"> 简单说明：</span>当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)</br>\r\n一批对象的总大小大于这块Survivor区域内存大小的50%，那么此时大于等于这批对象年龄**最大值**的对象</br>\r\n就可以直接进入老年代了</br>\r\n\r\n\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\"> 实例说明:</span>Survivor区域里现在有一批对象,年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%</br>\r\n此时就会把年龄n及以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活 的对象</br>\r\n尽早进入老年代。**对象动态年龄判断机制一般是在Minor GC之后触发的**。来通过示例来查看：</br>\r\n\r\n~~~java\r\n/**\r\n * @Description: 动态年龄判断\r\n * -Xms60m -Xmx60m -Xmn20m -XX:+PrintGCDetails -XX:SurvivorRatio=8 -verbose:gc\r\n * -XX:MaxTenuringThreshold=15 -XX:+UseConcMarkSweepGC\r\n * @Author: Ryan丶璟芮\r\n * @Date: 2021年4月12日10:12:30\r\n * @Blog: ryanc-site.gitee.io\r\n */\r\npublic class DynamicAgeJudgmentTest {\r\n    public static final int _1MB = 1024 * 1024;\r\n\r\n    public static void main(String[] args) {\r\n        // 2.88M\r\n        byte[] a1, a2, a3, a4;\r\n        a1 = new byte[_1MB / 4];\r\n        a2 = new byte[_1MB / 4];\r\n        a3 = new byte[8 * _1MB];\r\n        a4 = new byte[8 * _1MB];\r\n        a4 = null;\r\n        a4 = new byte[8 * _1MB];\r\n    }\r\n}\r\n~~~\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">分述1：</span>这里年轻代的收集还是使用的ParNew，其中Eden区空间为16MB，两个Survivor区占用2MB的空间</br>\r\n运行输出日志如下：\r\n\r\n![image-20210417155300320](amWiki/images/lib_img/image-20210417155300320.png)\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">分述2：</span>可以通过内存占用情况知道，Eden区占用51%是a4的第二次分配占用的空间，而Survivor区占用为29%</br>\r\n通过收集日志知道：\r\n![image-20210417160105613](amWiki/images/lib_img/image-20210417160105613.png)\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">分述3：</span>第一次Minor GC完之后，年轻代占用空间为789k，包括a1和a2总共大约0.5MB，而a3在第一次Minor GC后直接进入了老年代(Survivor区放不下)。在第二次Minor GC后a1和a2及其他的对象分代年龄相同，并且占用空间大于一个Survivor区的52%,所以对象直接进入了老年代，这可以解释Survivor区可以容下a1和a2等对象，但最终Survivor区占用为5。\r\n\r\n\r\n\r\n### 空间分配担保\r\n\r\n年轻代每次Minor GC之前JVM都会计算下老年代剩余可用空间，如果这个可用空间小于年轻代里现有的所有对象大小之和(包括垃圾对象)， 就会看一个-XX:-HandlePromotionFailure(jdk1.8默认就设置了)的参数是否设置，如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次Minor GC后进入老年代的对象的平均大小。如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full gc，对老年代和年轻代一起回收一次垃圾，如果回收完还是没有足够空间存放 新的对象就会发生\"OOM\" 。当然，如果Minor GC之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发Full GC，Full GC完之后如果还是没有空间放Minor GC之后的存活对象，则也会发生“OOM”。\r\n\r\n> <span style=\"color:#FC5531; font-weight:bold;\">注意：</span>老年代空间担保机制是在每次minor gc之前进行的判断。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/9306dd113fc7b649d889cff2694499e7.png)\r\n\r\n## 附录\r\n\r\n### 面试经\r\n\r\n\r\n\r\n### 参考\r\n\r\n👉 [jvm中对象创建与内存分配机制_JVM分析——内存分配机制_weixin_39530437的博客-CSDN博客](https://blog.csdn.net/weixin_39530437/article/details/110608913)\r\n\r\n","timestamp":1642514536573},{"name":"05-垃圾回收策略与算法.md","path":"02-java篇/02-技术栈/02-jvm/05-垃圾回收策略与算法.md","content":"# jvm垃圾回收策略与算法\r\n\r\n> 本文所有内容基于: <span style=\"color:#42B983;font-weight:bold;\">HotSpot    jdk1.8</span>\t\r\n>\r\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2021年4月12日15:22:54</span>\r\n\r\n## 一、概述\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">程序计数器、虚拟机栈、本地方发栈</span>这三个区域都是<span style=\"border-bottom: 2px solid #0081EF;color:#FC5531;\">线程独有的，随线程而生，也随线程而灭</span>；</br>\r\n<span style=\"border-bottom: 2px solid #0081EF;\">栈帧随着方法的开始而入栈，随着方法的结束而出栈</span>。这几个区域的内存分配和回收都具备确认性</br>\r\n在这几个区域内不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了</br>\r\n\r\n而对于 Java 堆和方法区，我们只有在程序运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的正是这部分内存。\r\n\r\n:mag_right:  哪些内存需要进行回收：<span style=\"color:#FC5531; font-weight:bold;\">Java 堆和方法区。</span>\r\n\r\n\r\n\r\n## 二、判定对象是否存活\r\n\r\n:anchor: <span style=\"color:#FC5531; font-weight:bold;\">什么时候回收对象</span> 若一个对象不被任何对象或变量引用，那么它就是无效对象，需要被回收\r\n\r\n### 1、引用计数法\r\n\r\n> <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px\">这里笔者只做概念性的介绍，深入性的研究单独开专题探讨</span>\r\n\r\n 在对象头维护着一个 引用计数器，对象被引用一次则计数器 +1；若引用失效则计数器 -1。\r\n当计数器为 0 时，就认为该对象无效了。\r\n\r\n\r\n引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法。\r\n但是主流的 Java 虚拟机里没有选用引用计数算法来管理内存\r\n\r\n:mag_right:  主要是因为它很难解决对象之间循环引用的问题。\r\n\r\n~~~java\r\n/*-- 背景 --*/\r\n// 对象objA 和 objB 都有字段 name\r\n// 两个对象相互进行引用，除此之外这两个人对象没有任何引用\r\nMyObject objA = new MyObject();// 内含一个name属性\r\nMyObject objB = new MyObject();\r\n\r\nobjA.name = objB；\r\nobjB.name = objA；\r\n\r\nobjA = null；\r\nobjB = null；\r\n\r\n/*-- 问题 --*/\r\n// 实际上这两个对象已经不可能再被访问，应该要被垃圾收集器进行回收\r\n// 但因为他们相互引用，所以导致计数器不为0，这导致引用计数算法无法通知垃圾收集器回收该两个对象\r\n~~~\r\n\r\n**引用计数法的特点：**\r\n\r\n-   需要单独的字段存储计数器，增加了存储空间的开销；\r\n-   每次赋值都需要更新计数器，增加了时间开销；\r\n-   垃圾对象便于辨识，只要计数器为0，就可作为垃圾回收；\r\n-   及时回收垃圾，没有延迟性；\r\n-   不能解决循环引用的问题；\r\n\r\n\r\n\r\n\r\n\r\n### 2、可达性分析（主流）\r\n\r\n> <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px\">这里笔者只做概念性的介绍，深入性的研究单独开专题探讨</span>\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述：</span>在Java中，是通过可达性分析（Reachability Analysis）来判定对象是否存活的。</br>\r\n该算法的基本思路就是通过一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索</br>\r\n搜索走过的路径被称为（Reference Chain)，当一个对象到GC Roots没有任何引用链相连时</br>\r\n(即从GC Roots节点到该节点不可达)，则证明该对象是不可用的。</br>\r\n\r\n**GC Roots 是指：**\r\n\r\n- Java 虚拟机栈（栈帧中的本地变量表）中引用的对象\r\n- 本地方法栈中引用的对象\r\n- 方法区中常量引用的对象\r\n- 方法区中类静态属性引用的对象\r\n\r\n<span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px\">GC Roots 并不包括堆中对象所引用的对象，这样就不会有循环引用的问题。</span>\r\n\r\n\r\n\r\n## 三、引用类型\r\n\r\n> <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px\">这里笔者只做概念性的介绍，深入性的研究单独开专题探讨</span>\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述：</span> 判定对象是否存活与“引用”有关。在 JDK 1.2 以前，Java 中的引用定义很传统</br>\r\n一个对象只有被引用或者没有被引用两种状态，\r\n\r\n* <span style=\"border-bottom: 2px solid #0081EF;\">当内存空间还足够时，则保留在内存中；</span>\r\n\r\n* <span style=\"border-bottom: 2px solid #0081EF;\">如果内存空间在进行垃圾手收集后还是非常紧张，则可以抛弃这些对象。</span>\r\n\r\n  很多系统的缓存功能都符合这样的应用场景。\r\n\r\n在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为了以下四种。\r\n不同的引用类型，主要体现的是对象不同的可达性状态reachable和垃圾收集的影响。\r\n\r\n### 1、强引用（S-R）\r\n\r\n类似 \"Object obj = new Object()\" 这类的引用，就是强引用，\r\n\r\n* <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">只要强引用存在垃圾收集器永远不会回收被引用的对象。</span>\r\n\r\n  但是，如果我们错误地保持了强引用</br>\r\n  比如：赋值给了 static 变量，那么对象在很长一段时间内不会被回收，会产生内存泄漏。</br>\r\n\r\n* <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">宁愿出现内存溢出，也不会回收这些对象。</span></br>\r\n\r\n~~~java\r\n/**\r\n * java 中的强引用\r\n *\r\n * @author Ryan丶璟芮\r\n * @since 2021-01-05\r\n */\r\npublic class StrongRef {\r\n    public static void main(String[] args) throws Exception {\r\n        M m = new M();\r\n        m = null;\r\n//        System.gc();\r\n        System.out.println(\"m = \" + m);\r\n        TimeUnit.SECONDS.sleep(3);\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n### 2、软引用(Soft-R)\r\n\r\n软引用是一种相对强引用弱化一些的引用\r\n\r\n* <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象</span>\r\n\r\nJVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。\r\n\r\n* <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">软引用通常用来实现内存敏感的缓存</span>\r\n\r\n如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。比如网页缓存、图片缓存等。\r\n\r\n~~~ java\r\n/**\r\n * java 中的软引用\r\n *\r\n * @author Ryan丶璟芮\r\n * @since 2021-01-05\r\n */\r\npublic class SoftRef {\r\n    public static void main(String[] args) throws Exception {\r\n        // 开辟一个10M的空间\r\n        SoftReference<byte[]> sr1 = new SoftReference<>(new byte[1024 * 1024 * 5]);\r\n        SoftReference<byte[]> sr2 = new SoftReference<>(new byte[1024 * 1024 * 5]);\r\n//        softM = null;\r\n\r\n        System.out.println(\"sr1\" + sr1.get());\r\n        System.out.println(\"sr2\" + sr2.get());\r\n        System.gc();\r\n        TimeUnit.MILLISECONDS.sleep(500);\r\n        System.out.println(\"sr1\" + sr1.get());\r\n        System.out.println(\"sr2\" + sr2.get());\r\n\r\n        // 再分配一个15M的空间，然后在从软引用中获取内容\r\n        byte[] b = new byte[1024 * 1024 * 11];\r\n        System.out.println(\"sr1\" + sr1.get());\r\n        System.out.println(\"sr2\" + sr2.get());\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n\r\n\r\n### 3、弱引用（W-R）\r\n\r\n弱引用的强度比软引用更弱一些；<span style=\"color:#FC5531; font-weight:bold;\">例：ThreadLocal中的Key </span>\r\n\r\n* <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">被弱引用引用的对象只能生存到下一次垃圾收集前，一旦发生垃圾收集，被弱引用所引用的对象就会被清掉</span>\r\n\r\n~~~ java\r\n/**\r\n * java 中的弱引用\r\n *\r\n * @author Ryan丶璟芮\r\n * @since 2021-01-05\r\n */\r\npublic class WeakRef {\r\n    public static void main(String[] args) {\r\n        M m = new M();\r\n        WeakReference<M> wr = new WeakReference<>(m);\r\n\r\n        System.out.println(wr.get());\r\n        m = null;\r\n        System.gc();\r\n        System.out.println(wr.get());\r\n    }\r\n}\r\n~~~\r\n\r\n> <span style=\"color:#FC5531; font-weight:bold;\">注意：</span>在使用软引用和弱引用的时候，我们可以显示地通过System.gc()来通知JVM进行垃圾回收，但是要注意的是，虽然发出了通知，JVM不一定会立刻执行，也就是说这句是无法确保此时JVM一定会进行垃圾回收的。 \r\n\r\n### 4、虚引用（P-R）\r\n\r\n虚引用也称幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。<span style=\"color:#FC5531; font-weight:bold;\">例：jdk1.4后的nio，直接内存</span>\r\n\r\n* <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">它仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制。</span>\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">注意 : </span>虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\r\n\r\n~~~java\r\n/**\r\n * java 中的虚引用\r\n *\r\n * @author Ryan丶璟芮\r\n * @since 2021-01-06\r\n */\r\npublic class PhantomRef {\r\n\r\n    private static final List<Object> LIST = new LinkedList<>();\r\n    private static final ReferenceQueue<M> QUEUE = new ReferenceQueue<>();\r\n\r\n    public static void main(String[] args) {\r\n        PhantomReference<M> phantomReference = new PhantomReference<>(new M(),QUEUE);\r\n        System.out.println(phantomReference.get());\r\n\r\n        new Thread(()->{\r\n            while (true) {\r\n                LIST.add(new byte[1024*512]);\r\n                try {\r\n                    TimeUnit.MILLISECONDS.sleep(500);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                System.out.println(phantomReference.get());\r\n            }\r\n        }).start();\r\n\r\n        new Thread(()->{\r\n            while (true){\r\n                Reference<? extends M> poll = QUEUE.poll();\r\n                if (null != poll) {\r\n                    System.out.println(\"phantomRef  被jvm回收了\" +poll);\r\n                }\r\n            }\r\n        }).start();\r\n\r\n\r\n        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1024);\r\n    }\r\n\r\n}\r\n~~~\r\n\r\n## 四、对象死亡的两次标记\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述：</span> 即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段</br>\r\n要真正宣告一个对象死亡，至少要经历再次标记过程。标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。\r\n\r\n* **第一次标记 & 筛选**\r\n\r\n  在对象可达性算法不可达时，进行第一次标记，并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize方法或者该方法被虚拟机调用过，虚拟机将这两种情况视为“没有必要去执行”。\r\n\r\n  如果该对象被判定为有必要执行finalize()方法，那么这个对象会被放置到一个叫做F-Queue的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalize线程去执行它。这里所谓的执行就是去触发该方法，但是并不会承诺等待它执行结束，这样做的原因是，如果对象在finalize()方法中执行缓慢，或者发生死循环，将会导致整个队列中的对象处于等待之中。\r\n\r\n* **第二次标记**\r\n\r\n  finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中拯救自己——只要重新与引用链上的一个对象重新建立关联即可，譬如将自己（this关键字）赋值给某个类变量或者成员变量，那么在第二次标记的时候就会被移除“即将回收”的集合；如果对象这时候还没有逃脱，那么就会被真的回收了！\r\n\r\n\r\n\r\n~~~java\r\npublic class FinalizeEscapeGC {\r\n    public static FinalizeEscapeGC SAVE_HOOK = null;\r\n\r\n    public void isAlive(){\r\n        System.out.println(\"yes, i am still alive!\");\r\n    }\r\n    @Override\r\n    public void finalize() throws Throwable {\r\n        super.finalize();\r\n        System.out.println(\"finalize method executed!\");\r\n        FinalizeEscapeGC.SAVE_HOOK = this;\r\n    }\r\n    public static void main(String[] args) throws InterruptedException {\r\n        SAVE_HOOK = new FinalizeEscapeGC();\r\n\r\n        //对象第一次拯救自己\r\n        SAVE_HOOK = null;\r\n        System.gc();\r\n        //因为finalize方法优先级很低所以暂停0.5秒等待\r\n        Thread.sleep(500);\r\n        if(SAVE_HOOK != null){\r\n            SAVE_HOOK.isAlive();\r\n        }else{\r\n            System.out.println(\"no, i am dead!\");\r\n        }\r\n\r\n        //对象第二次拯救自己，但是自救失败了\r\n        SAVE_HOOK = null;\r\n        System.gc();\r\n        //因为finalize方法优先级很低所以暂停0.5秒等待\r\n        Thread.sleep(500);\r\n        if(SAVE_HOOK != null){\r\n            SAVE_HOOK.isAlive();\r\n        }else{\r\n            System.out.println(\"no, i am dead!\");\r\n        }\r\n\r\n    }\r\n}\r\n\r\n//执行结果：\r\n/* \r\n    finalize method executed!\r\n    yes, i am still alive!\r\n    no, i am dead!\r\n*/\r\n~~~\r\n\r\n## 五、方法区回收\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述：</span> 方法区中存放生命周期较长的类信息、常量、静态变量，每次垃圾收集只有少量的垃圾被清除。方法区中主要清除两种垃圾：\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">废弃常量：</span>例如一个“abc”字符串常量存在常量池中，但没有任何String类型对象引用常量池中的这个常量，也没有其它地方引用了这个常量，如果必要的话，这个常量也会被系统清理出常量池；常量池中的其他类（接口）、方法、字段的符号引用也与此类似\r\n* <span style=\"color:#FC5531; font-weight:bold;\">无用的类：</span>同时满足以下 3 个条件的类。\r\n  * 该类的所有实例已被回收，Java 堆中不存在该类的任何实例；\r\n  * 加载该类的 Classloader 已被回收；\r\n  * 该类的 Class 对象没有被任何地方引用，即无法在任何地方通过反射访问该类的方法。\r\n\r\n\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">注意：</span>\r\n\r\n* <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;\">虚拟机是可以对满足上述3个条件的类进行回收，仅仅是“可以”，并不是和对象一样，不使用了就必然回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制</span>\r\n* <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;\">在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</span>\r\n\r\n\r\n\r\n## 六、垃圾回收算法\r\n\r\n### 1、标记 - 清除算法\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">标记：</span>遍历所有的 GC Roots，然后将所有 GC Roots 可达的对象标记为存活的对象。\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">清除：</span>将遍历堆中所有的对象，将没有标记的对象全部清除掉。与此同时，清除那些被标记过的对象的标记，以便下次的垃圾回收。\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">不足：</span>\r\n\r\n* 效率问题：<span style=\" font-weight:bold;border-bottom:1px dashed #0081EF; height:50px;width:350px;\">标记和清除两个过程的效率都不高。</span>\r\n* 空间问题：<span style=\" font-weight:bold;border-bottom:1px dashed #0081EF; height:50px;width:350px;\">标记清除之后会产生大量不连续的内存碎片，碎片太多可能导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</span>\r\n\r\n![image-20210417160412563](amWiki/images/lib_img/image-20210417160412563.png)\r\n\r\n\r\n\r\n### 2、复制算法（新生代）\r\n\r\n为了解决**效率问题**，“复制”收集算法出现了。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完，需要进行垃圾收集时，就将存活者的对象复制到另一块上面，然后将第一块内存全部清除。这种算法有优有劣：\r\n\r\n- <span style=\"color:#42B983;font-weight:bold;\">优点：</span>不会有内存碎片的问题。\r\n- <span style=\"color:#FC5531; font-weight:bold;\">缺点：</span>内存缩小为原来的一半，浪费空间。\r\n\r\n![image-20210417160331713](amWiki/images/lib_img/image-20210417160331713.png)\r\n\r\n:mag_right:  为了解决空间利用率问题</br>\r\n\r\n* 可以将内存分为三块： Eden、From Survivor、To Survivor，比例是 8:1:1，每次使用 Eden 和其中一块 Survivor。\r\n\r\n* 回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才使用的 Survivor 空间。\r\n\r\n这样只有 10% 的内存被浪费。但是我们无法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够，需要依赖其他内存（指老年代）进行分配担保\r\n\r\n\r\n\r\n### 3、标记-整理算法（老年代）\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">标记：</span>它的第一个阶段与标记/清除算法是一模一样的，均是遍历 GC Roots，然后将存活的对象标记。</br>\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">整理：</span>移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。</br>\r\n\r\n这是一种老年代的垃圾收集算法。老年代的对象一般寿命比较长，因此每次垃圾回收会有大量对象存活，如果采用复制算法，每次需要复制大量存活的对象，效率很低。</br>\r\n\r\n![image-20210417160348554](/amWiki/images/lib_img/image-20210417160348554.png)\r\n\r\n### 4、分代收集算法\r\n\r\n根据对象存活周期的不同，将内存划分为几块。一般是把 Java 堆分为新生代和老年代，针对各个年代的特点采用最适当的收集算法。\r\n\r\n- **新生代：** GC 过后只有少量对象存活 —— **复制算法**\r\n- **老年代：** GC 过后对象存活率高 —— **标记 - 整理算法**\r\n\r\n### MinorGC和FullGC的区别\r\n* MinorGC：发生在新生代的垃圾回收，因为新生代的特点，MinorGC非常频繁，且回收速度比较快，每次回收的量也很大。\r\n* FullGC：发生在老年代的垃圾回收，也称MajorGC，速度比较慢，相对于MinorGc慢10倍左右。进行一次FullGC通常会伴有多次多次MinorGC。\r\n\r\n\r\n## 附录\r\n\r\n### 面试经\r\n\r\n\r\n\r\n### 参考\r\n\r\n👉  [Java虚拟机JVM之垃圾回收策略与算法_毒毒毒毒丶的博客-CSDN博客](https://blog.csdn.net/qq_37776015/article/details/93708715)\r\n\r\n👉  [可达性算法中不可达的对象是否一定会死亡（不一定）_璟矢-CSDN博客](https://blog.csdn.net/qq_41999455/article/details/102608447)\r\n","timestamp":1642514536573},{"name":"06-HotSpot_JOL.md","path":"02-java篇/02-技术栈/02-jvm/06-HotSpot_JOL.md","content":"\r\n\r\n\r\n\r\n# Java Object LayOut\r\n\r\n> 本文所有内容基于: \t<span style=\"color:#42B983;font-weight:bold;\">HotSpot    jdk1.8</span>\t\r\n>\r\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2021年3月26日12:31:52</span>\r\n\r\n## 一、简述\r\n\r\n在 <span style=\"color:#42B983;font-weight:bold;\">HotSpot</span>虚拟机中\r\n对象在内存中的存储分为三块区域：<span style=\"color:#FC5531; font-weight:bold;\">对象头（Header）</span>、<span style=\"color:#FC5531; font-weight:bold;\">实例数据（Instance Data）</span>、<span style=\"color:#FC5531; font-weight:bold;\">对齐填充（Padding）</span>\r\n\r\n![image-20210411181827011](amWiki/images/lib_img/image-20210411181827011.png)\r\n\r\n---\r\n\r\n* 对象头\r\n\r\n  对象头(12个字节)主要分为两部分：\r\n\r\n  <span style=\"color:#FC5531; font-weight:bold;\">markWord ：</span> 占4个字节，主要描述：哈希码、gc分代年龄、锁状态标志、线程持有的锁、偏向线程id等</br>\r\n\r\n  ~~~c++\r\n  class markOopDesc: public oopDesc {\r\n   private:\r\n    // Conversion\r\n    uintptr_t value() const { return (uintptr_t) this; }\r\n   public:\r\n    // Constants\r\n    enum { age_bits                 = 4,  //分代年龄\r\n           lock_bits                = 2, //锁标识\r\n           biased_lock_bits         = 1, //是否为偏向锁\r\n           max_hash_bits            = BitsPerWord - age_bits - lock_bits - biased_lock_bits,\r\n           hash_bits                = max_hash_bits > 31 ? 31 : max_hash_bits, //对象的hashcode\r\n           cms_bits                 = LP64_ONLY(1) NOT_LP64(0),\r\n           epoch_bits               = 2 //偏向锁的时间戳\r\n    };\r\n  ~~~\r\n\r\n\r\n\r\n  <span style=\"color:#FC5531; font-weight:bold;\">Class对象指针：</span> 占8个字节，主要描述：</br>\r\n\r\n  * 普通对象：对象类型指针  <span style=\"color:#FC5531; font-weight:bold;\">注</span>：<span style=\"color:#42B983;font-weight:bold;\">对象定位方式</span>  和  <span style=\"color:#42B983;font-weight:bold;\">指针压缩</span>  问题 </br>\r\n  * 数组：数组元素类型指针 & 数组长度</br>\r\n\r\n---\r\n\r\n* 实例数据\r\n\r\n  实例数据部分就是成员变量的值：<span style=\"color:#42B983;font-weight:bold;\">基本变量</span> & <span style=\"color:#42B983;font-weight:bold;\">引用变量</span>。\r\n\r\n  * 基本变量：八种基本类型成员变量\r\n  * 引用变量：存放类的引用变量句柄，如String,Object每个句柄大小在32位虚拟机上是4byte，64位虚拟机上是8byte，但java8开始默认开启UseCompressedOops压缩参数，故也是4byte,classpoint也是如此；\r\n\r\n  <span style=\"color:#FC5531; font-weight:bold;\">注：</span>其中包括父类成员变量和本类成员变量\r\n\r\n---\r\n\r\n* 对齐填充\r\n\r\n  用于确保对象的总长度为 8 字节的整数倍。\r\n\r\n  HotSpot VM 的自动内存管理系统要求对象的大小必须是 8 字节的整数倍。\r\n\r\n  而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，\r\n\r\n  就需要通过对齐填充来补全。\r\n\r\n  > 对齐填充并不是必然存在，也没有特别的含义，它仅仅起着占位符的作用。\r\n\r\n---\r\n\r\n\r\n\r\n## 二 、详释\r\n\r\n> 实例数据 和 对齐填充 没有什么好说的，这里我们一起来看一下对象头（markWord & 实例数据）\r\n>\r\n> mark word的位长度为JVM的一个Word大小，也就是说32位JVM的Mark word为32位，64位JVM为64位。\r\n\r\n### 1、MarkWord\r\n\r\n* 32位对象头markword\r\n\r\n<table>\r\n\t<tr>\r\n\t    <th rowspan=\"2\">锁状态</th>\r\n\t    <th colspan=\"2\">25bit</th>  \r\n        <th rowspan=\"2\">4bit</th>\r\n\t    <th rowspan=\"2\">1bit(是否偏向锁)</th>\r\n\t    <th rowspan=\"2\">2bit(锁标志位)</th>  \r\n\t</tr >\r\n\t<tr >\r\n\t    <td>23bit</td>\r\n\t    <td>2bit</td>\r\n\t</tr>\r\n    <tr >\r\n\t    <td>无锁</td>\r\n\t    <td colspan=\"2\">对象hashCode</td>\r\n        <td>分代年龄</td>\r\n\t    <td>0</td>\r\n\t    <td>01</td>\r\n\t</tr>\r\n    <tr >\r\n\t    <td>偏向锁</td>\r\n\t    <td>(锁偏向的线程id)</td>\r\n\t    <td>Epoch</td>\r\n        <td>对象分代年龄</td>\r\n\t    <td>1</td>\r\n\t    <td>01</td>\r\n\t</tr>\r\n    <tr >\r\n\t    <td>轻量级</td>\r\n\t    <td colspan=\"4\">指向栈中锁记录的指针</td>\r\n\t    <td>00</td>\r\n\t</tr>\r\n    <tr >\r\n\t    <td>重量级</td>\r\n\t    <td colspan=\"4\">指向重量级锁的指针</td>\r\n\t    <td>10</td>\r\n\t</tr>\r\n    <tr >\r\n\t    <td>GC标记</td>\r\n\t    <td colspan=\"4\">空</td>\r\n\t    <td>11</td>\r\n\t</tr>\r\n</table>\r\n\r\n* 64位对象头markword\r\n\r\n<table>\r\n\t<tr>\r\n\t    <th align=\"center\" rowspan=\"2\" >锁状态</th>\r\n\t    <th align=\"center\" colspan=\"2\">56bit</th>  \r\n        <th align=\"center\" rowspan=\"2\">1bit</th>\r\n\t    <th align=\"center\" rowspan=\"2\">4bit</th>\r\n\t    <th align=\"center\" rowspan=\"2\">1bit(是否偏向锁)</th>\r\n        <th align=\"center\" rowspan=\"2\">2bit(锁标志位)</th>\r\n\t</tr >\r\n\t<tr >\r\n\t    <td align=\"center\">25bit</td>\r\n\t    <td align=\"center\">31bit</td>\r\n\t</tr>\r\n    <tr >\r\n\t    <td align=\"center\">无锁</td>\r\n        <td align=\"center\">unused</td>\r\n\t    <td align=\"center\">对象hashCode</td>\r\n        <td align=\"center\">cms_free</td>\r\n        <td align=\"center\">分代年龄</td>\r\n\t    <td align=\"center\">0</td>\r\n\t    <td align=\"center\">01</td>\r\n\t</tr>\r\n    <tr >\r\n\t    <td align=\"center\">偏向锁</td>\r\n\t    <td align=\"center\">(锁偏向的线程id)</td>\r\n\t    <td align=\"center\">Epoch</td>\r\n        <td align=\"center\">cms_free</td>\r\n        <td align=\"center\">对象分代年龄</td>\r\n\t    <td align=\"center\">1</td>\r\n\t    <td align=\"center\">01</td>\r\n\t</tr>\r\n    <tr >\r\n\t    <td align=\"center\">轻量级</td>\r\n\t    <td align=\"center\" colspan=\"5\">指向栈中锁记录的指针</td>\r\n\t    <td align=\"center\">00</td>\r\n\t</tr>\r\n    <tr >\r\n\t    <td align=\"center\">重量级</td>\r\n\t    <td align=\"center\" colspan=\"5\">指向重量级锁的指针</td>\r\n\t    <td align=\"center\">10</td>\r\n\t</tr>\r\n    <tr >\r\n\t    <td align=\"center\">GC标记</td>\r\n\t    <td align=\"center\" colspan=\"5\">空</td>\r\n\t    <td align=\"center\">11</td>\r\n\t</tr>\r\n</table>\r\n\r\n>  <span style=\"color:#FC5531; font-weight:bold;\">注</span>：这里锁升级（锁膨胀）、锁消除、锁粗化不做讨论，放在synchronize原理中讲解\r\n\r\n* 问题讨论\r\n\r\n  jvm对内存，对象年龄到15就会被移入老年代，那调优jvm是不是可以调大这个年龄？</br>\r\n\r\n  调优参数-XX:MaxTenuringThreshold</br>\r\n\r\n### 2、class类指针\r\n\r\n> class类指针 即：类型指针，通过该指针能确定对象属于哪个类。如果对象是一个数组，那么对象头还会包括数组长度。\r\n\r\n* 指针压缩\r\n\r\n  指针：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</br>\r\n\r\n   这部分就涉及到一个指针压缩的概念，在开启指针压缩的情况下，占4字节（32bit）</br>\r\n\r\n  未开启情况下，占8字节（64bit），现在JVM在1.6之后，在64位操作系统下都是默认开启的。</br>\r\n\r\n  * 未开启指针压缩\r\n\r\n  ![image-20210411182007583](/amWiki/images/lib_img/image-20210411182007583.png)\r\n\r\n\r\n\r\n![image-20210411182115359](amWiki/images/lib_img/image-20210411182115359.png)\r\n\r\n  采用8字节（64位）存储真实内存地址，比之前采用4字节（32位）压缩存储地址带来的问题：</br>\r\n\r\n  1. <span style=\"color:#FC5531; font-weight:bold;\">增加了GC开销</span>：64位对象引用需要占用更多的堆空间，留给其他数据的空间将会减少，</br>\r\n\r\n     从而加快了GC的发生，更频繁的进行GC。</br>\r\n\r\n  2. <span style=\"color:#FC5531; font-weight:bold;\">降低CPU缓存命中率</span>：64位对象引用增大了,CPU能缓存的oop将会更少,从而降低了CPU缓存的效率。</br>\r\n\r\n\r\n\r\n  * 开启指针压缩\r\n\r\n![image-20210411182036215](amWiki/images/lib_img/image-20210411182036215.png)\r\n\r\n![image-20210411182139375](amWiki/images/lib_img/image-20210411182139375.png)\r\n\r\n4个字节，32位，可以表示232 个地址，如果这个地址是真实内存地址的话，</br>\r\n那么由于CPU寻址的最小单位是byte，也就是 232 byte = 4GB。</br>\r\n如果内存地址是指向 bit的话，32位的最大寻址范围其实是 512MB，但是由于内存里，将8bit为一组划分，</br>\r\n所以内存地址就其实是指向的8bit为一组的byte地址，所以32位可以表示的容量就扩充了8倍，</br>\r\n就变成了4GB。</br>\r\n\r\n将java堆内存进行8字节划分</br>\r\n\r\njava对象的指针地址就可以不用存对象的真实的64位地址了，而是可以存一个映射地址编号。</br>\r\n这样4字节就可以表示出2^32个地址，而每一个地址对应的又是8byte的内存块。</br>\r\n所以，再乘以8以后，一换算，就可以表示出32GB的内存空间。</br>\r\n\r\n### 3、实例数据\r\n\r\n> 基本变量这里不再讨论，这里涉及到对象的访问方式：<span style=\"color:#42B983;font-weight:bold;\">句柄访问</span> & <span style=\"color:#42B983;font-weight:bold;\">指针访问</span>\r\n\r\n* 句柄访问\r\n\r\n  堆中需要有一块叫做“句柄池”的内存空间，句柄中包含了对象实例数据与类型数据各自的具体地址信息。\r\n\r\n  引用类型的变量存放的是该对象的句柄地址（reference）。访问对象时，首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址找到对象。\r\n\r\n![image-20210411182301644](amWiki/images/lib_img/image-20210411182301644.png)\r\n\r\n* 指针访问\r\n\r\n  引用类型的变量直接存放对象的地址，从而不需要句柄池，通过引用能够直接访问对象。但对象所在的内存空间需要额外的策略存储对象所属的类信息的地址。\r\n\r\n  ![image-20210411182323044](amWiki/images/lib_img/image-20210411182323044.png)\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">注</span>：HotSpot 采用第二种方式，即直接指针方式来访问对象，只需要一次寻址操作，所以在性能上比句柄访问方式快一倍。但像上面所说，它需要**额外的策略**来存储对象在方法区中类信息的地址。\r\n\r\n## 三、实例说明\r\n\r\n### 1、引入JOL辅助依赖\r\n\r\n~~~xml\r\n<dependency>\r\n    <groupId>org.openjdk.jol</groupId>\r\n    <artifactId>jol-core</artifactId>\r\n    <version>0.9</version>\r\n</dependency>\r\n~~~\r\n\r\n\r\n\r\n### 2、obj说明类\r\n\r\n* learner类\r\n\r\n~~~java\r\npublic class JolLearn {\r\n    public static void main(String[] args) {\r\n        /**\r\n         *  User对象的布局\r\n         *\r\n         *\r\n         *\r\n         *         --   +-------------+--------------------------------+\r\n         *        |     |   markword  |   8字节 (synchronized 信息在这里 |\r\n         * 对象头 {      +-------------+--------------------------------+\r\n         *        \\     |class pointer|   开启ccp4字节，不开启8字节       |\r\n         *         --   +-------------+--------------------------------+\r\n         *              |instant data |   具体分析：int 4字节。。。       |\r\n         *              +-------------+--------------------------------+\r\n         *              |   padding   |   总字节数被8整除，否则补齐       |\r\n         *              +-------------+--------------------------------+\r\n         *\r\n         *  Q:\r\n         *      1、\r\n         */\r\n        User_NoVal user_NoVal = new User_NoVal();\r\n        User_HaveVal user_HaveVal = new User_HaveVal();\r\n\r\n        // 普通对象:无成员变量时的对象布局\r\n        System.out.println(ClassLayout.parseInstance(user_NoVal).toPrintable());\r\n\r\n        // 普通对象:有成员变量时的对象布局\r\n        System.out.println(ClassLayout.parseInstance(user_HaveVal).toPrintable());\r\n\r\n        // 普通对象：无成员变量 有synchronized 信息时的对象布局\r\n        /*synchronized(user_NoVal){\r\n            System.out.println(ClassLayout.parseInstance(user_NoVal).toPrintable());\r\n        }*/\r\n    }\r\n}\r\n~~~\r\n\r\n* 有成员变量（hava_val）类\r\n\r\n~~~java\r\nclass User_HaveVal{\r\n    // 4个字节\r\n    private int id;\r\n    // 开启普通指针压缩的情况下 4个字节\r\n    private String name;\r\n}\r\n~~~\r\n\r\n* 无成员变量（  no_val  ）类\r\n\r\n~~~java\r\nclass User_NoVal{\r\n\r\n}\r\n~~~\r\n\r\n\r\n\r\n## 附录\r\n\r\n### 面试经\r\n\r\n1、对象在内存中的存储布局？Object o = new Object()在内存中占用多少字符？\r\n\r\n2、什么是java指针压缩\r\n\r\n3、Hotspot开启内存压缩的规则（64位机）\r\n\r\n4、当物理内存超过32g时指针压缩为啥会失效\r\n\r\n5、对象怎么定位？\r\n\r\n### 参考\r\n\r\n👉 [jvm压缩指针原理以及32g内存压缩指针失效详解_超负荷运转-CSDN博客_压缩指针](https://blog.csdn.net/lioncatch/article/details/105919666)\r\n\r\n👉 [聊一聊JAVA指针压缩的实现原理（图文并茂，让你秒懂）_liujianyangbj的博客-CSDN博客_指针压缩](https://blog.csdn.net/liujianyangbj/article/details/108049482)\r\n\r\n👉 https://github.com/doocs/jvm/blob/main/docs/02-hotspot-jvm-object.md\r\n\r\n👉 [java byte object的子类_Java对象布局(JOL)实现过程解析_王若然的博客-CSDN博客](https://blog.csdn.net/weixin_31458015/article/details/114184239)\r\n","timestamp":1642514536573},{"name":"01-synchronize底层原理.md","path":"02-java篇/02-技术栈/03-多线程/01-synchronize底层原理.md","content":"\r\n\r\n# synchronize底层原理\r\n\r\n>synchronize是如何使用的？这里不再赘述，从底层出发了解原理。\r\n>\r\n>时间：<span style=\"color:#42B983;font-weight:bold;\">2021年4月1日14:44:08</span>    本文所有内容基于: \t<span style=\"color:#42B983;font-weight:bold;\">HotSpot    jdk1.8</span>\r\n\r\n## 一、前置知识\r\n\r\n### 1、cas和unsafe类\r\n\r\n#### a、<span style=\"color:#FC5531; font-weight:bold;\">cas </span>\r\n**Compare and Swap(set)** 基于乐观锁的一种概念</br>\r\n描述了，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止的机制</br>\r\n\r\n\r\n\r\n#### b、<span style=\"color:#FC5531; font-weight:bold;\">unsafe类</span>\r\n\r\nunsafe(不安全)类，是对cas机制的一种  <span style=\"color:#42B983;font-weight:bold;\">\"安全实现\"</span>  下边我们详细描述。\r\n\r\n##### 不安全\r\n\r\n因为unsafe类是<span style=\"color:#FC5531; font-weight:bold;\"> 直接操作内存 </span>的类，所以不安全\r\n\r\n##### 安全\r\n\r\n因为unsafe类是直接操作内存的类，所以为了不让程序员们直接使用，对unsafe类加了限制</br>\r\n\r\n该类只能有Bootstrap类加载器加载（<span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px\">但让使用反射这种非常规的方式还是可以突破限制 ^_-！</span>）\r\n\r\n##### 正常尝试使用\r\n\r\n~~~java\r\n/**\r\n * 正常渠道使用unsafe类\r\n * ：因为 unsafe类 是在rt包下的，并且unsafe是直接操作内存的类，所以官方为了不让程序员们直接操作内存导致不安全的问题发生，所以对unsafe类使用加了以下限制\r\n * 首先unsafe类必须有Bootstrap类加载器加载才能使用\r\n *\r\n * @author Ryan丶璟芮\r\n * @since 2021-02-02\r\n */\r\npublic class NormalChannelUnsafe {\r\n    // 获取unsafe的实例\r\n    static final Unsafe unsafe = sun.misc.Unsafe.getUnsafe();\r\n\r\n    // state 字段内存偏移量\r\n    static long stateOffSet;\r\n\r\n    // cas 要修改的字段state\r\n    private volatile long state = 0;\r\n\r\n    static {\r\n        try {\r\n            // 获取字段“state\" 在对象NormalChannelUnsafe中的内存偏移量\r\n            stateOffSet = unsafe.objectFieldOffset(NormalChannelUnsafe.class.getDeclaredField(\"state\"));\r\n        } catch (NoSuchFieldException e) {\r\n            System.out.println(e.getLocalizedMessage());\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        NormalChannelUnsafe normalChannelUnsafe = new NormalChannelUnsafe();\r\n        // 使用unsafe类的cas方式修改对象normalChannelUnsafe对象在内存偏移量为stateOffSet位置上的值为1\r\n        Boolean sucess = unsafe.compareAndSwapLong(normalChannelUnsafe, stateOffSet, 0, 1);\r\n    }\r\n}\r\n~~~\r\n\r\n##### 反射尝试\r\n\r\n~~~java\r\n/**\r\n * 非正规渠道使用unsafe类\r\n *  正常的渠道无法使用unsafe类 但是我们可以利用强大的 反射来打破平衡，突破限制\r\n *\r\n * @author Ryan丶璟芮\r\n * @since 2021-02-02\r\n */\r\npublic class AbnormalChannelUnsafe {\r\n\r\n    static  Unsafe unsafe;\r\n\r\n    static long stateOffSet;\r\n\r\n    private volatile long state = 0;\r\n\r\n    static{\r\n        try {\r\n            Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\r\n\r\n            field.setAccessible(true);\r\n\r\n            unsafe = (Unsafe) field.get(null);\r\n\r\n            stateOffSet = unsafe.objectFieldOffset(AbnormalChannelUnsafe.class.getDeclaredField(\"state\"));\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n\r\n    public static void main(String[] args) {\r\n\r\n        AbnormalChannelUnsafe abnormalChannelUnsafe = new AbnormalChannelUnsafe();\r\n\r\n        Boolean success = unsafe.compareAndSwapLong(abnormalChannelUnsafe,stateOffSet,256,1);\r\n\r\n        System.out.println(\"abnormalChannelUnsafe to update state`s value result :\" + success + \" | current value :\" + abnormalChannelUnsafe.state);\r\n\r\n    }\r\n\r\n}\r\n~~~\r\n\r\n##### unsafe对cas实现解读\r\n\r\n> 这里以上例中的 unsafe.compareAndSwapLong();为例探索\r\n\r\n* java代码\r\n\r\n~~~java\r\n/**\r\n     * Atomically update Java variable to <tt>x</tt> if it is currently\r\n     * holding <tt>expected</tt>.\r\n     * @return <tt>true</tt> if successful\r\n     */\r\n    public final native boolean compareAndSwapLong(Object o, long offset,\r\n                                                   long expected,long x);\r\n~~~\r\n\r\n* openjdk1.8源码说明\r\n\r\n~~~c++\r\nUNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x))\r\n  UnsafeWrapper(\"Unsafe_CompareAndSwapLong\");\r\n  Handle p (THREAD, JNIHandles::resolve(obj));\r\n  jlong* addr = (jlong*)(index_oop_from_field_offset_long(p(), offset));\r\n  if (VM_Version::supports_cx8())\r\n    return (jlong)(Atomic::cmpxchg(x, addr, e)) == e;\r\n  else {\r\n    jboolean success = false;\r\n    ObjectLocker ol(p, THREAD);\r\n    if (*addr == e) { *addr = x; success = true; }\r\n    return success;\r\n  }\r\nUNSAFE_END\r\n~~~\r\n\r\n接着我们再看上面这段代码中的核心代码点：<span style=\"color:#FC5531; font-weight:bold;\">Atomic::cmpxchg(x, addr, e)</span>\r\n在atomic_linux_x86.inline.hpp中的实现\r\n\r\n~~~c++\r\ninline jlong    Atomic::cmpxchg    (jlong    exchange_value, volatile jlong*    dest, jlong    compare_value) {\r\n  bool mp = os::is_MP();\r\n  __asm__ __volatile__ (LOCK_IF_MP(%4) \"cmpxchgq %1,(%3)\"\r\n                        : \"=a\" (exchange_value)\r\n                        : \"r\" (exchange_value), \"a\" (compare_value), \"r\" (dest), \"r\" (mp)\r\n                        : \"cc\", \"memory\");\r\n  return exchange_value;\r\n}\r\n~~~\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">简单说明：</span>\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">\\__asm__  \\__volatile__ </span>:声明接下来的4部分表达式（：分割的）不被gcc指令优化</br>\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">os::is_MP()</span>：判断当前环境是否为多处理器环境 </br>\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">重点★★★</span> LOCK_IF_MP(%4) \"cmpxchgq %1,(%3)\" </br>\r\n\r\n LOCK_IF_MP：如果为多核处理器，则在“核心指令”前追加“lock”指令</br>\r\n\r\n lock:语义：只允许一个cpu修改地址偏移量上的值</br>\r\n\r\n硬件层面细究：锁总线：锁定总线一个北桥电信号 这里就不在往深了探讨了 0.o</br>\r\n\r\ncmpxchgq：核心指令，语义：比较并交换</br>\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">总</span>：总结cas机制用unsafe核心实现底层指令：<span style=\"color:#FC5531; font-weight:bold;\">lock  cmpxchgp</span>\r\n\r\n### 2、JOL\r\n\r\n>  JOL:java object layout,有专门的文章讲解，这里不在赘述\r\n\r\n## 二、synchronize使用场景\r\n\r\n### 1、修饰代码块\r\n\r\n~~~java\r\n// 指定一个加锁的对象，给对象加锁\r\npublic Demo1{\r\n   Object lock=new Object();\r\n   public void test1(){\r\n       synchronized(lock){\r\n       }\r\n   }\r\n}\r\n~~~\r\n\r\n\r\n\r\n### 2、修饰静态方法\r\n\r\n~~~java\r\n// 对当前类的Class对象加锁\r\npublic class Demo2 {\r\n   //形式一\r\n    public void test1(){\r\n        synchronized(Demo2.class){\r\n        }\r\n    }\r\n  //形式二\r\n    public void test2(){\r\n        public synchronized static void test1(){\r\n        }\r\n    }\r\n}\r\n~~~\r\n\r\n### 3、修饰普通方法\r\n\r\n~~~java\r\n// 对当前实例对象this加锁\r\npublic class Demo3 {\r\n    public synchronized void test1(){\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n## 三、字节码层面解读synchronize\r\n\r\n### 1、java代码\r\n\r\n~~~java\r\npublic static void main( String[] args ){\r\n    System.out.println( \"hello Java\" );\r\n}\r\n//synchronized修饰普通方法\r\npublic synchronized void test1() { }\r\n\r\n//修饰代码块\r\npublic void test2() {\r\n    synchronized (this) {}\r\n}\r\n~~~\r\n\r\n### 2、java字节码\r\n\r\n(字节码查看命令：javap -verbose  类名) 下文只是截取了test1 和 test2方法部分\r\n\r\ntest1()    <span style=\"color:#42B983;font-weight:bold;\">核心标志：</span><span style=\"color:#FC5531; font-weight:bold;\">ACC_SYNCHRONIZED</span>\r\n\r\n~~~java\r\n\'\'\'\r\npublic synchronized void test1();\r\n    descriptor: ()V\r\n    flags: ACC_PUBLIC, ACC_SYNCHRONIZED\r\n    Code:\r\n      stack=0, locals=1, args_size=1\r\n         0: return\r\n      LineNumberTable:\r\n        line 59: 0\r\n      LocalVariableTable:\r\n        Start  Length  Slot  Name   Signature\r\n            0       1     0  this   Lsite/ryanc/lock/SyncLearn;\r\n\'\'\'\r\n~~~\r\n\r\n> 如果修饰同步方法是通过的flag ACC_SYNCHRONIZED来完成的，也就是说一旦执行到这个方法，就会先判断是否有标志位，然后ACC_SYNCHRONIZED会去隐式调用刚才的两个指令：monitorenter和monitorexit。\r\n\r\n---\r\n\r\ntest2()    <span style=\"color:#42B983;font-weight:bold;\">核心指令：</span><span style=\"color:#FC5531; font-weight:bold;\">monitorenter 、monitorexit</span>\r\n\r\n~~~java\r\n\'\'\'\r\n public void test2();\r\n    descriptor: ()V\r\n    flags: ACC_PUBLIC\r\n    Code:\r\n      stack=2, locals=3, args_size=1\r\n         0: aload_0\r\n         1: dup\r\n         2: astore_1\r\n         3: monitorenter\r\n         4: aload_1\r\n         5: monitorexit\r\n         6: goto          14\r\n         9: astore_2\r\n        10: aload_1\r\n        11: monitorexit\r\n        12: aload_2\r\n        13: athrow\r\n        14: return\r\n~~~\r\n\r\n> 首先如果被synchronized修饰在方法块的话，是通过 monitorenter 和 monitorexit 这两个字节码指令获取线程的执行权的。当方法执行完毕退出以后或者出现异常的情况下会自动释放锁。\r\n\r\n### 3、综述\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">简单说明：</span>\r\n在Java虚拟机执行到monitorenter指令时：</br>\r\n1首先它会尝试获取对象的锁，如果该对象没有锁，或者当前线程已经拥有了这个对象的锁时</br>\r\n它会把计数器+1；然后当执行到monitorexit 指令时就会将计数器-1</br>\r\n然后当计数器为0时，锁就释放了。2⃣️如果获取锁 失败，那么当前线程就要阻塞等待</br>\r\n直到对象锁被另一个线程释放为止。</br>\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">问题讨论(面试经)：</span>为啥方法test2中有两个monitorexit？\r\n\r\n\r\n\r\n## 四、源码层面解读synchronize\r\n\r\n> 这里我们配合synchronize1.6优化后的，锁升级的过程来探究\r\n\r\n### 1、锁状态在markword的布局\r\n\r\n![image-20210411172438308](amWiki/images/lib_img/image-20210411172438308.png)\r\n\r\n### 2、无锁状态\r\n\r\n#### a、java代码\r\n\r\n~~~java\r\npublic class NoLock {\r\n    private static Object o = new Object();\r\n    public static void main(String[] args) {\r\n        System.out.println(ClassLayout.parseInstance(o).toPrintable());\r\n    }\r\n}\r\n~~~\r\n\r\n#### b、jol\r\n\r\n~~~\r\njava.lang.Object object internals:\r\n OFFSET  SIZE   TYPE DESCRIPTION VALUE\r\n      0     4   (object header)  01 00 00 00 (00000001 00000000 00000000 00000000) (1)\r\n      4     4   (object header)  00 00 00 00 (00000000 00000000 00000000 00000000) (0)\r\n      8     4   (object header)  dd 01 00 f8 (11011101 00000001 00000000 11111000) (-134217251)\r\n     12     4   (loss due to the next object alignment)\r\nInstance size: 16 bytes\r\nSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total\r\n~~~\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">问题讨论(面试经)：</span>上面布局中，锁标记状态最后两位，为啥打印出来是前两位？\r\n<span style=\"color:#42B983;font-weight:bold;\">解惑 : </span> 大端模式 和 小端模式\r\n\r\n总：无锁状态不涉及锁，我们从jol层面理解一下就好，这里不在深究 o.0\r\n\r\n### 3、偏向锁状态\r\n\r\n#### a、java代码\r\n\r\n~~~java\r\npublic class DeflectionLock {\r\n    private static Object o = new Object();\r\n//    private static Object o;\r\n\r\n    public static void main(String[] args) throws InterruptedException {\r\n//        Thread.sleep(5000);\r\n//        o = new Object();\r\n        System.out.println(ClassLayout.parseInstance(o).toPrintable());\r\n        lock();\r\n        System.out.println(ClassLayout.parseInstance(o).toPrintable());\r\n    }\r\n\r\n    private static void lock() {\r\n        synchronized (o) {\r\n\r\n        }\r\n    }\r\n}\r\n~~~\r\n\r\n#### b、jol\r\n\r\n~~~\r\njava.lang.Object object internals:\r\n OFFSET  SIZE   TYPE DESCRIPTION VALUE\r\n      0     4  (object header)   05 00 00 00 (00000101 00000000 00000000 00000000) (5)\r\n      4     4  (object header)   00 00 00 00 (00000000 00000000 00000000 00000000) (0)\r\n      8     4  (object header)   dd 01 00 f8 (11011101 00000001 00000000 11111000) (-134217251)\r\n     12     4  (loss due to the next object alignment)\r\nInstance size: 16 bytes\r\nSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total\r\n\r\njava.lang.Object object internals:\r\n OFFSET  SIZE   TYPE DESCRIPTION VALUE\r\n      0     4  (object header)   05 50 05 01 (00000101 01010000 00000101 00000001) (17125381)\r\n      4     4  (object header)   00 00 00 00 (00000000 00000000 00000000 00000000) (0)\r\n      8     4  (object header)   dd 01 00 f8 (11011101 00000001 00000000 11111000) (-134217251)\r\n     12     4  (loss due to the next object alignment)\r\nInstance size: 16 bytes\r\nSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total\r\n~~~\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">问题讨论(面试经)：</span>上述代码打印的jol于我们预期的jol不同？</br>\r\n<span style=\"color:#42B983;font-weight:bold;\">解惑 : </span> jdk1.6后默认开启偏向锁（-XX:-UseBiasedLocking = true）输入延迟开启</br>\r\n\r\n   取消延时（XX:BiasedLockingStartUpDelay=0；）</br>\r\n\r\n#### c、加锁流程\r\n\r\n![image-20210411165923326](amWiki/images/lib_img/image-20210411165923326.png)\r\n\r\n\r\n\r\n#### d、monitorenter指令源码\r\n\r\n~~~c++\r\n\'\'\'\r\n//UseHeavyMonitors表示是否只使用重量级锁，默认为false，如果为true则调用InterpreterRuntime::monitorenter方法获取重量级锁\r\n  if (UseHeavyMonitors) {\r\n    call_VM(noreg,CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\r\n            lock_reg);\r\n  } else {\r\n    Label done;\r\n    \'\'\'\r\n     //UseBiasedLocking默认为true\r\n    if (UseBiasedLocking) {\r\n      //首先尝试获取偏向锁，获取成功会跳转到done，否则走到slow_case\r\n      biased_locking_enter(lock_reg, obj_reg, swap_reg, rscratch1, false, done, \t\t\t  &slow_case);\r\n    }\r\n\r\n~~~\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">简单说明：</span>\r\n\r\n1、UseHeavyMonitors：首先判断是否使用重级锁，默认是false；</br>\r\n\r\n2、UseBiasedLocking:是否启用偏向锁,1.6以后默认开启,也可关闭(-XX:-UseBiasedLocking = false）</br>\r\n\r\n3、biased_locking_enter();该方法用cas将当前线程id刷新到 对象头markword中\r\n\r\n### 4、轻量级锁\r\n\r\n#### a、java代码\r\n\r\n~~~java\r\npublic class LightweightLocking {\r\n    private static Object o;\r\n    public static void main(String[] args) throws InterruptedException {\r\n        Thread.sleep(5000L);\r\n        o = new Object();\r\n        System.out.println(ClassLayout.parseInstance(o).toPrintable());\r\n        new Thread(LightweightLocking::lock).start();\r\n        // 加个睡眠是怕上面的线程没有执行完成而形成线程争用而升级为重量级锁\r\n        Thread.sleep(3000L);\r\n        lock();\r\n        System.out.println(ClassLayout.parseInstance(o).toPrintable());\r\n    }\r\n\r\n    private static void lock() {\r\n        synchronized (o) {\r\n            System.out.println(ClassLayout.parseInstance(o).toPrintable());\r\n        }\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n#### b、jol\r\n\r\n> 运行java代码查看，探讨\r\n\r\n#### c、monitorenter指令源码\r\n\r\n~~~c++\r\nvoid ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) {\r\n  markOop mark = obj->mark();\r\n  assert(!mark->has_bias_pattern(), \"should not see bias pattern here\");\r\n\r\n  if (mark->is_neutral()) {//如果当前是无锁状态, markword的\r\n    //直接把mark保存到BasicLock对象的_displaced_header字段\r\n    lock->set_displaced_header(mark);\r\n    //通过CAS将mark word更新为指向BasicLock对象的指针，更新成功表示获得了轻量级锁\r\n    if (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()->mark_addr(), mark)) {\r\n      TEVENT (slow_enter: release stacklock) ;\r\n      return ;\r\n    }\r\n    // Fall through to inflate() ...\r\n  }\r\n  //如果markword处于加锁状态、且markword中的ptr指针指向当前线程的栈帧，表示为重入操作，不需要争抢锁\r\n  else\r\n  if (mark->has_locker() && THREAD->is_lock_owned((address)mark->locker())) {\r\n    assert(lock != mark->locker(), \"must not re-lock the same lock\");\r\n    assert(lock != (BasicLock*)obj->mark(), \"don\'t relock with same BasicLock\");\r\n    lock->set_displaced_header(NULL);\r\n    return;\r\n  }\r\n\r\n#if 0\r\n  // The following optimization isn\'t particularly useful.\r\n  if (mark->has_monitor() && mark->monitor()->is_entered(THREAD)) {\r\n    lock->set_displaced_header (NULL) ;\r\n    return ;\r\n  }\r\n#endif\r\n\t//代码执行到这里，说明有多个线程竞争轻量级锁，轻量级锁通过`inflate`进行膨胀升级为重量级锁\r\n  lock->set_displaced_header(markOopDesc::unused_mark());\r\n  ObjectSynchronizer::inflate(THREAD, obj())->enter(THREAD);\r\n}\r\n~~~\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">简单说明：</span>\r\n\r\n1、在关闭偏向锁、或多线程竞争是发现偏向锁已经被获取时，就会升级为轻量级锁（自旋锁）\r\n\r\n2、Atomic::cmpxchg_ptr：cas修改资源对象markword 中指向当前线程的lockrecord对象\r\n\r\n总：当多次(10次,-XX:PreBlockSpin可以修改)cas修改markword指向锁记录的指针失败，就会升级为重量级锁\r\n\r\n#### d、加锁流程\r\n\r\n![image-20210411165941361](amWiki/images/lib_img/image-20210411165941361.png)\r\n\r\n#### e、解锁流程\r\n\r\n![image-20210411165959511](amWiki/images/lib_img/image-20210411165959511.png)\r\n\r\n### 5、重量级锁\r\n\r\n#### a、java代码\r\n\r\n~~~java\r\npublic class HeavyweightLock {\r\n    private static Object o;\r\n    public static void main(String[] args) throws InterruptedException {\r\n        Thread.sleep(5000L);\r\n        o = new Object();\r\n        System.out.println(ClassLayout.parseInstance(o).toPrintable());\r\n        new Thread(HeavyweightLock::lock).start();\r\n        lock();\r\n        System.out.println(ClassLayout.parseInstance(o).toPrintable());\r\n    }\r\n\r\n    private static void lock() {\r\n        synchronized (o) {\r\n            System.out.println(ClassLayout.parseInstance(o).toPrintable());\r\n        }\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n#### b、jol\r\n\r\n> 运行java代码查看，探讨\r\n\r\n\r\n\r\n#### c、指令源码\r\n\r\n* 第一段\r\n\r\n~~~c++\r\nvoid ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) {\r\n  markOop mark = obj->mark();\r\n  assert(!mark->has_bias_pattern(), \"should not see bias pattern here\");\r\n\r\n  if (mark->is_neutral()) {//如果当前是无锁状态, markword的\r\n    //直接把mark保存到BasicLock对象的_displaced_header字段\r\n    lock->set_displaced_header(mark);\r\n    //通过CAS将mark word更新为指向BasicLock对象的指针，更新成功表示获得了轻量级锁\r\n    if (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()->mark_addr(), mark)) {\r\n      TEVENT (slow_enter: release stacklock) ;\r\n      return ;\r\n    }\r\n    // Fall through to inflate() ...\r\n  }\r\n  //如果markword处于加锁状态、且markword中的ptr指针指向当前线程的栈帧，表示为重入操作，不需要争抢锁\r\n  else\r\n  if (mark->has_locker() && THREAD->is_lock_owned((address)mark->locker())) {\r\n    assert(lock != mark->locker(), \"must not re-lock the same lock\");\r\n    assert(lock != (BasicLock*)obj->mark(), \"don\'t relock with same BasicLock\");\r\n    lock->set_displaced_header(NULL);\r\n    return;\r\n  }\r\n\r\n#if 0\r\n  // The following optimization isn\'t particularly useful.\r\n  if (mark->has_monitor() && mark->monitor()->is_entered(THREAD)) {\r\n    lock->set_displaced_header (NULL) ;\r\n    return ;\r\n  }\r\n#endif\r\n\t//代码执行到这里，说明有多个线程竞争轻量级锁，轻量级锁通过`inflate`进行膨胀升级为重量级锁\r\n  lock->set_displaced_header(markOopDesc::unused_mark());\r\n  ObjectSynchronizer::inflate(THREAD, obj())->enter(THREAD);\r\n}\r\n~~~\r\n\r\n* 第二段\r\n\r\n~~~c++\r\nObjectMonitor * ATTR ObjectSynchronizer::inflate (Thread * Self, oop object) {\r\n  ...\r\n\r\n  for (;;) {\r\n      const markOop mark = object->mark() ;\r\n      assert (!mark->has_bias_pattern(), \"invariant\") ;\r\n\r\n      // mark是以下状态中的一种：\r\n      // *  Inflated（重量级锁状态）     - 直接返回\r\n      // *  Stack-locked（轻量级锁状态） - 膨胀\r\n      // *  INFLATING（膨胀中）    - 忙等待直到膨胀完成\r\n      // *  Neutral（无锁状态）      - 膨胀\r\n      // *  BIASED（偏向锁）       - 非法状态，在这里不会出现\r\n\r\n      // CASE: inflated\r\n      if (mark->has_monitor()) {\r\n          // 已经是重量级锁状态了，直接返回\r\n          ObjectMonitor * inf = mark->monitor() ;\r\n          ...\r\n          return inf ;\r\n      }\r\n\r\n      // CASE: inflation in progress\r\n      if (mark == markOopDesc::INFLATING()) {\r\n         // 正在膨胀中，说明另一个线程正在进行锁膨胀，continue重试\r\n         TEVENT (Inflate: spin while INFLATING) ;\r\n         // 在该方法中会进行spin/yield/park等操作完成自旋动作\r\n         ReadStableMark(object) ;\r\n         continue ;\r\n      }\r\n\r\n      if (mark->has_locker()) {\r\n          // 当前轻量级锁状态，先分配一个ObjectMonitor对象，并初始化值\r\n          ObjectMonitor * m = omAlloc (Self) ;\r\n\r\n          m->Recycle();\r\n          m->_Responsible  = NULL ;\r\n          m->OwnerIsThread = 0 ;\r\n          m->_recursions   = 0 ;\r\n          m->_SpinDuration = ObjectMonitor::Knob_SpinLimit ;   // Consider: maintain by type/class\r\n  // 将锁对象的mark word设置为INFLATING (0)状态\r\n          markOop cmp = (markOop) Atomic::cmpxchg_ptr (markOopDesc::INFLATING(), object->mark_addr(), mark) ;\r\n          if (cmp != mark) {\r\n             omRelease (Self, m, true) ;\r\n             continue ;       // Interference -- just retry\r\n          }\r\n\r\n          // 栈中的displaced mark word\r\n          markOop dmw = mark->displaced_mark_helper() ;\r\n          assert (dmw->is_neutral(), \"invariant\") ;\r\n\r\n          // 设置monitor的字段\r\n          m->set_header(dmw) ;\r\n          // owner为Lock Record\r\n          m->set_owner(mark->locker());\r\n          m->set_object(object);\r\n          ...\r\n          // 将锁对象头设置为重量级锁状态\r\n          object->release_set_mark(markOopDesc::encode(m));\r\n\r\n         ...\r\n          return m ;\r\n      }\r\n\r\n      // CASE: neutral\r\n\r\n      // 分配以及初始化ObjectMonitor对象\r\n      ObjectMonitor * m = omAlloc (Self) ;\r\n      // prepare m for installation - set monitor to initial state\r\n      m->Recycle();\r\n      m->set_header(mark);\r\n      // owner为NULL\r\n      m->set_owner(NULL);\r\n      m->set_object(object);\r\n      m->OwnerIsThread = 1 ;\r\n      m->_recursions   = 0 ;\r\n      m->_Responsible  = NULL ;\r\n      m->_SpinDuration = ObjectMonitor::Knob_SpinLimit ;       // consider: keep metastats by type/class\r\n  // 用CAS替换对象头的mark word为重量级锁状态\r\n      if (Atomic::cmpxchg_ptr (markOopDesc::encode(m), object->mark_addr(), mark) != mark) {\r\n          // 不成功说明有另外一个线程在执行inflate，释放monitor对象\r\n          m->set_object (NULL) ;\r\n          m->set_owner  (NULL) ;\r\n          m->OwnerIsThread = 0 ;\r\n          m->Recycle() ;\r\n          omRelease (Self, m, true) ;\r\n          m = NULL ;\r\n          continue ;\r\n          // interference - the markword changed - just retry.\r\n          // The state-transitions are one-way, so there\'s no chance of\r\n          // live-lock -- \"Inflated\" is an absorbing state.\r\n      }\r\n\r\n      ...\r\n      return m ;\r\n  }\r\n}\r\n~~~\r\n\r\n* 第三段\r\n\r\n~~~c++\r\nvoid ATTR ObjectMonitor::enter(TRAPS) {\r\n\r\n  Thread * const Self = THREAD ;\r\n  void * cur ;\r\n  // owner为null代表无锁状态，如果能CAS设置成功，则当前线程直接获得锁\r\n  cur = Atomic::cmpxchg_ptr (Self, &_owner, NULL) ;\r\n  if (cur == NULL) {\r\n     ...\r\n     return ;\r\n  }\r\n  // 如果是重入的情况\r\n  if (cur == Self) {\r\n     // TODO-FIXME: check for integer overflow!  BUGID 6557169.\r\n     _recursions ++ ;\r\n     return ;\r\n  }\r\n  // 当前线程是之前持有轻量级锁的线程。由轻量级锁膨胀且第一次调用enter方法，那cur是指向Lock Record的指针\r\n  if (Self->is_lock_owned ((address)cur)) {\r\n    assert (_recursions == 0, \"internal state error\");\r\n    // 重入计数重置为1\r\n    _recursions = 1 ;\r\n    // 设置owner字段为当前线程（之前owner是指向Lock Record的指针）\r\n    _owner = Self ;\r\n    OwnerIsThread = 1 ;\r\n    return ;\r\n  }\r\n\r\n  ...\r\n\r\n  // 在调用系统的同步操作之前，先尝试自旋获得锁\r\n  if (Knob_SpinEarly && TrySpin (Self) > 0) {\r\n     ...\r\n     //自旋的过程中获得了锁，则直接返回\r\n     Self->_Stalled = 0 ;\r\n     return ;\r\n  }\r\n\r\n  ...\r\n\r\n  {\r\n    ...\r\n\r\n    for (;;) {\r\n      jt->set_suspend_equivalent();\r\n      // 在该方法中调用系统同步操作\r\n      EnterI (THREAD) ;\r\n      ...\r\n    }\r\n    Self->set_current_pending_monitor(NULL);\r\n\r\n  }\r\n\r\n  ...\r\n\r\n}\r\n~~~\r\n\r\n\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">简单说明：</span>\r\n\r\n1、当代码执行到上述代码的最后两行时，有轻量级锁升级为重量级锁\r\n\r\n2、此时引入了“ObjectMonitor“对象\r\n\r\n3、膨胀完后再用第三段代码 中的enter方法获得锁\r\n\r\n#### d、ObjectMonitor\r\n\r\n~~~ c++\r\n\r\nObjectMonitor::ObjectMonitor() {  \r\n  _header       = NULL;  \r\n  _count       = 0;  \r\n  _waiters      = 0,  \r\n  _recursions   = 0;       //线程的重入次数\r\n  _object       = NULL;  \r\n  _owner        = NULL;    //标识拥有该monitor的线程\r\n  _WaitSet      = NULL;    //等待线程组成的双向循环链表，_WaitSet是第一个节点\r\n  _WaitSetLock  = 0 ;  \r\n  _Responsible  = NULL ;  \r\n  _succ         = NULL ;  \r\n  _cxq          = NULL ;    //多线程竞争锁进入时的单向链表\r\n  FreeNext      = NULL ;  \r\n  _EntryList    = NULL ;    //_owner从该双向循环链表中唤���线程结点，_EntryList是第一个节点\r\n  _SpinFreq     = 0 ;  \r\n  _SpinClock    = 0 ;  \r\n  OwnerIsThread = 0 ;  \r\n}\r\n~~~\r\n\r\n\r\n\r\n#### d、锁膨胀流程\r\n\r\n![image-20210411170026522](amWiki/images/lib_img/image-20210411170026522.png)\r\n\r\n#### e、加锁流程\r\n\r\n![img](https://img-blog.csdnimg.cn/2020032811351930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxODY1OTgz,size_16,color_FFFFFF,t_70)\r\n\r\n#### f、wait流程\r\n\r\n~~~c++\r\n  //1.调用ObjectSynchronizer::wait方法\r\nvoid ObjectSynchronizer::wait(Handle obj, jlong millis, TRAPS) {\r\n  /*省略 */\r\n  //2.获得Object的monitor对象(即内置锁)\r\n  ObjectMonitor* monitor = ObjectSynchronizer::inflate(THREAD, obj());\r\n  DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), THREAD, millis);\r\n  //3.调用monitor的wait方法\r\n  monitor->wait(millis, true, THREAD);\r\n  /*省略*/\r\n}\r\n  //4.在wait方法中调用addWaiter方法\r\n  inline void ObjectMonitor::AddWaiter(ObjectWaiter* node) {\r\n  /*省略*/\r\n  if (_WaitSet == NULL) {\r\n    //_WaitSet为null，就初始化_waitSet\r\n    _WaitSet = node;\r\n    node->_prev = node;\r\n    node->_next = node;\r\n  } else {\r\n    //否则就尾插\r\n    ObjectWaiter* head = _WaitSet ;\r\n    ObjectWaiter* tail = head->_prev;\r\n    assert(tail->_next == head, \"invariant check\");\r\n    tail->_next = node;\r\n    head->_prev = node;\r\n    node->_next = head;\r\n    node->_prev = tail;\r\n  }\r\n}\r\n  //5.然后在ObjectMonitor::exit释放锁，接着 thread_ParkEvent->park  也就是wait\r\n~~~\r\n\r\n\r\n\r\n![img](https://img-blog.csdnimg.cn/2020032811351930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxODY1OTgz,size_16,color_FFFFFF,t_70)\r\n\r\n#### g、notify流程\r\n\r\n~~~c++\r\n //1.调用ObjectSynchronizer::notify方法\r\n    void ObjectSynchronizer::notify(Handle obj, TRAPS) {\r\n    /*省略*/\r\n    //2.调用ObjectSynchronizer::inflate方法\r\n    ObjectSynchronizer::inflate(THREAD, obj())->notify(THREAD);\r\n}\r\n    //3.通过inflate方法得到ObjectMonitor对象\r\n    ObjectMonitor * ATTR ObjectSynchronizer::inflate (Thread * Self, oop object) {\r\n    /*省略*/\r\n     if (mark->has_monitor()) {\r\n          ObjectMonitor * inf = mark->monitor() ;\r\n          assert (inf->header()->is_neutral(), \"invariant\");\r\n          assert (inf->object() == object, \"invariant\") ;\r\n          assert (ObjectSynchronizer::verify_objmon_isinpool(inf), \"monitor is inva;lid\");\r\n          return inf\r\n      }\r\n    /*省略*/\r\n      }\r\n    //4.调用ObjectMonitor的notify方法\r\n    void ObjectMonitor::notify(TRAPS) {\r\n    /*省略*/\r\n    //5.调用DequeueWaiter方法移出_waiterSet第一个结点\r\n    ObjectWaiter * iterator = DequeueWaiter() ;\r\n    //6.后面省略是将上面DequeueWaiter尾插入_EntrySet的操作\r\n    /**省略*/\r\n  }\r\n~~~\r\n\r\n\r\n\r\n![img](https://img-blog.csdnimg.cn/20200328200119362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxODY1OTgz,size_16,color_FFFFFF,t_70)\r\n\r\n#### h、解锁流程\r\n\r\n![img](https://img-blog.csdnimg.cn/20200328210803767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxODY1OTgz,size_16,color_FFFFFF,t_70)\r\n\r\n### 6、总述\r\n\r\n#### a、整体加锁流程\r\n\r\n![img](https://img-blog.csdnimg.cn/2020032320204669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxODY1OTgz,size_16,color_FFFFFF,t_70)\r\n\r\n#### b、整体解锁流程\r\n\r\n![img](https://img-blog.csdnimg.cn/2020032309275286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxODY1OTgz,size_16,color_FFFFFF,t_70)\r\n\r\n## 五、锁优化\r\n\r\n### 1、锁粗化\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">锁粗化 : </span>\r\n\r\n如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的</br>\r\n\r\n那即使没有出现线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</br>\r\n\r\n如果虚拟机检测到有一串零碎的操作都是对同一对象的加锁，将会把加锁同步的范围扩展（粗化）到</br>\r\n\r\n整个操作序列的外部。</br>\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">举栗子</span>\r\n\r\n~~~java\r\npublic class StringBufferTest {\r\n    StringBuffer stringBuffer = new StringBuffer();\r\n\r\n    public void append(){\r\n        stringBuffer.append(\"a\");\r\n        stringBuffer.append(\"b\");\r\n        stringBuffer.append(\"c\");\r\n    }\r\n}\r\n~~~\r\n\r\n> 这里每次调用stringBuffer.append方法都需要加锁和解锁，如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。\r\n\r\n### 2、锁消除\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">锁消除 : </span>\r\n\r\n即删除不必要的加锁操作。虚拟机即时编辑器在运行时，对一些“代码上要求同步</br>\r\n\r\n但是被检测到不可能存在共享数据竞争”的锁进行消除。</br>\r\n\r\n根据代码<span style=\"color:#42B983;font-weight:bold;\"> 逃逸技术 </span>，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，</br>\r\n\r\n那么可以认为这段代码是线程安全的，不必要加锁。</br>\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">举栗子</span>\r\n\r\n~~~java\r\npublic class SynchronizedTest {\r\n\r\n    public static void main(String[] args) {\r\n        SynchronizedTest test = new SynchronizedTest();\r\n\r\n        for (int i = 0; i < 100000000; i++) {\r\n            test.append(\"abc\", \"def\");\r\n        }\r\n    }\r\n\r\n    public void append(String str1, String str2) {\r\n        StringBuffer sb = new StringBuffer();\r\n        sb.append(str1).append(str2);\r\n    }\r\n}\r\n~~~\r\n\r\n> 虽然StringBuffer的append是一个同步方法，但是这段程序中的StringBuffer属于一个局部变量，并且不会从该方法中逃逸出去（即StringBuffer sb的引用没有传递到该方法外，不可能被其他线程拿到该引用），所以其实这过程是线程安全的，可以将锁消除。\r\n\r\n## 附录\r\n\r\n### 面试经\r\n\r\n1、简述锁膨胀原理？锁粗化、锁消除。。。\r\n\r\n### 解惑\r\n\r\n#### 1、大端模式&小段模式\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">大端模式</span> 是高位字节存储在底地址段，低位字节存储在高地址段</br>\r\n<span style=\"color:#FC5531; font-weight:bold;\">小端模式</span> 是低位字节存储在底地址段，高位字节存储在高地址段</br>\r\n\r\n~~~java\r\n0x 00 00 00 00 00 00 00 01 表示MarkWord的8个字节，最左边就是高位字节，最右边就是地位字节\r\n小端模式在内存中存储顺序：\r\n0x 01 00 00 00 00 00 00 00\r\n大端模式在内存中存储顺序:\r\n0x 00 00 00 00 00 00 00 01\r\n~~~\r\n\r\n#### 2、monitorenter指令实现\r\n\r\n~~~c++\r\n\r\nvoid TemplateTable::monitorenter() {\r\n  //校验当前指令的栈顶缓存类型是否正确\r\n  transition(atos, vtos);\r\n\r\n  //校验rax中值是否为空，栈顶缓存就保存在rax寄存器中，如果为NULL会触发底层操作系统的NULL异常\r\n  //此时rax中保存的是用于获取锁的实例oop\r\n  __ null_check(rax);\r\n\r\n  const Address monitor_block_top(\r\n        rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize);\r\n  const Address monitor_block_bot(\r\n        rbp, frame::interpreter_frame_initial_sp_offset * wordSize);\r\n  const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;\r\n\r\n  Label allocated;\r\n\r\n  //xorl用于按位异或，相同的位置为0，不同的位置为1，此处是将c_rarg1置为NULL\r\n  __ xorl(c_rarg1, c_rarg1); // points to free slot or NULL\r\n\r\n  //找到一个空闲的monitor_block，结果保存在c_rarg1中\r\n  {\r\n    Label entry, loop, exit;\r\n    //将monitor_block_top拷贝到c_rarg3中\r\n    __ movptr(c_rarg3, monitor_block_top); // points to current entry,\r\n                                     // starting with top-most entry\r\n    //将monitor_block_bot拷贝到c_rarg2                             \r\n    __ lea(c_rarg2, monitor_block_bot); // points to word before bottom\r\n                                     // of monitor block\r\n    //跳转到entry标签处执行                     \r\n    __ jmpb(entry);\r\n\r\n    __ bind(loop);\r\n    //判断c_rarg3指向的BasicObjectLock的obj属性是否为空，如果为空表示未使用\r\n    __ cmpptr(Address(c_rarg3, BasicObjectLock::obj_offset_in_bytes()), (int32_t) NULL_WORD);\r\n    //如果相等，即BasicObjectLock的obj属性为空，则将c_rarg3的值拷贝到c_rarg1\r\n    __ cmov(Assembler::equal, c_rarg1, c_rarg3);\r\n    // 判断c_rarg3指向的BasicObjectLock的obj属性与rax中实例是否一致\r\n    __ cmpptr(rax, Address(c_rarg3, BasicObjectLock::obj_offset_in_bytes()));\r\n    // 如果一致则退出，一致说明BasicObjectLock的obj属性不为空，此时c_rarg1为空，就是重新分配一个新的\r\n    __ jccb(Assembler::equal, exit);\r\n    // 如果不一致则把c_rarg3地址加上entry_size，即开始遍历前面一个monitor_block，即存在空闲的，但是没有obj属性相同的时候会把所有的\r\n    //BasicObjectLock都遍历一遍，找到最上面的地址最大一个空闲的BasicObjectLock\r\n    __ addptr(c_rarg3, entry_size);\r\n    __ bind(entry);\r\n    //判断两个寄存器的值是否相等\r\n    __ cmpptr(c_rarg3, c_rarg2);\r\n    //如果不等于则跳转到loop标签，否则跳转到exit\r\n    __ jcc(Assembler::notEqual, loop);\r\n    __ bind(exit);\r\n  }\r\n\r\n  //判断c_rarg1是否为空，如果不为空则跳转到allocated处\r\n  __ testptr(c_rarg1, c_rarg1); // check if a slot has been found\r\n  __ jcc(Assembler::notZero, allocated); // if found, continue with that one\r\n\r\n  //如果没有找到空闲的monitor_block则分配一个\r\n  {\r\n    Label entry, loop;\r\n    // 将monitor_block_bot拷贝到c_rarg1            // rsp: old expression stack top\r\n    __ movptr(c_rarg1, monitor_block_bot); // c_rarg1: old expression stack bottom\r\n    //向下（低地址端）移动rsp指针entry_size字节\r\n    __ subptr(rsp, entry_size);            // move expression stack top\r\n    //将c_rarg1减去entry_size\r\n    __ subptr(c_rarg1, entry_size);        // move expression stack bottom\r\n    //将rsp拷贝到c_rarg3\r\n    __ mov(c_rarg3, rsp);                  // set start value for copy loop\r\n    //将c_rarg1中的值写入到monitor_block_bot\r\n    __ movptr(monitor_block_bot, c_rarg1); // set new monitor block bottom\r\n    //跳转到entry处开始循环\r\n    __ jmp(entry);\r\n    // 2.移动monitor_block_bot到栈顶的数据，将从栈顶分配的一个monitor_block插入到原来的monitor_block_bot下面\r\n    __ bind(loop);\r\n    //将c_rarg3之后的entry_size处的地址拷贝到c_rarg2，即原来的rsp地址\r\n    __ movptr(c_rarg2, Address(c_rarg3, entry_size)); // load expression stack\r\n                                                      // word from old location\r\n    //将c_rarg2中的数据拷贝到c_rarg3处，即新的rsp地址                                                  \r\n    __ movptr(Address(c_rarg3, 0), c_rarg2);          // and store it at new location\r\n    //c_rarg3加上一个字宽，即准备复制下一个字宽的数据\r\n    __ addptr(c_rarg3, wordSize);                     // advance to next word\r\n    __ bind(entry);\r\n    //比较两个寄存器的值\r\n    __ cmpptr(c_rarg3, c_rarg1);            // check if bottom reached\r\n    //如果不等于则跳转到loop\r\n    __ jcc(Assembler::notEqual, loop);      // if not at bottom then\r\n                                            // copy next word\r\n  }\r\n\r\n  // call run-time routine\r\n  // c_rarg1: points to monitor entry\r\n  __ bind(allocated);\r\n\r\n  //增加r13，使其指向下一个字节码指令\r\n  __ increment(r13);\r\n\r\n  //将rax中保存的获取锁的oop保存到c_rarg1指向的BasicObjectLock的obj属性中\r\n  __ movptr(Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()), rax);\r\n  //获取锁\r\n  __ lock_object(c_rarg1);\r\n\r\n  //保存bcp，为了出现异常时能够返回到原来的执行位置\r\n  __ save_bcp();  // in case of exception\r\n  __ generate_stack_overflow_check(0);\r\n\r\n  //恢复字节码指令的正常执行\r\n  //因为上面已经增加r13了，所以此处dispatch_next的第二个参数使用默认值0，即执行r13指向的字节码指令即可，不用跳转到下一个指令\r\n  __ dispatch_next(vtos);\r\n}\r\n\r\nvoid InterpreterMacroAssembler::lock_object(Register lock_reg) {\r\n  assert(lock_reg == c_rarg1, \"The argument is only for looks. It must be c_rarg1\");\r\n\r\n  //UseHeavyMonitors表示是否只使用重量级锁，默认为false，如果为true则调用InterpreterRuntime::monitorenter方法获取重量级锁\r\n  if (UseHeavyMonitors) {\r\n    call_VM(noreg,\r\n            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\r\n            lock_reg);\r\n  } else {\r\n    Label done;\r\n\r\n    const Register swap_reg = rax; // Must use rax for cmpxchg instruction\r\n    const Register obj_reg = c_rarg3; // Will contain the oop\r\n\r\n    const int obj_offset = BasicObjectLock::obj_offset_in_bytes();\r\n    const int lock_offset = BasicObjectLock::lock_offset_in_bytes ();\r\n    const int mark_offset = lock_offset +\r\n                            BasicLock::displaced_header_offset_in_bytes();\r\n\r\n    Label slow_case;\r\n\r\n    //进入此方法目标obj要么是无锁状态，要么是对同一个对象的synchronized嵌套情形下的有锁状态\r\n    //将用于获取锁的实例oop拷贝到obj_reg中\r\n    movptr(obj_reg, Address(lock_reg, obj_offset));\r\n\r\n    //UseBiasedLocking默认为true\r\n    if (UseBiasedLocking) {\r\n      //首先尝试获取偏向锁，获取成功会跳转到done，否则走到slow_case\r\n      biased_locking_enter(lock_reg, obj_reg, swap_reg, rscratch1, false, done, &slow_case);\r\n    }\r\n\r\n    //如果UseBiasedLocking为false或者目标对象的锁不是偏向锁了会走此逻辑\r\n    movl(swap_reg, 1);\r\n\r\n    //计算 object->mark() | 1，结果保存到swap_reg，跟1做或运算将其标记为无锁状态\r\n    orptr(swap_reg, Address(obj_reg, 0));\r\n\r\n    //将(object->mark() | 1)的结果保存到BasicLock的displaced_header中，保存原来的对象头\r\n    movptr(Address(lock_reg, mark_offset), swap_reg);\r\n\r\n    //lock_reg即是里面的lock属性的地址\r\n    assert(lock_offset == 0,\r\n           \"displached header must be first word in BasicObjectLock\");\r\n\r\n    if (os::is_MP()) lock(); //如果是多核系统，通过lock指令保证cmpxchgp的操作是原子的，即只可能有一个线程操作obj对象头\r\n    //将obj的对象头同rax即swap_reg比较，如果相等将lock_reg写入obj对象头，即lock属性写入obj对象头，如果不等于则将obj对象头放入rax中\r\n    cmpxchgptr(lock_reg, Address(obj_reg, 0));\r\n    if (PrintBiasedLockingStatistics) {\r\n      //增加计数器\r\n      cond_inc32(Assembler::zero,\r\n                 ExternalAddress((address) BiasedLocking::fast_path_entry_count_addr()));\r\n    }\r\n    //如果等于，说明obj的对象头是无锁状态的，此时跟1做或运算，结果不变\r\n    jcc(Assembler::zero, done);\r\n\r\n    //如果不等于，说明obj的对象头要么是偏向锁，要么是重量级锁，多线程下可能其他线程已经获取了该对象的轻量级锁\r\n    //下面的汇编指令相当于执行如下判断，判断目标对应的对象头是否属于当前调用栈帧，如果是说明还是当前线程占有该轻量级锁，如果不是则说明其他线程占用了轻量级锁或者已经膨胀成重量级锁\r\n    //  1) (mark & 7) == 0, and\r\n    //  2) rsp <= mark < mark + os::pagesize()\r\n    subptr(swap_reg, rsp);\r\n    andptr(swap_reg, 7 - os::vm_page_size());\r\n\r\n    //在递归即synchronized嵌套使用的情形下，上述指令计算的结果就是0\r\n    //当BasicLock的displaced_header置为NULL\r\n    movptr(Address(lock_reg, mark_offset), swap_reg);\r\n    if (PrintBiasedLockingStatistics) {\r\n      //增加计数器\r\n      cond_inc32(Assembler::zero,\r\n                 ExternalAddress((address) BiasedLocking::fast_path_entry_count_addr()));\r\n    }\r\n    //如果andptr的结果为0，说明当前线程已经获取了轻量级锁则跳转到done\r\n    jcc(Assembler::zero, done);\r\n    //否则执行InterpreterRuntime::monitorenter将轻量级锁膨胀成重量级锁或者获取重量级锁\r\n    bind(slow_case);\r\n\r\n    // Call the runtime routine for slow case\r\n    call_VM(noreg,\r\n            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\r\n            lock_reg);\r\n\r\n    bind(done);\r\n  }\r\n}\r\n~~~\r\n\r\n#### 3、monitorexit指令实现\r\n\r\n~~~c++\r\nvoid TemplateTable::monitorexit() {\r\n  //检查栈顶缓存的类型是否正确\r\n  transition(atos, vtos);\r\n\r\n  //检查rax包含的跟锁关联的对象oop是否为空\r\n  __ null_check(rax);\r\n\r\n  const Address monitor_block_top(\r\n        rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize);\r\n  const Address monitor_block_bot(\r\n        rbp, frame::interpreter_frame_initial_sp_offset * wordSize);\r\n  const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;\r\n\r\n  Label found;\r\n\r\n  // find matching slot\r\n  {\r\n    Label entry, loop;\r\n    //把monitor_block_top拷贝到c_rarg1\r\n    __ movptr(c_rarg1, monitor_block_top); // points to current entry,\r\n                                     // starting with top-most entry\r\n    //把monitor_block_bot拷贝到c_rarg2                    \r\n    __ lea(c_rarg2, monitor_block_bot); // points to word before bottom\r\n                                     // of monitor block\r\n    __ jmpb(entry);\r\n\r\n    __ bind(loop);\r\n    //比较rax中对象oop与obj属性是否一致\r\n    __ cmpptr(rax, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));\r\n    //如果一致则表示找到了跳转到found\r\n    __ jcc(Assembler::equal, found);\r\n    //如果没有找到则增加entry_size，即开始遍历前面一个BasicObjectLock\r\n    __ addptr(c_rarg1, entry_size);\r\n    __ bind(entry);\r\n    //比较这两个是否相等，如果相等表示遍历完成\r\n    __ cmpptr(c_rarg1, c_rarg2);\r\n    //如果不等则跳转到loop标签\r\n    __ jcc(Assembler::notEqual, loop);\r\n  }\r\n\r\n  //没有在当前线程的栈帧中找到关联的BasicObjectLock，抛出异常\r\n  __ call_VM(noreg, CAST_FROM_FN_PTR(address,\r\n                   InterpreterRuntime::throw_illegal_monitor_state_exception));\r\n  __ should_not_reach_here();\r\n\r\n  // call run-time routine\r\n  // rsi: points to monitor entry\r\n  __ bind(found);\r\n  //将这个锁对象放入栈帧中\r\n  __ push_ptr(rax); // make sure object is on stack (contract with oopMaps)\r\n  //执行解锁逻辑\r\n  __ unlock_object(c_rarg1);\r\n  //从栈帧中弹出锁对象\r\n  __ pop_ptr(rax); // discard object\r\n}\r\n\r\nvoid InterpreterMacroAssembler::unlock_object(Register lock_reg) {\r\n  assert(lock_reg == c_rarg1, \"The argument is only for looks. It must be rarg1\");\r\n\r\n  if (UseHeavyMonitors) {\r\n    //如果只使用重量级锁，UseHeavyMonitors默认为false\r\n    call_VM(noreg,\r\n            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit),\r\n            lock_reg);\r\n  } else {\r\n    Label done;\r\n\r\n    const Register swap_reg   = rax;  // Must use rax for cmpxchg instruction\r\n    const Register header_reg = c_rarg2;  // Will contain the old oopMark\r\n    const Register obj_reg    = c_rarg3;  // Will contain the oop\r\n\r\n    save_bcp(); //保存bcp，方便解锁异常时回滚\r\n\r\n    //将lock属性的地址复制到swap_reg\r\n    lea(swap_reg, Address(lock_reg, BasicObjectLock::lock_offset_in_bytes()));\r\n\r\n    //将obj属性复制到obj_reg\r\n    movptr(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()));\r\n\r\n    //将obj属性置为NULL\r\n    movptr(Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()), (int32_t)NULL_WORD);\r\n\r\n    if (UseBiasedLocking) {\r\n      //如果持有偏向锁，则解锁完成后跳转到done\r\n      biased_locking_exit(obj_reg, header_reg, done);\r\n    }\r\n\r\n    //将BasicLock的displaced_header属性复制到header_reg中，即该对象原来的对象头\r\n    movptr(header_reg, Address(swap_reg,\r\n                               BasicLock::displaced_header_offset_in_bytes()));\r\n\r\n    //判断这个是否为空\r\n    testptr(header_reg, header_reg);\r\n\r\n    //如果为空说明这是对同一目标对象的synchronized嵌套情形，则跳转到done，等到外层的synchronized解锁恢复目标对象的对象头\r\n    jcc(Assembler::zero, done);\r\n\r\n    // Atomic swap back the old header\r\n    if (os::is_MP()) lock();//如果是多核系统则通过lock指令前缀将cmpxchg变成一个原子操作，即只能有一个线程同时操作obj的对象头\r\n    //将obj的对象头同rax即swap_reg，即lock属性地址比较，如果相等把header_reg写入到obj的对象头中即恢复对象头，如果不等把obj对象头写入rax中\r\n    cmpxchgptr(header_reg, Address(obj_reg, 0));\r\n\r\n    //如果相等，说明还是轻量级锁，解锁完成\r\n    jcc(Assembler::zero, done);\r\n\r\n    //如果不等于，说明轻量级锁被膨胀成重量级锁，恢复obj属性，因为上面将该属性置为NULL\r\n    movptr(Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()),\r\n         obj_reg); // restore obj\r\n    //调用InterpreterRuntime::monitorexit，完成重量级锁退出     \r\n    call_VM(noreg,\r\n            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit),\r\n            lock_reg);\r\n\r\n    bind(done);\r\n    //恢复bcp\r\n    restore_bcp();\r\n  }\r\n}\r\n\r\n//偏向锁的解锁只是判断目标对象是否持有偏向锁，如果持有就跳转到done，没有实际的解锁动作\r\nvoid MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label& done) {\r\n  assert(UseBiasedLocking, \"why call this otherwise?\");\r\n  //将obj的对象头拷贝到temp_reg\r\n  movptr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\r\n  //将对象头指针同biased_lock_mask_in_place求且\r\n  andptr(temp_reg, markOopDesc::biased_lock_mask_in_place);\r\n  //判断且运算后的结果是否是5\r\n  cmpptr(temp_reg, markOopDesc::biased_lock_pattern);\r\n  //如果相等则跳转到done\r\n  jcc(Assembler::equal, done);\r\n}\r\n~~~\r\n\r\n#### 4、自适应的自旋锁\r\n\r\n* 简述\r\n\r\n  JDK1.6引入自适应的自旋锁，自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：如果在同一个锁的对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。简单来说，就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。\r\n\r\n* 场景\r\n\r\n  从轻量级锁获取的流程中我们知道，当线程在获取轻量级锁的过程中执行CAS操作失败时，是要通过自旋来获取重量级锁的。（见前面“轻量级锁”）\r\n\r\n### 参考\r\n\r\n[深入理解synchronized底层源码，小白这篇足够了_MarkJava-CSDN博客](https://blog.csdn.net/realize_dream/article/details/106968443)\r\n\r\n[深入OpenJDK源码核心探秘Unsafe(含JNI完整使用流程)_黄智霖的博客-CSDN博客](https://blog.csdn.net/huangzhilin2015/article/details/101158137)\r\n\r\n[synchronized的锁升级过程和详细的代码演示_killerofjava的博客-CSDN博客](https://blog.csdn.net/killerofjava/article/details/112445366)\r\n\r\n[Hotspot synchronized与volatile关键字实现（一） 源码解析_菜鸟进阶之路-CSDN博客](https://blog.csdn.net/qq_31865983/article/details/104875342)\r\n\r\n[Hotspot 三种锁实现总结_菜鸟进阶之路-CSDN博客](https://blog.csdn.net/qq_31865983/article/details/105024397)\r\n\r\n[死磕Synchronized底层实现--重量级锁-Java架构笔记-51CTO博客](https://blog.51cto.com/14440216/2427707?source=dra)\r\n","timestamp":1642514536573},{"name":"01-分布式基础.md","path":"02-java篇/02-技术栈/04-分布式/01-分布式基础.md","content":"# 分布式基础\r\n\r\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2021年4月26日07:16:41</span>\r\n\r\n## 一、分布式概述\r\n\r\n### 1、什么是分布式\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述：</span> 早期我们使用单体架构，即所有服务部署在一台服务器的一个进程中，随着互联网的发展，逐步演进为\r\n分布式架构，拆分业务，针对不同也业务（可独立）部署独立的微服务。\r\n\r\n![image-20210426225057669](amWiki/images/lib_img/image-20210426225057669.png)\r\n\r\n:anchor:  要理解分布式系统，主要需要明白一下2个方面：\r\n\r\n- <span style=\"color:#FC5531; font-weight:bold;\">分布式系统一定是由多个节点组成的系统。</span>\r\n  其中，节点指的是计算机服务器，而且这些节点一般不是孤立的，而是互通的。\r\n  \r\n- <span style=\"color:#FC5531; font-weight:bold;\">这些连通的节点上部署了我们的节点，并且相互的操作会有协同.</span>\r\n\r\n  ![image-20210426225119472](amWiki/images/lib_img/image-20210426225119472.png)\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">综：</span><span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px\">分布式系统对于用户而言，他们面对的就是一个服务器，提供用户需要的服务而已</span></br>\r\n<span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px\">而实际上这些服务是通过背后的众多服务器组成的一个分布式系统，</span></br>\r\n<span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px\">因此分布式系统看起来像是一个超级计算机一样。</span></br>\r\n\r\n###  2、分布式特点\r\n\r\n#### a、特征\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">增大系统容量</span> 我们的业务量越来越大，而要能应对越来越大的业务量，一台机器的性能已经无法满足了，我们需要多台机器才能应对大规模的应用场景。所以，我们需要垂直或是水平拆分业务系统，让其变成一个分布式的架构。\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">加强系统可用</span> 我们的业务越来越关键，需要提高整个系统架构的可用性，这就意味着架构中不能存在单点故障。这样，整个系统不会因为一台机器出故障而导致整体不可用。所以，需要通过分布式架构来冗余系统以消除单点故障，从而提高系统的可用性。\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">模块化 </span> 因为模块化，所以 系统模块重用度更高\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">高效开发 </span>因为软件服务模块被拆分，开发和发布速度可以并行而变得更快\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">扩展性</span> 系统扩展性更高\r\n\r\n* 团队协作流程也会得到改善\r\n\r\n#### b、类型\r\n\r\n:anchor:  分布式系统类型大致有三种：</br>\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">分布式 ：</span><span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">分布式处理，但只有一个总数据库，没有局部数据库</span></br>\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">分层式：</span><span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">分层式处理，每一层都有自己的数据库</span></br>\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">充分分散：</span> <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">充分分散的分布式网络，没有中央控制部分，各节点之间的联系方式又可以有多种，如松散的联接，紧密的联接，动态的联接，广播通知式的联接等</span></br>\r\n\r\n###  3、实现方式\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">分布式应用用到的技术：</span>  <span style=\"color:#FC5531; font-weight:bold;\">网络通信</span>，基于  <span style=\"color:#FC5531;border-bottom:1px dashed #000; font-weight:bold;\">消息方式</span>  的系统间通信和基于  <span style=\"color:#FC5531; font-weight:bold;border-bottom:1px dashed #000;\">远程调用</span>  的系统间通信。</br>\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">缺点：</span> 就是会增加技术的复杂度。</br>\r\n基于消息的系统通信方式，主要是利用的网络协议，比如 TCP/IP 协议。</br>\r\n系统间的通信还需要对数据进行处理，比如同步 IO 和异步 IO。</br>\r\n远程调用实现系统间的通信:通过调用本地的java接口的方法来透明的调用远程java的实现。具体的细节有框架来实现。\r\n\r\n\r\n\r\n##  二、CAP 原则\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述：</span> CAP原则又称CAP定理，指的是在一个分布式系统中，<span style=\"color:#FC5531; font-weight:bold;\">一致性（Consistency）</span>、<span style=\"color:#FC5531; font-weight:bold;\">可用性（Availability）</span>、<span style=\"color:#FC5531; font-weight:bold;\">分区容错性（Partition tolerance）</span>。</br>\r\n\r\n<span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。</span>\r\n\r\n![image-20210426225203614](amWiki/images/lib_img/image-20210426225203614.png)\r\n\r\n### 1、CAP\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">一致性（C）：</span>在分布式系统中的所有数据备份，在同一时刻是否同样的值，**即写操作之后的读操作，必须返回该值**。（分为弱一致性、强一致性和最终一致性；这里说的是“强一致性”）\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">可用性（A）：</span>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">分区容忍性（P）：</span>以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。\r\n\r\n\r\n\r\n### 2、取舍策略\r\n\r\n#### CA without P\r\n\r\n<span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。</span>\r\n但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。\r\n\r\n#### CP without A\r\n\r\n<span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)</span>\r\n一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。\r\n\r\n#### AP without C\r\n\r\n<span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">要高可用并允许分区，则需放弃一致性。</span>\r\n一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性\r\n\r\n### 3、主要矛盾 C & A\r\n\r\n:mag_right:  CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于网络硬件肯定会出现延迟丢包等问题，所以分区容错性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。\r\n\r\n\r\n\r\n### 4、解决方法—BASE\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">基本可用Basically Available</span>\r\n\r\n<span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#FC5531\">基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性</span>——但请注意，这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子。\r\n\r\n- 响应时间上的损失：正常情况下，一个在线搜索引擎需要0.5秒内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。\r\n- 功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">软状态Soft state</span>\r\n\r\n软状态也称弱状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即<span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#FC5531\">允许系统在不同节点的数据副本之间进行数据同步的过程存在延时</span>。\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">最终一致性Eventually consistent</span>\r\n\r\n<span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#FC5531\">最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。</span>因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。\r\n\r\n\r\n\r\n## 三、一致性协议\r\n\r\n>  数据在跨越多个分布式节点时，为了保障食物的ACID事务，需要一个协调者来协调分布式各个节点的调度，基于这个思想衍生了一致性协议\r\n\r\n###  1、二阶段提交（2PC）\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述：</span> 两阶段提交协议，简称2PC，是比较常用的解决分布式事务问题的方式，要么所有参与进程都提交事务，要么都取消事务，即实现ACID中的原子性(A)的常用手段</br>\r\n\r\n<span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">两阶段提交将提交过程划分为连续的两个阶段：</span> <span style=\"color:#FC5531; font-weight:bold;\">表决阶段(Voting)</span> 和 <span style=\"color:#FC5531; font-weight:bold;\">提交阶段(Commit)。</span> \r\n\r\n![image-20210426225228086](amWiki/images/lib_img/image-20210426225228086.png)\r\n\r\n#### ☛ 事务流程\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">第一阶段</span> <span style=\"color:#0081EF; font-weight:bold;\">提交事务请求</span>\r\n\r\n  1、协调者向所有的参与者节点发送事务内容，询问是否可以执行事务操作，并等待其他参与者节点的反馈\r\n\r\n  2 、各参与者节点执行事务操作\r\n\r\n  3 、各参与者节点反馈给协调者，事务是否可以执行\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">第二阶段</span> <span style=\"color:#0081EF; font-weight:bold;\">事务提交</span>\r\n\r\n  根据一阶段各个参与者节点反馈的 ack, 如果所有参与者节点反馈 ack ，则执行事务提交，否则中断事务\r\n  事务提交：\r\n  1 、协调者向各个参与者节点发送 commit 请求\r\n  2 、参与者节点接受到 commit 请求后，执行事务的提交操作\r\n  3 、各参与者节点完成事务提交后，向协调者返送提交 commit 成功确认消息\r\n  4 、协调者接受各个参与者节点的 ack 后，完成事务 commit\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">异常阶段</span> <span style=\"color:#FC5531; font-weight:bold;\">中断事务</span>\r\n\r\n  1 、发送回滚请求\r\n\r\n  2 、各个参与者节点回滚事务\r\n\r\n  3 、反馈给协调者事务回滚结果\r\n\r\n  4 、协调者接受各参与者节点 ack 后回滚事务\r\n\r\n#### ☛ 存在问题\r\n\r\n*  <span style=\"color:#FC5531; font-weight:bold;\">同步阻塞</span>\r\n    二阶段提交过程中，所有参与事务操作的节点处于同步阻塞状态，无法进行其他的操作\r\n*  <span style=\"color:#FC5531; font-weight:bold;\">单点问题</span>\r\n    一旦协调者出现单点故障，无法保证事务的一致性操作\r\n*  <span style=\"color:#FC5531; font-weight:bold;\">脑裂导致数据不一致</span>\r\n    如果分布式节点出现网络分区，某些参与者未收到 commit 提交命令。则出现部分参与者完成数据提\r\n    交。未收到 commit 的命令的参与者则无法进行事务提交，整个分布式系统便出现了数据不一致性现\r\n    象。\r\n\r\n\r\n\r\n### 2、三阶段提交（3PC）\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述：</span> 3PC 是 2PC 的改进版，实质是将 2PC 中提交事务请求拆分为两步，形成了 CanCommit 、 PreCommit 、\r\ndoCommit 三个阶段的事务一致性协议\r\n\r\n![image-20210426225248155](amWiki/images/lib_img/image-20210426225248155.png)\r\n\r\n#### ☛ 事务流程\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">阶段一 :</span>  <span style=\"color:#0081EF; font-weight:bold;\">CanCommit</span>\r\n  1 、事务询问\r\n  2 、各参与者节点向协调者反馈事务询问的响应\r\n* <span style=\"color:#42B983;font-weight:bold;\">阶段二 :</span> <span style=\"color:#0081EF; font-weight:bold;\">PreCommit</span>\r\n  根据阶段一的反馈结果分为两种情况\r\n  * 执行事务预提交\r\n    1 ）发送预提交请求\r\n    协调者向所有参与者节点发送 preCommit 请求，进入 prepared 阶段\r\n    2 ）事务预提交\r\n    各参与者节点接受到 preCommit 请求后，执行事务操作\r\n    3 ）各参与者节点向协调者反馈事务执行\r\n  * <span style=\"color:#42B983;font-weight:bold;\">异常阶段</span> <span style=\"color:#FC5531; font-weight:bold;\">中断事务</span>\r\n    任意一个参与者节点反馈给协调者响应 No 时，或者在等待超时后，协调者还未收到参与者的反\r\n    馈，就中断事务，中断事务分为两步：\r\n    1 ）协调者向各个参与者节点发送 abort 请求\r\n    2 ）参与者收到 abort 请求，或者等待超时时间后，中断事务\r\n* <span style=\"color:#42B983;font-weight:bold;\">阶段三 : </span><span style=\"color:#0081EF; font-weight:bold;\">doCommit</span>\r\n  * 执行提交\r\n    1 ）发送提交请求\r\n    协调者向所有参与者节点发送 doCommit 请求\r\n    2 ）事务提交\r\n    各参与者节点接受到 doCommit 请求后，执行事务提交操作\r\n    3 ）反馈事务提交结果 北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090\r\n    各参与者节点完成事务提交以后，向协调者发送 ack\r\n    4 ）事务完成\r\n    协调者接受各个参与者反馈的 ack 后，完成事务\r\n  * <span style=\"color:#42B983;font-weight:bold;\">异常阶段</span> <span style=\"color:#FC5531; font-weight:bold;\">中断事务</span>\r\n    1 ）参与者接受到 abort 请求后，执行事务回滚\r\n    2 ）参与者完成事务回滚以后，向协调者发送 ack\r\n    3 ）协调者接受回滚 ack 后，回滚事务\r\n\r\n\r\n#### ☛ 存在问题\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">网络分区</span>   3PC 相较于 2PC 而言，解决了协调者挂点后参与者无限阻塞和单点问题，但是仍然无法解决网络分区问题\r\n\r\n### 3、NWR协议\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述：</span>NWR是一种在分布式存储系统中用于控制一致性级别的一种策略。\r\n\r\n#### ☛ NWR含义\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">N：</span><span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">在分布式存储系统中，有多少份备份数据</span>\r\n* <span style=\"color:#FC5531; font-weight:bold;\">W：</span><span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">代表一次成功的更新操作要求至少有w份数据写入成功 </span>\r\n* <span style=\"color:#FC5531; font-weight:bold;\">R：</span> <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">代表一次成功的读数据操作要求至少有R份数据成功读取</span>\r\n\r\n\r\n\r\n#### ☛ 实例说明\r\n\r\nNWR值的不同组合会产生不同的一致性效果，当W+R>N的时候，整个系统对于客户端来讲能保证强一致性。\r\n\r\n* 当W+R 以常见的N=3、W=2、R=2为例：\r\n  * N=3表示，任何一个对象都必须有三个副本（Replica）\r\n  * W=2表示，对数据的修改操作（Write）只需要在3个Replica中的2个上面完成就返回\r\n  * R=2表示，从三个对象中要读取到2个数据对象，才能返回。\r\n\r\n在分布式系统中，<span style=\"color:#FC5531; font-weight:bold;\">数据的单点是不允许存在的</span>。</br>\r\n\r\n![image-20210426225311723](amWiki/images/lib_img/image-20210426225311723.png)\r\n\r\n<span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;\">即线上正常存在的Replica数量是1的情况是非常危险的，因为一旦这个Replica再次错误，就 可能发生数据的永久性错误。</span> </br>\r\n\r\n<span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">假如我们把N设置成为2，那么，只要有一个存储节点发生损坏，就会有单点的存在。</span> </br>\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">所以N必须大于2。N约高，系统的维护和整体 成本就越高。工业界通常把N设置为3。</span> </br>\r\n当W是2、R是2的时候，W+R>N，这种情况对于客户端就是强一致性的。</br>\r\n当W是1、R是1的时候，W+R<N，这种情况对于客户端就是最终一致性的。</br>\r\n\r\n\r\n\r\n### 4、paxos协议\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述：</span> 解决的问题是一个[分布式系统](https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F)如何就某个值（决议）达成一致，是一种基于消息传递模型的一致性算法。\r\n\r\n#### ☛ paxos算法\r\n\r\n* Paxos 算法主要包含两个部分：\r\n  * <span style=\"color:#FC5531; font-weight:bold;\">Basic Paxos 算法：</span>多个节点之间如何就某个值达成共识。（这个值我们称作`提案 Value`）\r\n  * <span style=\"color:#FC5531; font-weight:bold;\">Multi-Paxos 算法：</span>执行多个 Basic Paxos 实例，就一系列值达成共识。\r\n\r\n  Basic Paxos 算法是 Multi-Paxos 思想的核心，Multi 的意思就是多次，也就是说多执行几次 Basic Paxos 算法。所以 Basic Paxos 算法是重中之重。\r\n\r\n#### ☛ paxos角色\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">提案：</span>提案内容包括两部内容：<span style=\"color:#FC5531; font-weight:bold;\">提案编号</span> &  <span style=\"color:#FC5531; font-weight:bold;\">提案内容</span>（提议值）\r\n\r\n![image-20210426225345049](amWiki/images/lib_img/image-20210426225345049.png)\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">提议者（Proposer）</span>\r\n  * <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;\">提议一个值（提案），用于投票表决。</span>\r\n  * <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;\">接入和协调，收到客户端的请求后，可以发起二阶段提交，进行共识协商。</span>\r\n* <span style=\"color:#42B983;font-weight:bold;\">接受者（Acceptor）</span>\r\n  * <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;\">对每个提案的值进行投票，并存储接受的值。</span>\r\n  * <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;\">投票协商和存储数据，对提议的值进行投票，并接受达成共识的值，存储保存。</span>\r\n  * <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;\">集群中所有的节点都在扮演接受者的角色，参与共识协商，并接受和存储数据。</span>\r\n* <span style=\"color:#42B983;font-weight:bold;\">学习者（Learner）</span>\r\n  * <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;\">被告知投票的结果，接受达成共识的值，存储数据，</span>\r\n  * <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;\">不参与投票的过程，即不参与共识协商。</span>\r\n\r\n#### ☛ Paxos 算法推导\r\n\r\n- <span style=\"color:#FC5531; font-weight:bold;\">准备阶段</span> <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">由提案者 向所有节点发送提案编号；收到提案编号的节点做出响应</span>\r\n\r\n  - 发送准备请求\r\n\r\n    ![image-20210426225409638](amWiki/images/lib_img/image-20210426225409638.png)\r\n  \r\n- 响应准备请求（一）\r\n  \r\n  - 按照接受请求的时间顺序，**关羽** 和 **张飞** 收到 `诸葛亮`的请求`[1，空]`，**赵云** 收到`庞统`的请求`[2，空]`。\r\n  \r\n  ![image-20210426225430892](amWiki/images/lib_img/image-20210426225430892.png)\r\n  \r\n    - <span style=\"color:#FC5531; font-weight:bold;\">阐述点1 ：</span>因为**关羽**、**张飞**之前没有收到提案，所以返回一个尚无提案的响应。也就是告诉 `诸葛亮`，不会再响应编号小于等于 1 的准备请求了，也不会通过编号小于 1 的提案。响应的时间点是 14 点和 15 点。\r\n  - <span style=\"color:#FC5531; font-weight:bold;\">阐述点2：</span>而**赵云**之前也没有收到提案，所以返回一个尚无提案的响应。也就是告诉`庞统`，不会再响应编号小于等于 2 的准备请求了，也不会通过编号小于 2 的提案。响应的时间点是 16 点。\r\n  \r\n- 响应准备请求（二）\r\n  \r\n  ![image-20210426225451418](amWiki/images/lib_img/image-20210426225451418.png)\r\n  \r\n    - <span style=\"color:#FC5531; font-weight:bold;\">阐述点1 ：</span>而对于`庞统`的准备请求，**关羽**、**张飞**收到编号为 2 的准备请求，而 编号 2 大于之前接受到的编号 1 ，而且**关羽**和**张飞**没有通过任何提案，所以还是会返回给`庞统`一个尚无提案 的响应。也就是告诉`庞统`不会再响应编号小于等于 2 的准备请求了，也不会通过编号小于 2 的提案。响应的时间点是 14 点和 15 点。\r\n    - <span style=\"color:#FC5531; font-weight:bold;\">阐述点2 ：</span>而**赵云**最后收到 `诸葛亮`编号为 1 的准备请求后，因编号 1小于之前响应的准备请求的提案编号 2，所以直接丢弃该准备请求，不做响应，如上图的 ❌ 图示。\r\n\r\n\r\n\r\n\r\n\r\n\r\n- <span style=\"color:#FC5531; font-weight:bold;\">接受阶段</span>  <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">由提案者 依据上一阶段节点的响应，发送提案值</span>\r\n\r\n  - 发送接受请求\r\n\r\n    - `诸葛亮`  和  `庞统` 收到准备响应后，分别发送接受请求（发送提案值）\r\n\r\n      ![image-20210426225509421](amWiki/images/lib_img/image-20210426225509421.png)\r\n\r\n    - <span style=\"color:#FC5531; font-weight:bold;\">阐述点1 ：</span> `诸葛亮`收到大多数接受者（关羽和张飞）的`准备响应`后，根据响应中提案编号最大的提案的值，设置`接受请求`中的值。因为关羽和张飞返回的准备响应都是尚无提案，所以还是发送提案编号为 `1`，提案值为`北`的`接受请求`，`北`代表从北边进攻曹操。发送的时间点是 **15 点过 1 分、16 点**。\r\n\r\n    - <span style=\"color:#FC5531; font-weight:bold;\">阐述点2 ：</span> `庞统`收到大多数接受者（关羽、张飞和赵云）的`准备响应`后，根据响应中提案编号最大的提案的值，，设置`接受请求`中的值。因为关羽、张飞和赵云返回的准备响应都是尚无提案，所以还是发送提案编号为 `2`，提案值为`南`的`接受请求`，`南`代表从南边进攻曹操。发送的时间点是 **18 点、19 点、20 点**。\r\n\r\n\r\n\r\n\r\n\r\n\r\n  - 收到接受请求\r\n\r\n    - 当**关羽**、**张飞**、**赵云**收到`诸葛亮`  和 `庞统`的`接受请求`后，会进行如下处理，\r\n\r\n      ![image-20210426225529805](amWiki/images/lib_img/image-20210426225529805.png)\r\n\r\n    - <span style=\"color:#FC5531; font-weight:bold;\">阐述点1 ：</span> **关羽**、**张飞**、**赵云**收到诸葛亮发送的提案 [1，北]时候，因为提案编号 `1`小于他们承诺的能通过的提案的最小提案编号 `2`，所以诸葛亮的提案被拒绝了。\r\n\r\n    - <span style=\"color:#FC5531; font-weight:bold;\">阐述点2 ：</span> 在收到庞统的发送的提案 [2，南] 的时候，因为编号 2 不小于之前承诺的编号 2，所以通过庞统的提案 [2，南] ，所以**关羽**、**张飞**、**赵云**他们的作战计划是从南边进攻曹操。**达成了共识**。\r\n\r\n#### ☛ Paxos 缺点\r\n\r\n* :mag_right:   Paxos的活锁问题\r\n\r\n  上边我们介绍了Paxos的算法逻辑，但在算法运行过程中，可能还会存在一种极端情况，当有两个proposer依次提出一系列编号递增的议案，那么会陷入死循环，无法完成第二阶段，也就是无法选定一个提案。\r\n\r\n  ![image-20210426225548776](amWiki/images/lib_img/image-20210426225548776.png)\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">解决 ：</span> <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">通过选取主Proposer，就可以保证Paxos算法的活性。选择一个主Proposer，并规定只有主Proposer才能提出议案。这样一来，只要主Proposer和过半的Acceptor能够正常进行网络通信，那么肯定会有一个提案被批准（第二阶段的accept），则可以解决死循环导致的活锁问题。</span>\r\n\r\n\r\n\r\n#### ☛ Paxos 总结\r\n\r\n* Basic Paxos 也是通过二阶段提交协议达成共识。准备阶段、接受阶段。\r\n\r\n* Basic Paxos 不仅仅实现了共识，还实现了容错。有少于一半的节点出现故障时，集群也能正常工作。文中也多次强调了大多数节点都同意的原则，而这个原则赋予了 Basic Paxos 容错的能力。\r\n\r\n* 提案编号代表优先级，保证了三个承诺：\r\n  * 如果`准备请求`的提案编号，`小于等于`接受者已经响应的准备请求的提案编号，那么接受者将承诺不响应这个`准备请求`。\r\n  * 如果`接受请求`中的提案的提案编号，`小于`接受者已经响应的`准备请求`的提案，那么接受者将承诺不通过这个提案。\r\n  * 如果接受者之前有通过提案，那么接受者将承诺，会在`准备请求`的响应中，包含已经通过的最大编号的提案信息。\r\n\r\n\r\n\r\n\r\n\r\n### 5、ZAB协议（Fast paxos）\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述：</span> ZAB协议 即：`zookeeper atomic broadcast` 是一种支持崩溃恢复的原子广播协议，基于`fast paxos`实现，ZooKeeper使用单一主进程Leader用于处理客户端所有事务请求, 即写请求。当服务器数据发生变更 好，集群采用ZAB原子广播协议，以事务提交proposal的形式广播到所有的副本进程，每一个事务分配 一个全局的递增的事务编号xid。\r\n\r\n#### ☛ ZAB角色\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">zookeeper的三种角色 ：</span>\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">leader</span>\r\n  <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">leader 负责处理集群的写请求，并发起投票，只有超过半数的节点同意后才会提交该写请求</span>\r\n* <span style=\"color:#FC5531; font-weight:bold;\">follower</span>\r\n  <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">处理读请求，响应结果。转发写请求到 leader ，在选举 leader 过程中参与投票</span>\r\n* <span style=\"color:#FC5531; font-weight:bold;\">observer</span>\r\n  <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">observer可以理解为没有投票权的follower，主要职责是协助follower处理读请求。那么当整个zk</span>\r\n\r\n\r\n\r\n#### ☛ ZAB模式\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">zookeeper的两种模式 ：</span>\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">恢复模式</span>\r\n  当服务启动或领导崩溃后， zk 进入恢复状态，选举 leader ， leader 选出后，将完成 leader 和其他机\r\n  器的数据同步，当大多数 server 完成和 leader 的同步后，恢复模式结束\r\n* <span style=\"color:#FC5531; font-weight:bold;\">广播模式</span>\r\n  一旦 Leader 已经和多数的 Follower 进行了状态同步后，进入广播模式。进入广播模式后，如果有\r\n  新加入的服务器，会自动从 leader 中同步数据。 leader 在接收客户端请求后，会生成事务提案广播\r\n  给其他机器，有超过半数以上的 follower 同意该提议后，再提交事务。\r\n  注意在 ZAB 的事务的二阶段提交中，移除了事务中断的逻辑， follower 要么 ack ，要么放弃，\r\n  leader 无需等待所有的 follower 的 ack 。\r\n\r\n\r\n\r\n#### ☛ ZAB选举算法\r\n\r\n![image-20210426225652346](amWiki/images/lib_img/image-20210426225652346.png)\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">启动过程</span>\r\n  1. 每一个server发出一个投票给集群中其他节点</br>\r\n  2. 收到各个服务器的投票后，判断该投票有效性，比如是否是本轮投票，是否是 looking状态</br>\r\n  3. 处理投票，pk别人的投票和自己的投票 比较规则xid>myid “取大原则”</br>\r\n  4. 统计是否超过半数的接受相同的选票</br>\r\n  5. 确认leader，改变服务器状态</br>\r\n  6. 添加新server，leader已经选举出来，只能以follower身份加入集群中</br>\r\n* <span style=\"color:#FC5531; font-weight:bold;\">崩溃恢复过程</span>\r\n  1. leader挂掉后，集群中其他follower会将状态从FOLLOWING变为LOOKING,重新进入leader选举</br>\r\n  2. 同上启动过程\r\n\r\n\r\n\r\n#### ☛ ZAB消息广播算法\r\n\r\n:anger:   一旦进入广播模式，集群中非 leader 节点接受到事务请求，首先会将事务请求转发给服务器， leader服 务器为其生成对应的事务提案 proposal, 并发送给集群中其他节点，如果过半则事务提交；\r\n\r\n1. leader接受到消息后，消息通过全局唯一的64位自增事务id，zxid标识\r\n2. leader发送给follower的提案是有序的，leader会创建一个FIFO队列，将提案顺序写入队列中发送 给follower\r\n3. follower接受到提案后，会比较提案zxid和本地事务日志最大的zxid，若提案zxid比本地事务id 大，将提案记录到本地日志中，反馈ack给leader，否则拒绝\r\n4. leader接收到过半ack后，leader向所有的follower发送commit，通知每个follower执行本地事务\r\n\r\n\r\n\r\n### 6、Raft协议\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述：</span> `Raft 算法`是分布式系统开发首选的`共识算法`。\r\n\r\n**Raft 算法是通过一切以领导者为准的方式，实现一系列值的共识和各节点日志的一致。**\r\n\r\n#### ☛ Raft角色\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">跟随者（Follower）：</span>普通群众，默默接收和来自领导者的消息，当领导者心跳信息超时的时候，就主动站出来，推荐自己当候选人。\r\n* <span style=\"color:#FC5531; font-weight:bold;\">候选人（Candidate）：</span>候选人将向其他节点请求投票 RPC 消息，通知其他节点来投票，如果赢得了大多数投票选票，就晋升当领导者。\r\n* <span style=\"color:#FC5531; font-weight:bold;\">领导者（Leader）：</span>霸道总裁，一切以我为准。处理写请求、管理日志复制和不断地发送心跳信息，通知其他节点“我是领导者，我还活着，你们不要”发起新的选举，不用找新领导来替代我。\r\n\r\n\r\n\r\n:point_down:如下图所示，分别用三种图代表跟随者、候选人和领导者。 \r\n\r\n![image-20210426225711144](amWiki/images/lib_img/image-20210426225711144.png)\r\n\r\n\r\n\r\n\r\n\r\n#### ☛ Raft单节点系统\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">单节点服务（单机数据库）</span>\r\n\r\n  现在我们想象一下，有一个单节点系统，这个节点作为数据库服务器，且存储了一个值为 X。\r\n\r\n![image-20210426225729719](amWiki/images/lib_img/image-20210426225729719.png)\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">客户端</span>\r\n\r\n  左边绿色的实心圈就是客户端，右边的蓝色实心圈就是节点 a（Node a）。Term 代表任期，后面会讲到。\r\n\r\n![image-20210426225747501](amWiki/images/lib_img/image-20210426225747501.png)\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">客户端向服务器发送数据</span>\r\n\r\n  客户端向单节点服务器发送了一条更新操作，设置数据库中存的值为 8。单机环境下（单个服务器节点），客户端从服务器拿到的值也是 8。一致性非常容易保证。\r\n\r\n  ![image-20210426225747501](amWiki/images/lib_img/d546c1d895227830024d3340661ea14c.gif)\r\n\r\n  :mag_right:  <span style=\"color:#FC5531; font-weight:bold;\">多节点如何保证数据一致性</span>\r\n\r\n  但如果有多个服务器节点，怎么保证一致性呢？比如有三个节点：a，b，c。如下图所示。这三个节点组成一个数据库集群。客户端对这三个节点进行更新操作，如何保证三个节点中存的值一致？这个就是分布式一致性问题。Raft 算法就是来解决这个问题的。当然还有其他协议也可以保证，本篇只针对 Raft 算法。\r\n\r\n\r\n\r\n\r\n\r\n#### ☛ Raft选主过程\r\n\r\n* 初始状态\r\n\r\n  如下图所示，有三个节点(Node) a、b、c，任期（Term）都为 0。\r\n\r\n![image-20210426230034999](amWiki/images/lib_img/image-20210426230034999.png)\r\n\r\n* ### 成为候选者\r\n\r\n  Raft 算法实现了随机超时时间的特性，每个节点等待领导者节点心跳信息的超时时间间隔是随机的。比如 A 节点等待超时的时间间隔 150 ms，B 节点 200 ms，C 节点 300 ms。那么 a 先超时，最先因为没有等到领导者的心跳信息，发生超时。如下图所示，三个节点的超时计时器开始运行。\r\n\r\n![image-20210426230034999](amWiki/images/lib_img/7db9079db188f10aef792ba24282636e.gif)\r\n\r\n当 A 节点的超时时间到了后，A 节点成为候选者，并增加自己的任期编号，Term 值从 0 更新为 1，并给自己投了一票。\r\n\r\n- Node A：Term = 1, Vote Count = 1。\r\n\r\n- Node B：Term = 0。\r\n\r\n- Node C：Term = 0。0c1f0267ebb930016eaa746c6598bae1\r\n\r\n  ![image-20210426230034999](amWiki/images/lib_img/0c1f0267ebb930016eaa746c6598bae1.gif)\r\n\r\n* 投票\r\n\r\n  我们来看下候选者如何成为领导者的。\r\n\r\n![image-20210426230034999](amWiki/images/lib_img/e532a7cd454cb58460d16a980e9f9cd7.gif)\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">总述：</span>\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">第一步：</span>节点 A 成为候选者后，向其他节点发送请求投票 RPC 信息，请它们选举自己为领导者。\r\n* <span style=\"color:#FC5531; font-weight:bold;\">第二步：</span>节点 B 和 节点 C 接收到节点 A 发送的请求投票信息后，在编号为 1 的这届任期内，还没有进行过投票，就把选票投给节点 A，并增加自己的任期编号。\r\n* <span style=\"color:#FC5531; font-weight:bold;\">第三步：</span>节点 A 收到 3 次投票，得到了大多数节点的投票，从候选者成为本届任期内的新的领导者。\r\n* <span style=\"color:#FC5531; font-weight:bold;\">第四步：</span>节点 A 作为领导者，固定的时间间隔给 节点 B 和节点 C 发送心跳信息，告诉节点 B 和 C，我是领导者，组织其他跟随者发起新的选举。\r\n* <span style=\"color:#FC5531; font-weight:bold;\">第五步：</span>节点 B 和节点 C 发送响应信息给节点 A，告诉节点 A 我是正常的。\r\n\r\n\r\n\r\n#### ☛ Raft概念\r\n\r\n- <span style=\"color:#42B983;font-weight:bold;\">任期</span>\r\n  英文单词是 term，领导者是有任期的。\r\n  - <span style=\"color:#FC5531; font-weight:bold;\">自动增加：</span>跟随者在等待领导者心跳信息超时后，推荐自己为候选人，会增加自己的任期号，如上图所示，节点 A 任期为 0，推举自己为候选人时，任期编号增加为 1。\r\n  - <span style=\"color:#FC5531; font-weight:bold;\">更新为较大值：</span>当节点发现自己的任期编号比其他节点小时，会更新到较大的编号值。比如节点 A 的任期为 1，请求投票，投票消息中包含了节点 A 的任期编号，且编号为 1，节点 B 收到消息后，会将自己的任期编号更新为 1。\r\n  - <span style=\"color:#FC5531; font-weight:bold;\">恢复为跟随者：</span>如果一个候选人或者领导者，发现自己的任期编号比其他节点小，那么它会立即恢复成跟随者状态。这种场景出现在分区错误恢复后，任期为 3 的领导者受到任期编号为 4 的心跳消息，那么前者将立即恢复成跟随者状态。\r\n  - <span style=\"color:#FC5531; font-weight:bold;\">拒绝消息：</span>如果一个节点接收到较小的任期编号值的请求，那么它会直接拒绝这个请求，比如任期编号为 6 的节点 A，收到任期编号为 5 的节点 B 的请求投票 RPC 消息，那么节点 A 会拒绝这个消息。\r\n  \r\n- <span style=\"color:#42B983;font-weight:bold;\">选举规则</span>\r\n  - <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">一个任期内，领导者一直都会领导者，直到自身出现问题（如宕机），或者网络问题（延迟），其他节点发起一轮新的选举。</span>\r\n  - <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">在一次选举中，每一个服务器节点最多会对一个任期编号投出一张选票，投完了就没了。</span>\r\n  \r\n- <span style=\"color:#42B983;font-weight:bold;\">大多数</span>\r\n  假设一个集群由 N 个节点组成，那么大多数就是至少 N/2+1。例如： 3 个节点的集群，大多数就是 2。\r\n\r\n-  <span style=\"color:#42B983;font-weight:bold;\">心跳超时</span>\r\n  <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;\">为了防止多个节点同时发起投票，会给每个节点分配一个随机的选举超时时间。这个时间内，节点不能成为候选者，只能等到超时。比如上述例子，节点 A 先超时，先成为了候选者。这种巧妙的设计，在大多数情况下只有一个服务器节点先发起选举，而不是同时发起选举，减少了因选票瓜分导致选举失败的情况。</span>\r\n  \r\n  \r\n\r\n![image-20210426230034999](amWiki/images/lib_img/0c1f0267ebb930016eaa746c6598bae1.gif)\r\n\r\n#### ☛ Raft领导故障\r\n\r\n如果领导者节点出现故障，则会触发新的一轮选举。如下图所示，领导者节点 B 发生故障，节点 A 和 节点 B 就会重新选举 Leader。![image-20210426230034999](amWiki/images/lib_img/fee8d40e26f1eb765fc6f7bc770d5795.gif)\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">第一步 ：</span>节点 A 发生故障，节点 B 和节点 C 没有收到领导者节点 A 的心跳信息，等待超时。\r\n* <span style=\"color:#FC5531; font-weight:bold;\">第二步：</Span>节点 C 先发生超时，节点 C 成为候选人。\r\n* <span style=\"color:#FC5531; font-weight:bold;\">第三步：</span>节点 C 向节点 A 和 节点 B 发起请求投票信息。\r\n* <span style=\"color:#FC5531; font-weight:bold;\">第四步：</span>节点 C 响应投票，将票投给了 C，而节点 A 因为发生故障了，无法响应 C 的投票请求。\r\n* <span style=\"color:#FC5531; font-weight:bold;\">第五步：</span>节点 C 收到两票（大多数票数），成为领导者。\r\n* <span style=\"color:#FC5531; font-weight:bold;\">第六步：</span>节点 C 向节点 A 和 B 发送心跳信息，节点 B 响应心跳信息，节点 A 不响应心跳信息。\r\n\r\n#### ☛ Raft总结\r\n\r\nRaft 算法通过以下几种方式来进行领导选举，保证了一个任期只有一位领导，极大减少了选举失败的情况。\r\n\r\n- <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">任期</span>\r\n- <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">领导者心跳信息</span>\r\n- <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">随机选举超时时间</span>\r\n- <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">先来先服务的投票原则</span>\r\n- <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">大多数选票原则</span>\r\n\r\n## 附录\r\n\r\n### 参考\r\n\r\n👉 [JAVA 分布式 - 分布式介绍_肖朋伟-CSDN博客_分布式](https://blog.csdn.net/qq_40147863/article/details/84350344)\r\n\r\n👉 [分布式之CAP原则详解_csdn_life18的博客-CSDN博客](https://blog.csdn.net/csdn_life18/article/details/112597914)\r\n\r\n👉 [分布式系统中的一致性协议总结_chenglinhust的专栏-CSDN博客](https://blog.csdn.net/chdhust/article/details/52651741)\r\n\r\n👉 [太上老君的炼丹炉之分布式 Quorum NWR_悟空聊架构的专栏-CSDN博客](https://blog.csdn.net/jackson0714/article/details/114338016?spm=1001.2014.3001.5501)","timestamp":1642514536573},{"name":"01-zookeeper基础.md","path":"02-java篇/02-技术栈/04-分布式/02-zookeeper/01-zookeeper基础.md","content":"# zookeeper基础\r\n\r\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2021年4月27日09:32:01</span>\r\n\r\n## 一、zookeeper数据结构\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述：</span>ZooKeeper数据模型的结构与Unix文件系统很类似，整体上可以看作是一棵树，每个节点称做一个\r\nZNode，每个ZNode都可以通过其路径唯一标识。\r\n\r\n<span style=\"color:#FC5531; font-weight:bold;\">ZooKeeper = 文件系统 + 监听通知机制 + ACL</span>\r\n\r\n![image-20210502165741208](amWiki/images/lib_img/image-20210502165741208.png)\r\n\r\n### 1、Znode节点类型 \r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">持久化目录节点（PERSISTENT）</span>\r\n  客户端与zookeeper断开连接后，该节点依旧存在\r\n* <span style=\"color:#FC5531; font-weight:bold;\">持久化顺序编号目录节点（PERSISTENT_SEQUENTIAL）</span>\r\n  客户端与zookeeper断开连接后，该节点依旧存在，Zookeeper会给该节点按照顺序编号\r\n* <span style=\"color:#FC5531; font-weight:bold;\">临时目录节点（EPHEMERAL）</span>\r\n  客户端与zookeeper断开连接后，该节点被删除\r\n* <span style=\"color:#FC5531; font-weight:bold;\">临时顺序编号目录节点（EPHEMERAL_SEQUENTIAL）</span>\r\n  客户端与zookeeper断开连接后，该节点被删除，Zookeeper会给该节点按照顺序编号\r\n\r\n\r\n\r\n### 2、Znode节点结构\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">结构：</span>  znode包含了数据、子节点引用、访问权限等等。\r\n\r\n![image-20210502165804827](amWiki/images/lib_img/image-20210502165804827.png)\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">data：    </span>\r\n\r\n  Znode存储的数据信息。 \r\n\r\n  <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px\">每一个znode默认能够存储1MB的数据（对于记录状态性质的数据来说，够了）</span></br>\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">ACL：</span>    \r\n\r\n  记录Znode的访问权限，即哪些人或哪些IP可以访问本节点。\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">stat： </span>\r\n\r\n  包含Znode的各种元数据，比如事务ID、版本号、时间戳、大小等等。 \r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">child：</span>     \r\n\r\n  当前节点的子节点引用，类似于二叉树的左孩子右孩子。\r\n\r\n### 3、Znode状态信息\r\n\r\n* stat\r\n\r\n  <span style=\"color:#42B983;\">-cZxid </span> 就是 Create ZXID，表示节点被创建时的事务ID。</br>\r\n  <span style=\"color:#42B983;\">-ctime</span> 就是 Create Time，表示节点创建时间。</br>\r\n  <span style=\"color:#42B983;\">-mZxid</span> 就是 Modified ZXID，表示节点最后一次被修改时的事务ID。</br>\r\n  <span style=\"color:#42B983;\">-mtime</span> 就是 Modified Time，表示节点最后⼀次被修改的时间。</br>\r\n  <span style=\"color:#42B983;\">-pZxid</span> 表示该节点的子节点列表最后⼀次被修改时的事务 ID。只有子节点列表变更才会更新 pZxid，子节点内容变更不会更新。</br>\r\n  <span style=\"color:#42B983;\">-cversion</span> 表示子节点的版本号。</br>\r\n  <span style=\"color:#42B983;\">-dataVersion</span> 表示内容版本号。</br>\r\n  <span style=\"color:#42B983;\">-aclVersion</span> 标识acl版本</br>\r\n  <span style=\"color:#42B983;\">-ephemeralOwner</span> 表示创建该临时节点时的会话 sessionID，如果是持久性节点那么值为 0 </br>\r\n  <span style=\"color:#42B983;\">-dataLength </span>表示数据⻓长度声明。</br>\r\n\r\n\r\n\r\n## 二 、Watcher机制\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述：</span> <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">Znode发生变化（Znode本身的增加，删除，修改，以及子Znode的变化）可以通过Watch机制通知到客户端。</span>Watch事件具有one-time trigger（一次性触发）的特性，如果Watch监视的Znode有变化，那么就会通知设置该Watch的客户端。\r\n\r\n### 1、watcher特征\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">一次性触发器</span>\r\n\r\n  客户端在Znode设置了Watch时，如果Znode内容发生改变，那么客户端就会获得Watch事件。\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">异步发送客户端</span>\r\n\r\n  Watch事件是异步发送到Client。Zookeeper可以保证客户端发送过去的更新顺序是有序的。\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">更新节点数据</span>\r\n\r\n  Znode改变有很多种方式，例如：节点创建，节点删除，节点改变，子节点改变等等。Zookeeper维护了两个Watch列表，一个节点数据Watch列表，另一个是子节点Watch列表。\r\n\r\n### 2、watcher运行机制\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">Watcher   的组成：</span><span style=\"color:#FC5531; font-weight:bold;\"> zk客户端，zk服务器，watcherManager</span>\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">Watcher工作机制：</span> <span style=\"color:#FC5531; font-weight:bold;\">客户端注册 Watcher、服务器处理 Watcher 和客户端回调 Watcher</span>\r\n\r\n![image-20210502165827943](amWiki/images/lib_img/image-20210502165827943.png)\r\n\r\n![image-20210502165850092](amWiki/images/lib_img/image-20210502165850092.png)\r\n\r\n#### ☛ 客户端注册watcher\r\n\r\n![image-20210502165910531](amWiki/images/lib_img/image-20210502165910531.png)\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">在发送一个 Watch 监控事件的会话请求时，ZooKeeper 客户端主要做了两个工作：</span> </br>\r\n\r\n1. <span style=\"color:#FC5531; font-weight:bold;\"> 标记该会话是一个带有 Watch 事件的请求</span></br>\r\n2. <span style=\"color:#FC5531; font-weight:bold;\"> 将 Watch 事件存储到 </span>ZKWatchManager</br>\r\n\r\n#### ☛ 服务器处理watcher\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">Zookeeper 服务端处理 Watch 事件基本也做了两个工作：</span>\r\n\r\n1. <span style=\"color:#FC5531; font-weight:bold;\"> 解析收到的请求是否带有 Watch 注册事件</span></br>\r\n2. <span style=\"color:#FC5531; font-weight:bold;\"> 将对应的 Watch 事件存储到 WatchManager</span></br>\r\n\r\n当 ZooKeeper 服务器接收到一个客户端请求后，首先会对请求进行解析，判断该请求是否包含 Watch 事件.\r\n\r\nZooKeeper 底层是通过 FinalRequestProcessor 类中的 processRequest 函数实现的。当 getDataRequest.getWatch() 值为 True 时，表明该请求需要进行 Watch 监控注册。并通过 zks.getZKDatabase().getData 函数将 Watch 事件注册到服务端的 WatchManager 中\r\n\r\n#### ☛ 客户端回调watcher\r\n\r\n![image-20210502165929240](amWiki/images/lib_img/image-20210502165929240.png)\r\n\r\n\r\n\r\n## 三、zookeeper环境搭建\r\n\r\n> <span style=\"color:#42B983;font-weight:bold;\">zookeeper版本号 & 环境：</span> <span style=\"color:#FC5531; font-weight:bold;\">  3.7.0      jdk1.8         linux </span>   \r\n\r\n### 1、单机环境\r\n\r\n#### ☛ jdk安装\r\n\r\n> jdk安装不是介绍重点（网上有很多教程），这里我们用的jdk1.8\r\n\r\n#### ☛ zookeeper安装\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">下载并解压zookeeper安装包</span>\r\n\r\n~~~ shell\r\n$ tar -xzvf [zookeeper_install_package]\r\n~~~\r\n\r\n\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">进入安装目录创建data目录</span>\r\n\r\n~~~shell\r\n# 进入zk目录\r\n$ cd [zookeeper_home]\r\n\r\n# 创建data目录\r\n$ mkdir data\r\n~~~\r\n\r\n\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">修改zk配置文件，指定data目录</span>\r\n\r\n~~~shell\r\n# 进入zk配置目录\r\n$ cd %zk_home%/conf\r\n\r\n# 配置zoo.cfg\r\n$ mv zoo_sample.cfg zoo.cfg\r\n\r\n# 指定data目录  修改zoo.cfg中的data属性 如下：\r\ndataDir=%zk_home%/data\r\n~~~\r\n\r\n\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">启/停zk</span>\r\n\r\n~~~shell\r\n# 命令行 启动zk\r\n$ ./zkServer.sh start\t\r\n\r\n# 命令行 停止zk\r\n$ ./zkServer.sh stop\r\n\r\n~~~\r\n\r\n### 2、集群环境\r\n\r\n#### ☛ 准备工作\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">安装jdk</span>\r\n\r\n  安装jdk不是重点不做赘述（度娘or谷狗），这里我们用jdk1.8\r\n\r\n  \r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">上传zookeeper安装包</span>\r\n\r\n  上传zk_install_package到你喜欢的目录\r\n\r\n  \r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">装备三份zk</span>\r\n\r\n  * <span style=\"color:#FC5531; font-weight:bold;\">  复制三份zk，并分别命名如下：</span>\r\n\r\n  ~~~shell\r\n  [custom_path]/zookeeper_01\r\n  [custom_path]/zookeeper_01\r\n  [custom_path]/zookeeper_01\r\n  ~~~\r\n\r\n  * <span style=\"color:#FC5531; font-weight:bold;\">  分别为上边的zk，配置cfg文件，并指定data目录以及端口号如下：</span>\r\n\r\n  ~~~shell\r\n  # zk节点一\r\n  clientPort=2181\r\n  dataDir=[custom_path]/zookeeper_01/data\r\n  \r\n  # zk节点二\r\n  clientPort=2182\r\n  dataDir=[custom_path]/zookeeper_02/data\r\n  \r\n  # zk节点三\r\n  clientPort=2183\r\n  dataDir=[custom_path]/zookeeper_03/data\r\n  ~~~\r\n\r\n\r\n\r\n#### ☛  集群配置\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">创建myid文件</span>\r\n\r\n  ![image-20210502141009861](amWiki/images/lib_img/image-20210502141009861.png)\r\n\r\n  <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">在每个zookeeper的 data 目录下创建一个 myid 文件，内容分别是1、2、3 。</span></br>\r\n\r\n  <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">这个文件就是记录 每个服务器的ID</span></br>\r\n\r\n\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">配置集群服务其列表</span>\r\n\r\n![image-20210502140729022](amWiki/images/lib_img/image-20210502140729022.png)\r\n\r\n~~~ shell\r\n# server.服务器ID=服务器IP地址：服务器之间通信端口：服务器之间投票选举端口\r\nserver.1=ip:28881:3881\r\nserver.2=ip:28882:3882\r\nserver.3=ip:28883:3883\r\n# 注：这里的“服务器之间通信端口”切记不要和clientPort混淆 （配置一样）\r\n~~~\r\n\r\n\r\n\r\n#### ☛  集群启动\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">集群服务启动</span>\r\n\r\n  <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">依次启动三个zk实例，其中有一个leader和两个follower</span>\r\n\r\n\r\n\r\n## 四、zookeeper基本使用\r\n\r\n### 1、命令行\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">服务启/停、状态检查</span>\r\n\r\n~~~ shell\r\n# zk服务启动\r\n$ ./zkServer.sh start\r\n\r\n# zk服务停止\r\n$ ./zkServer.sh stop\r\n\r\n# zk状态检查\r\n$ ./zkServer.sh status\r\n~~~\r\n\r\n\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">连接zk服务</span>\r\n\r\n~~~ shell\r\n# 默认连接本地zk\r\n$ sh %zk_home%/bin/zkCli.sh\r\n\r\n# 连接指定ip端口的zk服务\r\n$ sh %zk_home%/bin/zkCli.sh -server ip:port\r\n~~~\r\n\r\n\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">查看节点信息</span>\r\n\r\n  ![image-20210502144727846](amWiki/images/lib_img/image-20210502144727846.png)\r\n\r\n~~~shell\r\n# 注：以下命令都是在连接到zk_server后执行的\r\n# 查看根节点信息\r\n$ ls / [watch]\r\n\r\n# 查看指定目录节点的信息\r\n$ ls /[zNode_name] [watch]\r\n\r\n# 查看节点信息（包含更新次数等信息）\r\n$ ls -s /[zNode_name] [watch]    \t\t\t#在老版本中这样使用：ls2 /[zNode_name]\r\n\r\n# 注：[watch] 监听机制（一次）：监听当前节点目录是否发生变化（添加、删除当前节点或子节点）\r\n~~~\r\n\r\n\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">创建节点</span>\r\n\r\n  ![image-20210502144800580](amWiki/images/lib_img/image-20210502144800580.png)\r\n\r\n~~~shell\r\n# 创建节点 注：要指定节点值\r\n$ create [-s] [-e] /ryanc-site site.ryanc\r\n# 注：-s：有序节点； -e：临时节点\r\n~~~\r\n\r\n\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">查看节点的值</span>\r\n\r\n~~~shell\r\n# 普通查看\r\n$ get /[zNode_name] [watch]\r\n# 注：[watch] 监听机制（一次）：监听当前节点的值是否发生变化\r\n~~~\r\n\r\n\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">更新节点的值</span>\r\n\r\n~~~shell\r\n# 普通更新\r\n$ set /[zNode_name] [nValue]\r\n~~~\r\n\r\n\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">查看节点状态</span>\r\n\r\n~~~shell\r\n$ stat /[zNode_name]\r\n~~~\r\n\r\n\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">删除节点</span>\r\n\r\n~~~shell\r\n# 普通删除 注：不能删除子节点不为空的节点\r\n$ delete /[zNode_name]\r\n\r\n# 递归删除\r\n$ rmr /[zNode_name]\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 2、api调用\r\n\r\n#### ☛ 添加maven依赖\r\n\r\n~~~xml\r\n<!-- https://mvnrepository.com/artifact/org.apache.zookeeper/zookeeper -->\r\n<dependency>\r\n    <groupId>org.apache.zookeeper</groupId>\r\n    <artifactId>zookeeper</artifactId>\r\n    <version>3.7.0</version>\r\n</dependency>\r\n\r\n<!-- https://mvnrepository.com/artifact/junit/junit -->\r\n<dependency>\r\n    <groupId>junit</groupId>\r\n    <artifactId>junit</artifactId>\r\n    <version>4.13</version>\r\n    <scope>test</scope>\r\n</dependency>\r\n~~~\r\n\r\n\r\n\r\n#### ☛  连接zk\r\n\r\n~~~ java\r\n// 创建zk对象，连接zk—server\r\n// 参数列表：\r\n// \t\tconnectString => zk_ip:zk_client_port\r\n//\t\tsessionTimeout => 超时时间\r\n// \t\twatcher \t  => watcher机制\r\n\r\nZooKeeper zk = new ZooKeeper(\"192.168.8.124:2181\",2000,new Watcher() {\r\n    @Override\r\n    public void process(WatchedEvent event) {\r\n        System.out.println(\"触发了 \"+ event.getType() + \"类型的事件。。。\");\r\n    }\r\n});\r\n~~~\r\n\r\n\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">创建节点</span>\r\n\r\n~~~java\r\n// zk对象创建节点\r\n// 参数列表：\r\n// \t\tpath  => 节点名称（目录）\r\n//\t\tdata  => 节点值\r\n//\t\tacl   => 节点访问权限\r\n//  \tcMode => 节点类型：临时节点、持久节点、顺序节点。。。\r\n\r\n// 创建父节点\r\nString zn_path= zk.create(\"/test_l\", \"api创建\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\r\n\r\n// 创建子节点\r\nString child_zn_path = zk.create(\"/test_l/child\", \"api创建,子节点\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT))\r\n~~~\r\n\r\n\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">获取节点值</span>\r\n\r\n~~~java\r\n// 获取节点的值\r\n// 参数列表：\r\n//\t\tpath\t=> 节点目录\r\n//\t\twatch\t=> 是否监听\r\n// \t\tstat\t=> 指定数据版本等等\r\nbyte[] b_data = zk.getData(\"/test_l/child\", false, null);\r\nString data = new String(b_data);\r\n~~~\r\n\r\n\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">更新节点值</span>\r\n\r\n~~~ java\r\n// 更新节点值\r\n// 参数列表：\r\n//\t\tpath\t=> 待更新节点目录\r\n//\t\tdata\t=> 待更新的内容\r\n//\t\tversion\t=> 指定要匹配的版本 -1：表是匹配任何版本\r\nStat stat = zk.setData(\"/test_lll\", \"update datas\".getBytes(), -1);\r\nString data = new String(zk.getData(\"/test_lll\", false, null));\r\nSystem.out.println(data);\r\n~~~\r\n\r\n\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">判断节点是否存在</span>\r\n\r\n~~~java\r\n// 参数列表：\r\n//\t\tpath\t=> 带判断的节点目录\r\n//\t\twatch\t=> 是否监听\r\nStat stat_exists = zk.exists(\"/test_llls\", false);\r\nSystem.out.println(stat_exists);\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">删除节点</span>\r\n\r\n~~~java\r\n// 参数列表：\r\n//\t\tpath\t=> 待删除节点目录\r\n//\t\tversion\t=> 指定要匹配的版本 -1：表是匹配任何版本\r\nzk.delete(\"/test_lll/child\", -1);\r\nSystem.out.println(zk.exists(\"/test_lll/child\", false)); // 查看是否删除成功\r\n~~~\r\n\r\n\r\n\r\n## 附录\r\n\r\n### 参考\r\n\r\n👉  [zookeeper_微毂的博客-CSDN博客](https://blog.csdn.net/weixin_42749734/category_10783522.html)\r\n\r\n👉  [Zookeeper数据结构_HelloWorld搬运工-CSDN博客_zookeeper数据结构](https://blog.csdn.net/wufaliang003/article/details/76043892)","timestamp":1642514536573},{"name":"02-zookeeper进阶.md","path":"02-java篇/02-技术栈/04-分布式/02-zookeeper/02-zookeeper进阶.md","content":"# zookeeper进阶\r\n\r\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2021年05月02日17:09:24</span>\r\n\r\n## 一、源码解析\r\n\r\n### 1、源码下载\r\n\r\n\r\n\r\n### 2、启动流程\r\n\r\n\r\n\r\n### 3、选主流程\r\n\r\n\r\n\r\n### 4、watcher机制\r\n\r\n\r\n\r\n## 二、zk应用场景\r\n\r\n### 1、配置中心\r\n\r\n#### ☛ 场景 & 需求\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述：</span>集群上有很多个节点运行同一个任务，这个任务会有一些可能经常改变的配置参数</br>\r\n要求是当配置参数改变之后能够很快地同步到每个节点上</br>\r\n如果将这些配置参数放在本地文件中则每次都要修改本地文件费时费力还可能会有遗漏</br>\r\n所以这个时候一个比较自然的想法就是将配置单独提取出来作为一个服务</br>\r\n\r\n\r\n\r\n#### ☛  选型分析\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">配置中心的核心</span>\r\n\r\n  * <span style=\"color:#FC5531; font-weight:bold;\"> 低延时：</span> <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">配置改变后能够尽快的将最新配置同步给每一个节点。</span>\r\n  * <span style=\"color:#FC5531; font-weight:bold;\"> 高可用：</span> <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">配置中心需要能够稳定不间断的提供服务。</span>\r\n\r\n* <span style=\"color:#42B983;font-weight:bold;\">配置中心实现</span>\r\n\r\n  <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;\">发布/订阅系统一般有两种设计模式，分别是推(Push)模式和拉(Pull)模式。</span>\r\n\r\n  * <span style=\"color:#FC5531; font-weight:bold;\"> 推模式：</span><span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">服务端主动将数据更新发送给所有订阅的客户端。</span>\r\n  * <span style=\"color:#FC5531; font-weight:bold;\"> 拉模式：</span><span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">客户端通过采用定时轮询拉取。</span>\r\n\r\n\r\n\r\n#### ☛ 实现分析\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">分析：</span> ZooKeeper采用的是推拉相结合的方式：</br>\r\n\r\n客户端向服务端注册自己需要关注的节点，一旦该节点的数据发生变更，那么服务端就会向相应的客户端发送Watcher事件通知，客户端接收到这个消息通知之后，需要主动到服务端获取最新的数据。 </br>\r\n\r\n如果将配置信息存放到ZK上进行集中管理，那么通常情况下，应用在启动的时候会主动到ZK服务器上进行一次配置信息的获取，同时，在指定上注册一个Watcher监听，这样一来，但凡配置信息发生变更，服务器都会实时通知所有订阅的客户端，从而达到实时获取最新配置信息的目的。</br>\r\n\r\n![image-20210502195628408](amWiki/images/lib_img/image-20210502195628408.png)\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\"> 配置信息特性</span>\r\n\r\n  * 数据量通常比较小\r\n  * 数据内容在运行时会发生变化\r\n  * 集群中各机器共享、配置一致\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\"> 配置存储</span>\r\n\r\n  在进行配置管理之前，首先我们需要将初始化配置存储到ZK上去，一般情况下，我们可以在ZK上选取一个数据节点用于配置的存储，我们将需要集中管理的配置信息写入到该数据节点中去。\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\"> 配置获取</span>\r\n\r\n  集群中每台机器在启动初始化阶段，首先会从上面提到的ZK的配置节点上读取数据库信息，同时，客户端还需要在该配置节点上注册一个数据变更的Watcher监听，一旦发生节点数据变更，所有订阅的客户端都能够获取数据变更通知。\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\"> 配置变更</span>\r\n\r\n  在系统运行过程中，可能会出现需要进行数据切换的情况，这个时候就需要进行配置变更。借助ZK，我们只需要对ZK上配置节点的内容进行更新，ZK就能够帮我们将数据变更的通知发送到各个客户端，每个客户端在接收到这个变更通知后，就可以重新进行最新数据的获取。\r\n\r\n#### ☛代码实现\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述：</span> <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;\">代码包括如下三个部分:配置客户端类ConfigClient、应用服务类Service、本地配置类MyConfig,关系如下：</span></br>\r\n\r\n<span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">ConfigClient通过与zookeeper服务器交互，修改MyConfig；</span></br>\r\n\r\n<span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">Service在业务逻辑中直接使用MyConfig；</span> </br>\r\n\r\n<span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">Service启动时，完成ConfigClient的启动、初始化。</span> </br>\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">客户端类ConfigClient</span>\r\n\r\n~~~ java\r\nimport org.apache.zookeeper.*;\r\nimport org.apache.zookeeper.data.Stat;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n \r\nimport java.io.IOException;\r\nimport java.lang.reflect.Field;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n \r\n/**\r\n * +--------------------------------+ <br>\r\n * | Even in a galaxy far,far away.  | <br>\r\n * | 即使是在遥远的星河里也一样  !      |<br>\r\n * +--------------------------------+ <br>\r\n * @author ryan\r\n * @date May 2, 2021\r\n * @desc \r\n * \t\t实际生产中，配置中心的客户端以java注解的形式使用\r\n * \t\t通过maven引入依赖，随着服务的启动，spring容器自动加载\r\n *\r\n */\r\npublic class ConfigClient {\r\n \r\n    private static final Logger log = LoggerFactory.getLogger(ConfigClient.class);\r\n \r\n    private ZooKeeper zkClient;\r\n \r\n    private String servicePath;\r\n \r\n    private Map<String, String> localConfigs;\r\n \r\n    /**\r\n     * 服务启动时调用，将服务节点记录到/config-center节点下\r\n     */\r\n    public void init(String appkey) throws IOException {\r\n        zkClient = new ZooKeeper(\"192.168.8.124:2181\", 15000,\r\n                event -> log.info(\"event:{}\", event));\r\n        this.servicePath = \"/config-center/\" + appkey;\r\n        createNode(servicePath, new byte[0]);\r\n        localConfigs = new HashMap<>(10);\r\n    }\r\n \r\n    /**\r\n     * 注意，调用create时，data还被当做上下文参数ctx的值；在异步回调时，如果发生connectionLoss，ctx可以作为data再次调用create方法\r\n     */\r\n    private void createNode(String path, byte[] data) {\r\n        zkClient.create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new AsyncCallback.StringCallback() {\r\n            @Override\r\n            public void processResult(int rc, String path, Object ctx, String name) {\r\n                switch (KeeperException.Code.get(rc)) {\r\n                    case CONNECTIONLOSS:\r\n                        createNode(path, (byte[]) ctx);\r\n                        break;\r\n                    case OK:\r\n                        log.info(\"{} create successfully!\", path);\r\n                        break;\r\n                    case NODEEXISTS:\r\n                        log.info(\"{} exists!\", path);\r\n                        break;\r\n                    default:\r\n                        log.error(\"Something went wrong: \", KeeperException.create(KeeperException.Code.get(rc), path));\r\n                }\r\n            }\r\n        }, data);\r\n    }\r\n \r\n    /**\r\n     * 服务启动时调用，将本地的每个配置项作为节点，记录到服务节点下\r\n     */\r\n    public void registerConfig(String fieldName, Object configValue) {\r\n        byte[] data = configValue == null ? new byte[0] : configValue.toString().getBytes();\r\n        String configPath = this.servicePath + \"/\" + fieldName;\r\n        createNode(configPath, data);\r\n        localConfigs.put(configPath, fieldName);\r\n        reloadConfig(configPath);\r\n    }\r\n \r\n    /**\r\n     * DataCallback：异步方式查询数据，如果连接丢失，重新执行reloadConfig\r\n     * Watcher：监听节点数据变更，即监听配置的值发生变更\r\n     */\r\n    public void reloadConfig(String configPath) {\r\n        zkClient.getData(configPath, new Watcher() {\r\n            @Override\r\n            public void process(WatchedEvent event) {\r\n                switch (event.getType()) {\r\n                    case NodeDataChanged:\r\n                        log.info(\"数据修改事件发生:{}\", event.getPath());\r\n                        reloadConfig(event.getPath());\r\n                }\r\n            }\r\n        }, new AsyncCallback.DataCallback() {\r\n            @Override\r\n            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\r\n                switch (KeeperException.Code.get(rc)) {\r\n                    case CONNECTIONLOSS:\r\n                        reloadConfig(path);\r\n                    case OK:\r\n                        String fieldName = localConfigs.get(path);\r\n                        String strValue = new String(data);\r\n                        reloadValue(fieldName, strValue);\r\n                }\r\n \r\n            }\r\n        }, new Stat());\r\n    }\r\n \r\n    /**\r\n     * 通过反射的方式，将配置的变更set到应用服务的MyConfig类的对应field中\r\n     * 实际生产中，依托配置中心的客户端field级注解：不必将所有配置统一写到特定的类中；配置项名称不必与字段名称fieldName相同\r\n     */\r\n    private void reloadValue(String fieldName, String strValue) {\r\n        try {\r\n            Field field = MyConfig.class.getDeclaredField(fieldName);\r\n            field.setAccessible(true);\r\n            if (field.getType() == String.class) {\r\n                field.set(MyConfig.getInstance(), strValue);\r\n            } else if (field.getType() == Integer.class) {\r\n                field.set(MyConfig.getInstance(), Integer.valueOf(strValue));\r\n            }\r\n        } catch (IllegalAccessException e) {\r\n            log.error(\"reload zk config to local config fail:\", e);\r\n        } catch (NoSuchFieldException e) {\r\n            log.error(\"reload zk config to local config fail:\", e);\r\n        }\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">应用服务类Service</span>\r\n\r\n~~~java\r\nimport org.apache.log4j.BasicConfigurator;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n \r\nimport java.io.IOException;\r\nimport java.util.Scanner;\r\n \r\n/**\r\n * +--------------------------------+ <br>\r\n * | Even in a galaxy far,far away.  | <br>\r\n * | 即使是在遥远的星河里也一样  !      |<br>\r\n * +--------------------------------+ <br>\r\n * @author ryan\r\n * @date May 2, 2021\r\n * @desc 服务类\r\n *\r\n */\r\npublic class Service {\r\n \r\n    private static final Logger log = LoggerFactory.getLogger(ConfigClient.class);\r\n \r\n    /**\r\n     * 服务唯一标识\r\n     */\r\n    private String appkey = \"service-1\";\r\n    private ConfigClient configClient;\r\n    /**\r\n     * 应用服务初始化\r\n     * 在实际生产中，通过spring完成configClient的初始化、依赖注入\r\n     */\r\n    public void init() throws IOException {\r\n        configClient = new ConfigClient();\r\n        configClient.init(appkey);\r\n        configClient.registerConfig(\"whiteList\", MyConfig.getInstance().whiteList);\r\n        configClient.registerConfig(\"limit\", MyConfig.getInstance().limit);\r\n    }\r\n    public static void main(String[] args) {\r\n    \tBasicConfigurator.configure();\r\n        Service service = new Service();\r\n        try {\r\n            service.init();\r\n            Thread.sleep(2000);\r\n        } catch (Exception e) {\r\n        \tlog.error(\"start fail....\");\r\n            System.exit(-1);\r\n        }\r\n        Scanner sc = new Scanner(System.in);\r\n        while (true) {\r\n            log.info(\"回车查看当前配置：\");\r\n            sc.nextLine();\r\n            log.info(\"service config whiteList: {}, limit:{}\", MyConfig.getInstance().getWhiteList(),\r\n                    MyConfig.getInstance().limit);\r\n        }\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\">本地配置类MyConfig</span>\r\n\r\n~~~java\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n \r\n/**\r\n * +--------------------------------+ <br>\r\n * | Even in a galaxy far,far away.  | <br>\r\n * | 即使是在遥远的星河里也一样  !      |<br>\r\n * +--------------------------------+ <br>\r\n * @author ryan\r\n * @date May 2, 2021\r\n * @desc \r\n * \t\t实际生产中：\r\n * \t\t\t① myConfig可以作为单例bean托管在spring容器中\r\n * \t\t\t② 利用java field级注解，不必将每一项配置统一写到特定类中，\r\n *\r\n */\r\npublic class MyConfig {\r\n \r\n    private volatile static MyConfig instance;\r\n \r\n    private MyConfig() {\r\n    }\r\n \r\n    /**\r\n     * 单例模式：延迟加载与双重检查锁定\r\n     */\r\n    public static MyConfig getInstance() {\r\n        if (instance == null) {\r\n            synchronized (MyConfig.class) {\r\n                if (instance == null) {\r\n                    instance = new MyConfig();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n \r\n    /**\r\n     * 配置1：白名单列表\r\n     */\r\n    public String whiteList = \"lileim,hanmeimei\";\r\n \r\n    public List<String> getWhiteList() {\r\n        try {\r\n            return new ArrayList(Arrays.asList(whiteList.split(\",\")));\r\n        } catch (Exception e) {\r\n            return new ArrayList<>();\r\n        }\r\n    }\r\n \r\n    /**\r\n     * 配置2：限制\r\n     */\r\n    public Integer limit = 10;\r\n \r\n}\r\n~~~\r\n\r\n\r\n\r\n###  2、负载均衡\r\n\r\n\r\n\r\n### 3、命名服务\r\n\r\n\r\n\r\n### 4、DNS服务\r\n\r\n\r\n\r\n### 5、集群管理\r\n\r\n\r\n\r\n### 6、分布式锁\r\n\r\n#### ☛  场景 & 需求\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述：</span> 在分布式微服务场景中，同一个微服务的多个节点同时对资源进行操作时就会有分布式同步问题（类似于多线程操作资源场景）\r\n\r\n#### ☛  选型分析\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">分布式锁的核心</span>\r\n\r\n* <span style=\"color:#FC5531; font-weight:bold;\"> 独占：</span> <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">任何时候只能有个微服务获取到该锁</span>\r\n* <span style=\"color:#FC5531; font-weight:bold;\"> 时序性：</span> <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">所有参与获取锁的微服务都会被安排执行</span>\r\n\r\n#### ☛ 实现分析\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">实现思路：</span> 为每一个执行的客户端都创建一个有序临时节点；每个客户端都判断自己的临时节点序号是不是最小的：\r\n\r\n* 序号最小：则获取锁执行相关操作，释放锁（删除节点）\r\n* 序号非最小：则监听前一个节点，当前一个节点删除时，获取锁，一次类推\r\n\r\n![image-20210502194804999](amWiki/images/lib_img/image-20210502194804999.png)\r\n\r\n#### ☛ 代码实现\r\n\r\n<span style=\"color:#42B983;font-weight:bold;\">简述：</span> <span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;\">代码包括如下三个部分:分布式锁工具类ZkLock、库存数据模型stock、分布式锁测试StockMain,关系如下：</span></br>\r\n\r\n<span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">ZkLock通过实现Lock对外提供lock API</span></br>\r\n\r\n<span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">stock 库存数据模型，角色共享资源</span> </br>\r\n\r\n<span style=\" font-weight:bold;border-bottom:1px dashed #000; height:50px;width:350px;color:#0081EF\">StockMain 用多线程模拟分布式场景，测试分布式锁</span> </br>\r\n\r\n* ZkLock\r\n\r\n~~~java\r\nimport org.apache.zookeeper.*;\r\nimport org.apache.zookeeper.data.Stat;\r\nimport java.util.List;\r\nimport java.util.TreeSet;\r\nimport java.util.concurrent.CountDownLatch;\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.concurrent.locks.Condition;\r\nimport java.util.concurrent.locks.Lock;\r\n\r\n\r\n/**\r\n * +--------------------------------+ <br>\r\n * | Even in a galaxy far,far away.  | <br>\r\n * | 即使是在遥远的星河里也一样  !      |<br>\r\n * +--------------------------------+ <br>\r\n * @author ryan\r\n * @date May 2, 2021\r\n * @desc 基于zk 实现的分布式锁\r\n *\r\n */\r\npublic class ZkLock implements Lock {\r\n\r\n\r\n    //zk客户端\r\n    private ZooKeeper zk;\r\n    //zk是一个目录结构，locks\r\n    private String root = \"/locks\";\r\n    //锁的名称\r\n    private String lockName;\r\n    //当前线程创建的序列node\r\n    private ThreadLocal<String> nodeId = new ThreadLocal<>();\r\n    //用来同步等待zkclient链接到了服务端\r\n    private CountDownLatch connectedSignal = new CountDownLatch(1);\r\n    private final static int sessionTimeout = 3000;\r\n    private final static byte[] data= new byte[0];\r\n\r\n\r\n    public ZkLock(String config, String lockName) {\r\n        this.lockName = lockName;\r\n\r\n        try {\r\n            zk = new ZooKeeper(config, sessionTimeout, new Watcher() {\r\n\r\n                @Override\r\n                public void process(WatchedEvent event) {\r\n                    // 建立连接\r\n                    if (event.getState() == Event.KeeperState.SyncConnected) {\r\n                        connectedSignal.countDown();\r\n                    }\r\n                }\r\n\r\n            });\r\n\r\n            connectedSignal.await();\r\n            Stat stat = zk.exists(root, false);\r\n            if (null == stat) {\r\n                // 创建根节点\r\n                zk.create(root, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\r\n            }\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    class LockWatcher implements Watcher {\r\n        private CountDownLatch latch = null;\r\n\r\n        public LockWatcher(CountDownLatch latch) {\r\n            this.latch = latch;\r\n        }\r\n\r\n        @Override\r\n        public void process(WatchedEvent event) {\r\n\r\n            if (event.getType() == Event.EventType.NodeDeleted)\r\n                latch.countDown();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void lock() {\r\n        try {\r\n            // 创建临时子节点\r\n            String myNode = zk.create(root + \"/\" + lockName , data, ZooDefs.Ids.OPEN_ACL_UNSAFE,\r\n                    CreateMode.EPHEMERAL_SEQUENTIAL);\r\n\r\n            System.out.println(Thread.currentThread().getName()+myNode+ \"created\");\r\n\r\n            // 取出所有子节点\r\n            List<String> subNodes = zk.getChildren(root, false);\r\n            TreeSet<String> sortedNodes = new TreeSet<>();\r\n            for(String node :subNodes) {\r\n                sortedNodes.add(root +\"/\" +node);\r\n            }\r\n\r\n            String smallNode = sortedNodes.first();\r\n\r\n\r\n            if (myNode.equals( smallNode)) {\r\n                // 如果是最小的节点,则表示取得锁\r\n                System.out.println(Thread.currentThread().getName()+ myNode+\"get lock\");\r\n                this.nodeId.set(myNode);\r\n                return;\r\n            }\r\n\r\n            String preNode = sortedNodes.lower(myNode);\r\n\r\n            CountDownLatch latch = new CountDownLatch(1);\r\n            Stat stat = zk.exists(preNode, new LockWatcher(latch));// 同时注册监听。\r\n            // 判断比自己小一个数的节点是否存在,如果不存在则无需等待锁,同时注册监听\r\n            if (stat != null) {\r\n                System.out.println(Thread.currentThread().getName()+myNode+\r\n                        \" waiting for \" + root + \"/\" + preNode + \" released lock\");\r\n\r\n                latch.await();// 等待，这里应该一直等待其他线程释放锁\r\n                nodeId.set(myNode);\r\n                latch = null;\r\n            }\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n\r\n    }\r\n\r\n\r\n    @Override\r\n    public void unlock() {\r\n        try {\r\n            System.out.println(Thread.currentThread().getName()+ \"unlock \");\r\n            if (null != nodeId) {\r\n                zk.delete(nodeId.get(), -1);\r\n            }\r\n            nodeId.remove();\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        } catch (KeeperException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n    public void lockInterruptibly() throws InterruptedException {\r\n\r\n    }\r\n\r\n    @Override\r\n    public boolean tryLock() {\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {\r\n        return false;\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n    public Condition newCondition() {\r\n        return null;\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n* Stock\r\n\r\n~~~java\r\n/**\r\n * +--------------------------------+ <br>\r\n * | Even in a galaxy far,far away.  | <br>\r\n * | 即使是在遥远的星河里也一样  !      |<br>\r\n * +--------------------------------+ <br>\r\n * @author ryan\r\n * @date May 2, 2021\r\n * @desc 分布式锁 演示 数据模型\r\n *\r\n */\r\npublic class Stock {\r\n\r\n    //库存为1\r\n    private static int num = 1;\r\n\r\n    public static boolean reduseStock(){\r\n\r\n        if(num>0){\r\n            try {\r\n                Thread.sleep(1000);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            num--;\r\n            return true;\r\n        }\r\n         return false;\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n* StockMain\r\n\r\n~~~java\r\n\r\n/**\r\n * +--------------------------------+ <br>\r\n * | Even in a galaxy far,far away.  | <br>\r\n * | 即使是在遥远的星河里也一样  !      |<br>\r\n * +--------------------------------+ <br>\r\n * @author ryan\r\n * @date May 2, 2021\r\n * @desc 分布式锁测试类\r\n *\r\n */\r\npublic class StockMain {\r\n\r\n    private static ZkLock zkLock;\r\n\r\n    static{\r\n        zkLock = new ZkLock(\"127.0.0.1:2181\",\"stock_zk\");\r\n    }\r\n\r\n\r\n    static class StockThread implements Runnable{\r\n\r\n        @Override\r\n        public void run() {\r\n\r\n        \t// 上锁\r\n            zkLock.lock();\r\n\r\n            // 扣减库存\r\n            boolean b = new Stock().reduseStock();\r\n\r\n            // 解锁\r\n            zkLock.unlock();\r\n\r\n            if(b){\r\n                System.out.println(Thread.currentThread().getName()+\":扣减库存成功！\");\r\n            }else{\r\n                System.out.println(Thread.currentThread().getName()+\":扣减库存失败！\");\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        new Thread(new StockThread(),\"用户1\").start();\r\n        new Thread(new StockThread(),\"用户2\").start();\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n\r\n\r\n### 7、分布式队列\r\n\r\n\r\n\r\n## 附录\r\n\r\n### 参考\r\n\r\n👉 [zookeeper-配置中心](https://blog.csdn.net/ye201622021113/article/details/112760952)\r\n\r\n","timestamp":1642514536573},{"name":"01-sikulix快速上手.md","path":"02-java篇/03-第三方/03-上帝之眼sikulix/01-sikulix快速上手.md","content":"# sikulix快速上手\r\n\r\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2020年12月19日15:47:31</span>\r\n\r\n## 一、第三方依赖\r\n\r\n* maven依赖坐标\r\n\r\n  ~~~xml\r\n  <!-- sikulix maven坐标 版本按需选择 -->\r\n  <dependency>\r\n     <groupId>com.sikulix</groupId>\r\n     <artifactId>sikulixapi</artifactId>\r\n     <version>1.1.2</version>\r\n  </dependency>\r\n  ~~~\r\n\r\n  \r\n\r\n## 二、快速上手\r\n\r\n### 1、开启浏览器\r\n\r\n~~~java\r\n// 浏览器图标自行截图 存放至制定目录\r\ntry {\r\n   Pattern pattern = new Pattern(\"浏览器图标图片路径\");\r\n   Screen screen = new Screen();\r\n   screen.click(pattern);\r\n} catch (Exception e) {\r\n\te.printStackTrace();\r\n}\r\n~~~\r\n\r\n\r\n\r\n### 2、访问百度\r\n\r\n~~~java\r\nPattern pattern = new Pattern(\"浏览器地址栏图片路径\");\r\nScreen screen = new Screen();\r\nscreen.click(pattern);\r\nscreen.paste(\"浏览器地址栏图片路径\",\"www.baidu.com\");\r\n~~~\r\n\r\n\r\n\r\n## 三、进阶使用\r\n\r\n>sikulix参考文档：http://doc.sikuli.org/region.html#Region.text\r\n\r\n### 1、文本框输入中文\r\n\r\n~~~java\r\nPattern pattern = new Pattern(\"输入框图片路径\");\r\nScreen screen = new Screen();\r\nscreen.click(pattern);\r\nscreen.paste(\"输入框图片路径\",要输入的文本); // 方法一\r\nscreen.type(\"输入框图片路径\"，要输入的文本)； // 方法二\r\n~~~\r\n\r\n<span style=\"color:red;\">注：使用screen类输入文本的两种方法，type存在文本长度的问题，而paste方法没有此类问题</span>","timestamp":1642514536573},{"name":"01-selenium初探.md","path":"02-java篇/03-第三方/04-selenium/01-selenium初探.md","content":"# selenium初探\r\n\r\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2020年12月19日18:47:54</span>\r\n\r\n## 一、第三方依赖\r\n\r\n### 1、maven依赖坐标\r\n\r\n~~~xml\r\n<!-- selenium 的java api ：版本按需选择 -->\r\n<dependency>\r\n    <groupId>org.seleniumhq.selenium</groupId>\r\n    <artifactId>selenium-java</artifactId>\r\n    <version>3.4.0</version>\r\n</dependency>\r\n~~~\r\n\r\n\r\n\r\n### 2、浏览器驱动\r\n\r\n> 当selenium升级到3.0之后，对不同的浏览器驱动进行了规范。如果想使用selenium驱动不同的浏览器，必须单独下载并设置不同的浏览器驱动。\r\n\r\n* 各浏览器驱动\r\n\r\n  Firefox浏览器驱动：[geckodriver](https://github.com/mozilla/geckodriver/releases) </br>\r\n  Chrome浏览器驱动：[chromedriver](https://sites.google.com/a/chromium.org/chromedriver/home)[taobao备用地址 </br>](https://npm.taobao.org/mirrors/chromedriver)\r\n  IE浏览器驱动：[IEDriverServer](http://selenium-release.storage.googleapis.com/index.html) </br>\r\n  Edge浏览器驱动：[MicrosoftWebDriver](https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/) </br>\r\n  Opera浏览器驱动：[operadriver](https://github.com/operasoftware/operachromiumdriver/releases) </br>\r\n  PhantomJS浏览器驱动：[phantomjs](http://phantomjs.org/) </br>\r\n\r\n  <span style=\"color:red;\">注：部分浏览器驱动地址需要科学上网。</span>\r\n\r\n\r\n\r\n## 二、快速上手\r\n\r\n### 1、开启浏览器\r\n\r\n> 这里我们以谷歌浏览器为例（访问百度）\r\n\r\n~~~java\r\n// 设置浏览器驱动程序位置\r\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \r\n\r\n// 开启一个谷歌浏览器\r\nWebDriver webDriver = new ChromeDriver();\r\n\r\n// 窗口最大化\r\nwebDriver.manage().window().maximize();\r\n\r\n// 访问百度\r\nwebDriver.get(\"https://www.baidu.com\")\r\n~~~\r\n\r\n","timestamp":1642514536573},{"name":"02-selenium进阶.md","path":"02-java篇/03-第三方/04-selenium/02-selenium进阶.md","content":"# selenium进阶\r\n\r\n> 时间：<span style=\"color:#42B983;font-weight:bold;\">2020年12月19日 19:48:17</span>\r\n\r\n## 一、元素定位\r\n\r\n### 1、定位方法\r\n\r\n<span style=\"color:#FF531A;font-weight:bold;\">id:</span><span style=\"color:#42B983;font-weight:bold;\">    findElement(By.id())</span></br>\r\n<span style=\"color:#FF531A;font-weight:bold;\">name:</span><span style=\"color:#42B983;font-weight:bold;\">    findElement(By.name())</span></br>\r\n<span style=\"color:#FF531A;font-weight:bold;\">class name:</span> <span style=\"color:#42B983;font-weight:bold;\">   findElement(By.className())</span></br>\r\n<span style=\"color:#FF531A;font-weight:bold;\">tag name: </span> <span style=\"color:#42B983;font-weight:bold;\">  findElement(By.tagName())</span></br>\r\n<span style=\"color:#FF531A;font-weight:bold;\">link text:</span><span style=\"color:#42B983;font-weight:bold;\">    findElement(By.linkText())</span></br>\r\n<span style=\"color:#FF531A;font-weight:bold;\">partial link text:</span><span style=\"color:#42B983;font-weight:bold;\">    findElement(By.partialLinkText())</span></br>\r\n<span style=\"color:#FF531A;font-weight:bold;\">xpath:</span><span style=\"color:#42B983;font-weight:bold;\">    findElement(By.xpath())</span></br>\r\n<span style=\"color:#FF531A;font-weight:bold;\">css selector:</span> <span style=\"color:#42B983;font-weight:bold;\">   findElement(By.cssSelector())</span></br>\r\n\r\n### 2、定位方法用法\r\n\r\n~~~html\r\n<html>\r\n  <head>\r\n  <body link=\"#0000cc\">\r\n    <a id=\"result_logo\" href=\"/\" onmousedown=\"return c({\'fm\':\'tab\',\'tab\':\'logo\'})\">\r\n    <form id=\"form\" class=\"fm\" name=\"f\" action=\"/s\">\r\n      <span class=\"soutu-btn\"></span>\r\n        <input id=\"kw\" class=\"s_ipt\" name=\"wd\" value=\"\" maxlength=\"255\" autocomplete=\"off\">\r\n~~~\r\n\r\n#### <span style=\"color:red;\">Q1:我们的目的是要定位input标签的输入框。</span>\r\n\r\n- 通过id定位：\r\n\r\n  ```java\r\n  driver.findElement(By.id(\"kw\"))\r\n  ```\r\n\r\n- 通过name定位：\r\n\r\n  ```java\r\n  driver.findElement(By.name(\"wd\"))\r\n  ```\r\n\r\n- 通过class name定位：\r\n\r\n  ```java\r\n  driver.findElement(By.className(\"s_ipt\"))\r\n  ```\r\n\r\n- 通过tag name定位：\r\n\r\n  ```java\r\n  driver.findElement(By.tagName(\"input\"))\r\n  ```\r\n\r\n- 通过xpath定位，xpath定位有N种写法，这里列几个常用写法：\r\n\r\n  ```java\r\n  driver.findElement(By.xpath(\"//*[@id=\'kw\']\"))\r\n  driver.findElement(By.xpath(\"//*[@name=\'wd\']\"))\r\n  driver.findElement(By.xpath(\"//input[@class=\'s_ipt\']\"))\r\n  driver.findElement(By.xpath(\"/html/body/form/span/input\"))\r\n  driver.findElement(By.xpath(\"//span[@class=\'soutu-btn\']/input\"))\r\n  driver.findElement(By.xpath(\"//form[@id=\'form\']/span/input\"))\r\n  driver.findElement(By.xpath(\"//input[@id=\'kw\' and @name=\'wd\']\"))\r\n  ```\r\n\r\n- 通过css定位，css定位有N种写法，这里列几个常用写法：\r\n\r\n  ```java\r\n  driver.findElement(By.cssSelector(\"#kw\")\r\n  driver.findElement(By.cssSelector(\"[name=wd]\")\r\n  driver.findElement(By.cssSelector(\".s_ipt\")\r\n  driver.findElement(By.cssSelector(\"html > body > form > span > input\")\r\n  driver.findElement(By.cssSelector(\"span.soutu-btn> input#kw\")\r\n  driver.findElement(By.cssSelector(\"form#form > span > input\")\r\n  ```\r\n\r\n#### <span style=\"color:red;\">Q2:我们的页面上有一组文本链接。</span>\r\n\r\n```java\r\n<a class=\"mnav\" href=\"http://news.baidu.com\" name=\"tj_trnews\">新闻</a>\r\n<a class=\"mnav\" href=\"http://www.hao123.com\" name=\"tj_trhao123\">hao123</a>\r\n```\r\n\r\n- 通过link text定位：\r\n\r\n  ```java\r\n  driver.findElement(By.linkText(\"新闻\")\r\n  driver.findElement(By.linkText(\"hao123\")\r\n  ```\r\n\r\n- 通过partialLink text定位：\r\n\r\n  ```java\r\n  driver.findElement(By.partialLinkText(\"新\")\r\n  driver.findElement(By.partialLinkText(\"hao\")\r\n  driver.findElement(By.partialLinkText(\"123\")\r\n  ```\r\n\r\n关于xpaht和css的定位比较复杂，请参考：[ xpath语法](http://www.w3school.com.cn/xpath/xpath_syntax.asp)、[css选择器](http://www.w3school.com.cn/cssref/css_selectors.asp)\r\n\r\n#### <span style=\"color:red;\">Q3:定位一组元素</span>\r\n\r\n~~~java\r\nWebDriver driver = new ChromeDriver();\r\ndriver.get(\"https://www.baidu.com/\");\r\n\r\nWebElement search_text = driver.findElement(By.id(\"kw\"));\r\nsearch_text.sendKeys(\"selenium\");\r\nsearch_text.submit();\r\nThread.sleep(2000);\r\n\r\n//匹配第一页搜索结果的标题， 循环打印\r\nList<WebElement> search_result = driver.findElements(By.xpath(\"//div/div/h3\"));\r\n\r\n//打印元素的个数\r\nSystem.out.println(search_result.size());\r\n\r\n// 循环打印搜索结果的标题\r\nfor(WebElement result : search_result){\r\n    System.out.println(result.getText());\r\n}\r\n\r\nSystem.out.println(\"-------我是分割线---------\");\r\n\r\n//打印第n结果的标题\r\nWebElement text = search_result.get(search_result.size() - 10);\r\nSystem.out.println(text.getText());\r\n\r\ndriver.quit();\r\n~~~\r\n\r\n\r\n\r\n## 二、控制浏览器窗口\r\n\r\n### 1、浏览器窗口大小\r\n\r\n>- maximize() 设置浏览器最大化\r\n>- setSize() 设置浏览器宽高\r\n\r\n~~~java\r\n// 设置浏览器驱动程序位置\r\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \r\n\r\n// 开启浏览器 访问pc版百度\r\nWebDriver driver= new ChromeDriver();\r\ndriver.get(\"https://www.baidu.cn\");\r\n \r\n// 设置窗口最大话\r\ndriver.manage().window().maximize();\r\nThread.sleep(2000);\r\n \r\n// 访问移动版百度，自定义窗口大小\r\ndriver.get(\"https://m.baidu.cn\");\r\ndriver.manage().window().setSize(new Dimension(480, 800));\r\nThread.sleep(2000);\r\n \r\n// 关闭浏览器（注：这种有时候会关不掉）\r\ndriver.quit();\r\n~~~\r\n\r\n\r\n\r\n### 2、浏览器前进后退\r\n\r\n~~~java\r\n// 设置浏览器驱动程序位置 & 开启浏览器\r\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \r\nWebDriver driver = new ChromeDriver();\r\n \r\n//get 到百度首页\r\ndriver.get(\"https://www.baidu.com/\");\r\nSystem.out.printf(\"now accesss %s \\n\", driver.getCurrentUrl());\r\nThread.sleep(2000);\r\n\r\n//点击“新闻” 链接\r\ndriver.findElement(By.linkText(\"新闻\")).click();\r\nSystem.out.printf(\"now accesss %s \\n\", driver.getCurrentUrl());\r\nThread.sleep(2000);\r\n\r\n//执行浏览器后退\r\ndriver.navigate().back();\r\nSystem.out.printf(\"back to %s \\n\", driver.getCurrentUrl());\r\nThread.sleep(2000);\r\n\r\n//执行浏览器前面\r\ndriver.navigate().forward();\r\nSystem.out.printf(\"forward to %s \\n\", driver.getCurrentUrl());\r\nThread.sleep(2000);\r\n\r\ndriver.quit();\r\n~~~\r\n\r\n### 3、刷新页面\r\n\r\n> refresh() 刷新页面（F5）\r\n\r\n~~~java\r\n……\r\n// 刷新页面\r\ndriver.navigate().refresh();\r\n……\r\n~~~\r\n\r\n## 三、webDriver常用方法\r\n\r\n### 1、常用方法\r\n\r\n> - clear() 清除文本。\r\n> - sendKeys(*value) 模拟按键输入。\r\n> - click() 单击元素\r\n\r\n~~~java\r\n// 设置浏览器驱动程序位置 & 开启浏览器\r\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \r\nWebDriver driver = new ChromeDriver();\r\ndriver.get(\"https://www.baidu.com/\");\r\n\r\n// 获取目标元素\r\nWebElement search_text = driver.findElement(By.id(\"kw\"));\r\nWebElement search_button = driver.findElement(By.id(\"su\"));\r\n\r\n// clear & sendKeys & click\r\nsearch_text.sendKeys(\"Java\");\r\nsearch_text.clear();\r\nsearch_text.sendKeys(\"Selenium\");\r\nsearch_button.click();\r\n\r\ndriver.quit();\r\n~~~\r\n\r\n### 2、其他方法\r\n\r\n> submit()\r\n\r\n~~~java\r\n……\r\nWebElement search_text = driver.findElement(By.id(\"kw\"));\r\nsearch_text.sendKeys(\"Selenium\");\r\nsearch_text.submit();// 模拟执行提交\r\n……\r\n~~~\r\n\r\n> - getSize() 返回元素的尺寸。\r\n> - getText() 获取元素的文本。\r\n> - getAttribute(name) 获得属性值。\r\n> - isDisplayed() 设置该元素是否用户可见。\r\n\r\n~~~java\r\n// 设置浏览器驱动程序位置 & 开启浏览器\r\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \r\nWebDriver driver = new ChromeDriver();\r\ndriver.get(\"https://www.baidu.com/\");\r\n\r\n//获得百度输入框的尺寸\r\nWebElement size = driver.findElement(By.id(\"kw\"));\r\nSystem.out.println(size.getSize());\r\n\r\n//返回百度页面底部备案信息\r\nWebElement text = driver.findElement(By.id(\"cp\"));\r\nSystem.out.println(text.getText());\r\n\r\n//返回元素的属性值， 可以是 id、 name、 type 或元素拥有的其它任意属性\r\nWebElement ty = driver.findElement(By.id(\"kw\"));\r\nSystem.out.println(ty.getAttribute(\"type\"));\r\n\r\n//返回元素的结果是否可见， 返回结果为 True 或 False\r\nWebElement display = driver.findElement(By.id(\"kw\"));\r\nSystem.out.println(display.isDisplayed());\r\n\r\ndriver.quit();\r\n~~~\r\n\r\n## 四、鼠标操作\r\n\r\n> - contextClick() 右击\r\n> - clickAndHold() 鼠标点击并控制\r\n> - doubleClick() 双击\r\n> - dragAndDrop() 拖动\r\n> - release() 释放鼠标\r\n> - perform() 执行所有Actions中存储的行为\r\n\r\n### 1、悬停显示下拉菜单\r\n\r\n~~~java\r\n// 设置浏览器驱动程序位置 & 开启浏览器\r\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \r\nWebDriver driver = new ChromeDriver();\r\ndriver.get(\"https://www.baidu.com/\");\r\n\r\nWebElement search_setting = driver.findElement(By.linkText(\"设置\"));\r\nActions action = new Actions(driver);\r\naction.clickAndHold(search_setting).perform();\r\n\r\ndriver.quit();\r\n~~~\r\n\r\n\r\n\r\n### 2、鼠标其他操作\r\n\r\n~~~java\r\n......\r\nActions action = new Actions(driver);\r\n \r\n// 鼠标右键点击指定的元素\r\naction.contextClick(driver.findElement(By.id(\"element\"))).perform();\r\n \r\n// 鼠标右键点击指定的元素\r\naction.doubleClick(driver.findElement(By.id(\"element\"))).perform();\r\n \r\n// 鼠标拖拽动作， 将 source 元素拖放到 target 元素的位置。\r\nWebElement source = driver.findElement(By.name(\"element\"));\r\nWebElement target = driver.findElement(By.name(\"element\"));\r\naction.dragAndDrop(source,target).perform();\r\n \r\n// 释放鼠标\r\naction.release().perform();\r\n......\r\n~~~\r\n\r\n## 五、键盘操作\r\n\r\n> sendKeys(Keys.BACK_SPACE) 回格键（BackSpace）\r\n> sendKeys(Keys.SPACE) 空格键(Space)\r\n> sendKeys(Keys.TAB) 制表键(Tab)\r\n> sendKeys(Keys.ESCAPE) 回退键（Esc）\r\n> sendKeys(Keys.ENTER) 回车键（Enter）\r\n> sendKeys(Keys.CONTROL,‘a’) 全选（Ctrl+A）\r\n> sendKeys(Keys.CONTROL,‘c’) 复制（Ctrl+C）\r\n> sendKeys(Keys.CONTROL,‘x’) 剪切（Ctrl+X）\r\n> sendKeys(Keys.CONTROL,‘v’) 粘贴（Ctrl+V）\r\n> sendKeys(Keys.F1) 键盘 F1\r\n> ……\r\n\r\n### 1、模拟键盘操作\r\n\r\n~~~java\r\n// 设置浏览器驱动程序位置 & 开启浏览器\r\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \r\nWebDriver driver = new ChromeDriver();\r\ndriver.get(\"https://www.baidu.com\");\r\n\r\nWebElement input = driver.findElement(By.id(\"kw\"));\r\n\r\n//输入框输入内容\r\ninput.sendKeys(\"seleniumm\");\r\nThread.sleep(2000);\r\n\r\n//删除多输入的一个 m\r\ninput.sendKeys(Keys.BACK_SPACE);\r\nThread.sleep(2000);\r\n\r\n//输入空格键+“教程”\r\ninput.sendKeys(Keys.SPACE);\r\ninput.sendKeys(\"教程\");\r\nThread.sleep(2000);\r\n\r\n//ctrl+a 全选输入框内容\r\ninput.sendKeys(Keys.CONTROL,\"a\");\r\nThread.sleep(2000);\r\n\r\n//ctrl+x 剪切输入框内容\r\ninput.sendKeys(Keys.CONTROL,\"x\");\r\nThread.sleep(2000);\r\n\r\n//ctrl+v 粘贴内容到输入框\r\ninput.sendKeys(Keys.CONTROL,\"v\");\r\nThread.sleep(2000);\r\n\r\n//通过回车键盘来代替点击操作\r\ninput.sendKeys(Keys.ENTER);\r\nThread.sleep(2000);\r\n\r\ndriver.quit();\r\n~~~\r\n\r\n## 六、元素等待\r\n\r\n> WebDriver提供了两种类型的等待：<span style=\"color:#42B983;font-weight:bold;\">显式等待</span> 和 <span style=\"color:#42B983;font-weight:bold;\">隐式等待</span>。\r\n\r\n### 1、显示等待\r\n\r\n~~~java\r\n// 设置浏览器驱动程序位置 & 开启浏览器\r\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \r\nWebDriver driver = new ChromeDriver();\r\ndriver.get(\"https://www.baidu.com\");\r\n\r\n//显式等待， 针对某个元素等待\r\nWebDriverWait wait = new WebDriverWait(driver,10,1);\r\n\r\nwait.until(new ExpectedCondition<WebElement>(){\r\n    @Override\r\n    public WebElement apply(WebDriver text) {\r\n        return text.findElement(By.id(\"kw\"));\r\n    }\r\n}).sendKeys(\"selenium\");\r\n\r\ndriver.findElement(By.id(\"su\")).click();\r\nThread.sleep(2000);\r\n\r\ndriver.quit();\r\n~~~\r\n\r\n\r\n\r\n### 2、隐式等待\r\n\r\n~~~java\r\n// 设置浏览器驱动程序位置 & 开启浏览器\r\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \r\nWebDriver driver = new ChromeDriver();\r\n\r\n//页面加载超时时间设置为 5s\r\ndriver.manage().timeouts().pageLoadTimeout(5, TimeUnit.SECONDS);\r\ndriver.get(\"https://www.baidu.com/\");\r\n\r\n//定位对象时给 10s 的时间, 如果 10s 内还定位不到则抛出异常\r\ndriver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);\r\ndriver.findElement(By.id(\"kw\")).sendKeys(\"selenium\");\r\n\r\n//异步脚本的超时时间设置成 3s\r\ndriver.manage().timeouts().setScriptTimeout(3, TimeUnit.SECONDS);\r\n\r\ndriver.quit();\r\n\r\n~~~\r\n\r\n## 七、多表单切换\r\n\r\n> 在 Web 应用中经常会遇到 frame/iframe 表单嵌套页面的应用， WebDriver 只能在一个页面上对元素识别与 定位， 对于 frame/iframe 表单内嵌页面上的元素无法直接定位。 这时就需要通过 switchTo().frame()方法将当前定 位的主体切换为 frame/iframe 表单的内嵌页面中。\r\n\r\n~~~html\r\n<html>\r\n  <body>\r\n    ...\r\n    <iframe id=\"x-URS-iframe\" ...>\r\n      <html>\r\n         <body>\r\n           ...\r\n           <input name=\"email\" >\r\n~~~\r\n\r\n> 126邮箱登录框的结构大概是这样子的，想要操作登录框必须要先切换到iframe表单。\r\n\r\n~~~java\r\n// 设置浏览器驱动程序位置 & 开启浏览器\r\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \r\nWebDriver driver = new ChromeDriver();\r\ndriver.get(\"http://www.126.com\");\r\n\r\nWebElement xf = driver.findElement(By.xpath(\"//*[@id=\'loginDiv\']/iframe\"));\r\ndriver.switchTo().frame(xf);\r\ndriver.findElement(By.name(\"email\")).clear();\r\ndriver.findElement(By.name(\"email\")).sendKeys(\"username\");\r\ndriver.findElement(By.name(\"password\")).clear();\r\ndriver.findElement(By.name(\"password\")).sendKeys(\"password\");\r\ndriver.findElement(By.id(\"dologin\")).click();\r\ndriver.switchTo().defaultContent();\r\n//……\r\n~~~\r\n\r\n<span style=\"color:red;\">注:如果完成了在当前表单上的操作，则可以通过switchTo().defaultContent()方法跳出表单。</span>\r\n\r\n## 八、多窗口切换\r\n\r\n> - getWindowHandle()： 获得当前窗口句柄。\r\n> - getWindowHandles()： 返回的所有窗口的句柄到当前会话。\r\n> - switchTo().window()： 用于切换到相应的窗口，与上一节的switchTo().frame()类似，前者用于不同窗口的切换， 后者用于不同表单之间的切换。\r\n\r\n~~~java\r\n// 设置浏览器驱动程序位置 & 开启浏览器\r\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \r\nWebDriver driver = new ChromeDriver();\r\ndriver.get(\"https://www.baidu.com\");\r\n\r\n//获得当前窗口句柄\r\nString search_handle = driver.getWindowHandle();\r\n\r\n//打开百度注册窗口\r\ndriver.findElement(By.linkText(\"登录\")).click();\r\nThread.sleep(3000);\r\ndriver.findElement(By.linkText(\"立即注册\")).click();\r\n\r\n//获得所有窗口句柄\r\nSet<String> handles = driver.getWindowHandles();\r\n\r\n//判断是否为注册窗口， 并操作注册窗口上的元素\r\nfor(String handle : handles){\r\n    if (handle.equals(search_handle)==false){\r\n        //切换到注册页面\r\n        driver.switchTo().window(handle);\r\n        System.out.println(\"now register window!\");\r\n        Thread.sleep(2000);\r\n        driver.findElement(By.name(\"userName\")).clear();\r\n        driver.findElement(By.name(\"userName\")).sendKeys(\"user name\");\r\n        driver.findElement(By.name(\"phone\")).clear();\r\n        driver.findElement(By.name(\"phone\")).sendKeys(\"phone number\");\r\n        //......\r\n        Thread.sleep(2000);\r\n        //关闭当前窗口\r\n        driver.close();\r\n    }\r\n}\r\nThread.sleep(2000);\r\n\r\ndriver.quit();\r\n~~~\r\n\r\n## 九、下拉框选择\r\n\r\n> 有时我们会碰到下拉框，WebDriver提供了Select类来处理下接框。\r\n\r\n* html 代码\r\n\r\n  ~~~java\r\n  <select id=\"nr\" name=\"NR\">\r\n    <option value=\"10\" selected>每页显示 10 条</option>\r\n    <option value=\"20\">每页显示 20 条</option>\r\n    <option value=\"50\">每页显示 50 条</option>\r\n  <select>\r\n  ~~~\r\n\r\n* java代码\r\n\r\n  ~~~java\r\n  // 设置浏览器驱动程序位置 & 开启浏览器\r\n  System.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \r\n  WebDriver driver = new ChromeDriver();\r\n  driver.get(\"https://www.baidu.com\");\r\n  \r\n  driver.findElement(By.linkText(\"设置\")).click();\r\n  driver.findElement(By.linkText(\"搜索设置\")).click();\r\n  Thread.sleep(2000);\r\n  \r\n  //<select>标签的下拉框选择\r\n  WebElement el = driver.findElement(By.xpath(\"//select\"));\r\n  Select sel = new Select(el);\r\n  sel.selectByValue(\"20\");\r\n  Thread.sleep(2000);\r\n  \r\n  driver.quit();\r\n  ~~~\r\n\r\n  \r\n\r\n## 十、警告框处理\r\n\r\n> - getText()： 返回 alert/confirm/prompt 中的文字信息。\r\n> - accept()： 接受现有警告框。\r\n> - dismiss()： 解散现有警告框。\r\n> - sendKeys(keysToSend)： 发送文本至警告框。\r\n> - keysToSend： 将文本发送至警告框。\r\n\r\n~~~java\r\n// 设置浏览器驱动程序位置 & 开启浏览器\r\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \r\nWebDriver driver = new ChromeDriver();\r\ndriver.get(\"https://www.baidu.com\");\r\n\r\ndriver.findElement(By.linkText(\"设置\")).click();\r\ndriver.findElement(By.linkText(\"搜索设置\")).click();\r\nThread.sleep(2000);\r\n\r\n//保存设置\r\ndriver.findElement(By.className(\"prefpanelgo\")).click();\r\n\r\n//接收弹窗\r\ndriver.switchTo().alert().accept();\r\nThread.sleep(2000);\r\n\r\ndriver.quit();\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n## 十一、Cookies操作\r\n\r\n> - getCookies() 获得所有 cookie 信息。\r\n> - getCookieNamed(String name) 返回字典的key为“name”的Cookie信息。\r\n> - addCookie(cookie dict) 添加Cookie。“cookie_dict”指字典对象，必须有 name和value值。\r\n> - deleteCookieNamed(String name) 删除Cookie 信息。 “name”是要删除的 cookie的名称； “optionsString” 是该Cookie的选项，目前支持的选项包括“路径” ， “域” 。\r\n> - deleteAllCookies() 删除所有 cookie 信息\r\n\r\n~~~java\r\n// 设置浏览器驱动程序位置 & 开启浏览器\r\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \r\nWebDriver driver = new ChromeDriver();\r\ndriver.get(\"https://www.baidu.com\");\r\n\r\nCookie c1 = new Cookie(\"name\", \"key-aaaaaaa\");\r\nCookie c2 = new Cookie(\"value\", \"value-bbbbbb\");\r\ndriver.manage().addCookie(c1);\r\ndriver.manage().addCookie(c2);\r\n\r\n//获得 cookie\r\nSet<Cookie> coo = driver.manage().getCookies();\r\nSystem.out.println(coo);\r\n\r\n//删除所有 cookie\r\n//driver.manage().deleteAllCookies();\r\n\r\ndriver.quit();\r\n\r\n~~~\r\n\r\n\r\n\r\n## 十二、执行js\r\n\r\n>window.scrollTo()方法用于设置浏览器窗口滚动条的水平和垂直位置。方法的第一个参数表示水平的左间距，第二个参数表示垂直的上边距\r\n\r\n~~~java\r\n// 设置浏览器驱动程序位置 & 开启浏览器\r\nSystem.setProperty(\"webdriver.chrome.driver\", \"浏览器驱动路径\"); \r\nWebDriver driver = new ChromeDriver();\r\n\r\n//设置浏览器窗口大小\r\ndriver.manage().window().setSize(new Dimension(700, 600));\r\ndriver.get(\"https://www.baidu.com\");\r\n\r\n//进行百度搜索\r\ndriver.findElement(By.id(\"kw\")).sendKeys(\"webdriver api\");\r\ndriver.findElement(By.id(\"su\")).click();\r\nThread.sleep(2000);\r\n\r\n//将页面滚动条拖到底部\r\n((JavascriptExecutor)driver).executeScript(\"window.scrollTo(100,450);\");\r\nThread.sleep(3000);\r\n\r\ndriver.quit();\r\n~~~\r\n\r\n\r\n\r\n## 小进阶\r\n\r\n### 1、页面缩放\r\n\r\n~~~java\r\nJavascriptExecutor js = (JavascriptExecutor) driver;\r\njs.executeScript(\"document.body.style.zoom = \'30%\'\");\r\n// 或\r\n((JavascriptExecutor)driver).executeScript(\"document.body.style.zoom =\'70%\'\");\r\n~~~\r\n\r\n### 2、强制杀死浏览器及驱动程序\r\n\r\n~~~java\r\nWindowsUtils.killByName(\"chrome.exe\");\r\nWindowsUtils.killByName(\"firefox.exe\");\r\nWindowsUtils.killByName(\"chromedriver.exe\");\r\nWindowsUtils.killByName(\"geckodriver.exe\");\r\n// 注：由于selenium的版本问题 可能会存在方法名不一样情况\r\n~~~\r\n\r\n### 3、获取新窗口关闭原窗口\r\n\r\n~~~java\r\nString currentHand = driver.getWindowHandle();\r\nfor(String hand : driver.getWindowHandles()){\r\n    if(!currentHand.equals(hand)){\r\n        driver.close();\r\n        driver.switchTo().window(hand);\r\n        break;\r\n    }\r\n}\r\n~~~\r\n\r\n### 4、selenium获取验证码图片\r\n\r\n~~~java\r\nSystem.setProperty(\"webdriver.chrome.driver\",\"C:/chromedriver.exe\");\r\nWebDriver driver = new ChromeDriver();\r\ndriver.manage().window().maximize();\r\ndriver.get(\"https://agent.lionairthai.com/B2BAdmin/Login.aspx?CU=207&culture=en-GB\");\r\n\r\nWebElement ele = driver.findElement(By.id(\"ucAgentLogin_rdCapImage_CaptchaImageUP\"));\r\nWrapsDriver wrapsDriver = (WrapsDriver) ele;\r\nFile screenshot = ((TakesScreenshot)wrapsDriver.getWrappedDriver()).getScreenshotAs(OutputType.FILE);\r\nBufferedImage fullImg=ImageIO.read(screenshot);\r\nint screenshotWidth = fullImg.getWidth();\r\nDimension dimension = driver.manage().window().getSize();\r\ndouble scale = (double) dimension.getWidth() / screenshotWidth;\r\nPoint point= ele.getLocation();\r\nint eleWidth= ele.getSize().getWidth()+10;\r\nint eleHeight= ele.getSize().getHeight()+10;\r\nBufferedImage eleScreenshot= fullImg.getSubimage((int)(point.getX() / scale),(int)(point.getY() / scale), (int)(eleWidth / scale), (int)(eleHeight / scale));\r\nImageIO.write(eleScreenshot, \"jpg\", screenshot);\r\nFile screenshotLocation= new File(\"D:\\\\tmp\\\\test.jpg\");\r\nFileUtils.copyFile(screenshot, screenshotLocation);\r\ndriver.quit();\r\n~~~\r\n\r\n","timestamp":1642514536573}]